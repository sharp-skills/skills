{"d": "[![ioredis](https://cdn.jsdelivr.net/gh/redis/ioredis@b5e8c74/logo.svg)](https://github.com/redis/ioredis)\n\n[![Build Status](https://github.com/redis/ioredis/actions/workflows/release.yml/badge.svg?branch=main)](https://github.com/redis/ioredis/actions/workflows/release.yml?query=branch%3Amain)\n[![Coverage Status](https://coveralls.io/repos/github/luin/ioredis/badge.svg?branch=main)](https://coveralls.io/github/luin/ioredis?branch=main)\n[![Commitizen friendly](https://img.shields.io/badge/commitizen-friendly-brightgreen.svg)](http://commitizen.github.io/cz-cli/)\n[![semantic-release](https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg)](https://github.com/semantic-release/semantic-release)\n\n[![Discord](https://img.shields.io/discord/697882427875393627.svg?style=social&logo=discord)](https://discord.gg/redis)\n[![Twitch](https://img.shields.io/twitch/status/redisinc?style=social)](https://www.twitch.tv/redisinc)\n[![YouTube](https://img.shields.io/youtube/channel/views/UCD78lHSwYqMlyetR0_P4Vig?style=social)](https://www.youtube.com/redisinc)\n[![Twitter](https://img.shields.io/twitter/follow/redisinc?style=social)](https://twitter.com/redisinc)\n\nA robust, performance-focused and full-featured [Redis](http://redis.io) client for [Node.js](https://nodejs.org).\n\nSupports Redis >= 2.6.12. Completely compatible with Redis 7.x.\n\nioredis is a stable project and maintenance is done on a best-effort basis for relevant issues (contributions to ioredis will still be evaluated, reviewed, and merged when they benefit the project). For new projects, node-redis is the recommended client library. [node-redis](https://github.com/redis/node-redis) is the open-source (MIT license) Redis JavaScript client library redesigned from the ground up and actively maintained. [node-redis](https://github.com/redis/node-redis) supports new (hash-field expiration) and future commands and the capabilities available in Redis Stack and Redis 8 (search, JSON, time-series, probabilistic data structures).\n\n# Features\n\nioredis is a robust, full-featured Redis client that is\nused in the world's biggest online commerce company [Alibaba](http://www.alibaba.com/) and many other awesome companies.\n\n0. Full-featured. It supports [Cluster](http://redis.io/topics/cluster-tutorial), [Sentinel](https://redis.io/docs/latest/operate/oss_and_stack/management/sentinel/), [Streams](https://redis.io/topics/streams-intro), [Pipelining](http://redis.io/topics/pipelining), and of course [Lua scripting](http://redis.io/commands/eval), [Redis Functions](https://redis.io/topics/functions-intro), [Pub/Sub](http://redis.io/topics/pubsub) (with the support of binary messages).\n1. High performance \ud83d\ude80.\n2. Delightful API \ud83d\ude04. It works with Node callbacks and Native promises.\n3. Transformation of command arguments and replies.\n4. Transparent key prefixing.\n5. Abstraction for Lua scripting, allowing you to [define custom commands](https://github.com/redis/ioredis#lua-scripting).\n6. Supports [binary data](https://github.com/redis/ioredis#handle-binary-data).\n7. Supports [TLS](https://github.com/redis/ioredis#tls-options) \ud83d\udd12.\n8. Supports offline queue and ready checking.\n9. Supports ES6 types, such as `Map` and `Set`.\n10. Supports GEO commands \ud83d\udccd.\n11. Supports Redis ACL.\n12. Sophisticated error handling strategy.\n13. Supports NAT mapping.\n14. Supports autopipelining.\n\n**100% written in TypeScript and official declarations are provided:**\n\n<img width=\"837\" src=\"resources/ts-screenshot.png\" alt=\"TypeScript Screenshot\" />\n\n# Versions\n\n| Version        | Branch | Node.js Version | Redis Version   |\n| -------------- | ------ | --------------- | --------------- |\n| 5.x.x (latest) | main   | >= 12           | 2.6.12 ~ latest |\n| 4.x.x          | v4     | >= 8            | 2.6.12 ~ 7      |\n\nRefer to [CHANGELOG.md](CHANGELOG.md) for features and bug fixes introduced in v5.\n\n\ud83d\ude80 [Upgrading from v4 to v5](https://github.com/redis/ioredis/wiki/Upgrading-from-v4-to-v5)\n\n# Links\n\n- [API Documentation](https://redis.github.io/ioredis/) ([Redis](https://redis.github.io/ioredis/classes/Redis.html), [Cluster](https://redis.github.io/ioredis/classes/Cluster.html))\n- [Changelog](CHANGELOG.md)\n\n<hr>\n\n# Quick Start\n\n## Install\n\n```shell\nnpm install ioredis\n```\n\nIn a TypeScript project, you may want to add TypeScript declarations for Node.js:\n\n```shell\nnpm install --save-dev @types/node\n```\n\n## Basic Usage\n\n```javascript\n// Import ioredis.\n// You can also use `import { Redis } from \"ioredis\"`\n// if your project is a TypeScript project,\n// Note that `import Redis from \"ioredis\"` is still supported,\n// but will be deprecated in the next major version.\nconst Redis = require(\"ioredis\");\n\n// Create a Redis instance.\n// By default, it will connect to localhost:6379.\n// We are going to cover how to specify connection options soon.\nconst redis = new Redis();\n\nredis.set(\"mykey\", \"value\"); // Returns a promise which resolves to \"OK\" when the command succeeds.\n\n// ioredis supports the node.js callback style\nredis.get(\"mykey\", (err, result) => {\n  if (err) {\n    console.error(err);\n  } else {\n    console.log(result); // Prints \"value\"\n  }\n});\n\n// Or ioredis returns a promise if the last argument isn't a function\nredis.get(\"mykey\").then((result) => {\n  console.log(result); // Prints \"value\"\n});\n\nredis.zadd(\"sortedSet\", 1, \"one\", 2, \"dos\", 4, \"quatro\", 3, \"three\");\nredis.zrange(\"sortedSet\", 0, 2, \"WITHSCORES\").then((elements) => {\n  // [\"one\", \"1\", \"dos\", \"2\", \"three\", \"3\"] as if the command was `redis> ZRANGE sortedSet 0 2 WITHSCORES`\n  console.log(elements);\n});\n\n// All arguments are passed directly to the redis server,\n// so technically ioredis supports all Redis commands.\n// The format is: redis[SOME_REDIS_COMMAND_IN_LOWERCASE](ARGUMENTS_ARE_JOINED_INTO_COMMAND_STRING)\n// so the following statement is equivalent to the CLI: `redis> SET mykey hello EX 10`\nredis.set(\"mykey\", \"hello\", \"EX\", 10);\n```\n\nSee the `examples/` folder for more examples. For example:\n\n- [TTL](examples/ttl.js)\n- [Strings](examples/string.js)\n- [Hashes](examples/hash.js)\n- [Lists](examples/list.js)\n- [Sets](examples/set.js)\n- [Sorted Sets](examples/zset.js)\n- [Streams](examples/stream.js)\n- [Redis Modules](examples/module.js) e.g. RedisJSON\n\nAll Redis commands are supported. See [the documentation](https://redis.github.io/ioredis/classes/Redis.html) for details.\n\n## Connect to Redis\n\nWhen a new `Redis` instance is created,\na connection to Redis will be created at the same time.\nYou can specify which Redis to connect to by:\n\n```javascript\nnew Redis(); // Connect to 127.0.0.1:6379\nnew Redis(6380); // 127.0.0.1:6380\nnew Redis(6379, \"192.168.1.1\"); // 192.168.1.1:6379\nnew Redis(\"/tmp/redis.sock\");\nnew Redis({\n  port: 6379, // Redis port\n  host: \"127.0.0.1\", // Redis host\n  username: \"default\", // needs Redis >= 6\n  password: \"my-top-secret\",\n  db: 0, // Defaults to 0\n});\n```\n\nYou can also specify connection options as a [`redis://` URL](http://www.iana.org/assignments/uri-schemes/prov/redis) or [`rediss://` URL](https://www.iana.org/assignments/uri-schemes/prov/rediss) when using [TLS encryption](#tls-options):\n\n```javascript\n// Connect to 127.0.0.1:6380, db 4, using password \"authpassword\":\nnew Redis(\"redis://:authpassword@127.0.0.1:6380/4\");\n\n// Username can also be passed via URI.\nnew Redis(\"redis://username:authpassword@127.0.0.1:6380/4\");\n```\n\nSee [API Documentation](https://redis.github.io/ioredis/index.html#RedisOptions) for all available options.\n\n## Pub/Sub\n\nRedis provides several commands for developers to implement the [Publish\u2013subscribe pattern](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern). There are two roles in this pattern: publisher and subscriber. Publishers are not programmed to send their messages to specific subscribers. Rather, published messages are characterized into channels, without knowledge of what (if any) subscribers there may be.\n\nBy leveraging Node.js's built-in events module, ioredis makes pub/sub very straightforward to use. Below is a simple example that consists of two files, one is publisher.js that publishes messages to a channel, the other is subscriber.js that listens for messages on specific channels.\n\n```javascript\n// publisher.js\n\nconst Redis = require(\"ioredis\");\nconst redis = new Redis();\n\nsetInterval(() => {\n  const message = { foo: Math.random() };\n  // Publish to my-channel-1 or my-channel-2 randomly.\n  const channel = `my-channel-${1 + Math.round(Math.random())}`;\n\n  // Message can be either a string or a buffer\n  redis.publish(channel, JSON.stringify(message));\n  console.log(\"Published %s to %s\", message, channel);\n}, 1000);\n```\n\n```javascript\n// subscriber.js\n\nconst Redis = require(\"ioredis\");\nconst redis = new Redis();\n\nredis.subscribe(\"my-channel-1\", \"my-channel-2\", (err, count) => {\n  if (err) {\n    // Just like other commands, subscribe() can fail for some reasons,\n    // ex network issues.\n    console.error(\"Failed to subscribe: %s\", err.message);\n  } else {\n    // `count` represents the number of channels this client are currently subscribed to.\n    console.log(\n      `Subscribed successfully! This client is currently subscribed to ${count} channels.`\n    );\n  }\n});\n\nredis.on(\"message\", (channel, message) => {\n  console.log(`Received ${message} from ${channel}`);\n});\n\n// There's also an event called 'messageBuffer', which is the same as 'message' except\n// it returns buffers instead of strings.\n// It's useful when the messages are binary data.\nredis.on(\"messageBuffer\", (channel, message) => {\n  // Both `channel` and `message` are buffers.\n  console.log(channel, message);\n});\n```\n\nIt's worth noticing that a connection (aka a `Redis` instance) can't play both roles at the same time. More specifically, when a client issues `subscribe()` or `psubscribe()`, it enters the \"subscriber\" mode. From that point, only commands that modify the subscription set are valid. Namely, they are: `subscribe`, `psubscribe`, `unsubscribe`, `punsubscribe`, `ping`, and `quit`. When the subscription set is empty (via `unsubscribe`/`punsubscribe`), the connection is put back into the regular mode.\n\nIf you want to do pub/sub in the same file/process, you should create a separate connection:\n\n```javascript\nconst Redis = require(\"ioredis\");\nconst sub = new Redis();\nconst pub = new Redis();\n\nsub.subscribe(/* ... */); // From now, `sub` enters the subscriber mode.\nsub.on(\"message\" /* ... */);\n\nsetInterval(() => {\n  // `pub` can be used to publish messages, or send other regular commands (e.g. `hgetall`)\n  // because it's not in the subscriber mode.\n  pub.publish(/* ... */);\n}, 1000);\n```\n\n`PSUBSCRIBE` is also supported in a similar way when you want to subscribe all channels whose name matches a pattern:\n\n```javascript\nredis.psubscribe(\"pat?ern\", (err, count) => {});\n\n// Event names are \"pmessage\"/\"pmessageBuffer\" instead of \"message/messageBuffer\".\nredis.on(\"pmessage\", (pattern, channel, message) => {});\nredis.on(\"pmessageBuffer\", (pattern, channel, message) => {});\n```\n\n## Streams\n\nRedis v5 introduces a new data type called streams. It doubles as a communication channel for building streaming architectures and as a log-like data structure for persisting data. With ioredis, the usage can be pretty straightforward. Say we have a producer publishes messages to a stream with `redis.xadd(\"mystream\", \"*\", \"randomValue\", Math.random())` (You may find the [official documentation of Streams](https://redis.io/topics/streams-intro) as a starter to understand the parameters used), to consume the messages, we'll have a consumer with the following code:\n\n```javascript\nconst Redis = require(\"ioredis\");\nconst redis = new Redis();\n\nconst processMessage = (message) => {\n  console.log(\"Id: %s. Data: %O\", message[0], message[1]);\n};\n\nasync function listenForMessage(lastId = \"$\") {\n  // `results` is an array, each element of which corresponds to a key.\n  // Because we only listen to one key (mystream) here, `results` only contains\n  // a single element. See more: https://redis.io/commands/xread#return-value\n  const results = await redis.xread(\"BLOCK\", 0, \"STREAMS\", \"mystream\", lastId);\n  const [key, messages] = results[0]; // `key` equals to \"mystream\"\n\n  messages.forEach(processMessage);\n\n  // Pass the last id of the results to the next round.\n  await listenForMessage(messages[messages.length - 1][0]);\n}\n\nlistenForMessage();\n```\n\n## Expiration\n\nRedis can set a timeout to expire your key, after the timeout has expired the key will be automatically deleted. (You can find the [official Expire documentation](https://redis.io/commands/expire/) to understand better the different parameters you can use), to set your key to expire in 60 seconds, we will have the following code:\n\n```javascript\nredis.set(\"key\", \"data\", \"EX\", 60);\n// Equivalent to redis command \"SET key data EX 60\", because on ioredis set method,\n// all arguments are passed directly to the redis server.\n```\n\n## Handle Binary Data\n\nBinary data support is out of the box. Pass buffers to send binary data:\n\n```javascript\nredis.set(\"foo\", Buffer.from([0x62, 0x75, 0x66]));\n```\n\nEvery command that returns a [bulk string](https://redis.io/docs/reference/protocol-spec/#resp-bulk-strings)\nhas a variant command with a `Buffer` suffix. The variant command returns a buffer instead of a UTF-8 string:\n\n```javascript\nconst result = await redis.getBuffer(\"foo\");\n// result is `<Buffer 62 75 66>`\n```\n\nIt's worth noticing that you don't need the `Buffer` suffix variant in order to **send** binary data. That means\nin most case you should just use `redis.set()` instead of `redis.setBuffer()` unless you want to get the old value\nwith the `GET` parameter:\n\n```javascript\nconst result = await redis.setBuffer(\"foo\", \"new value\", \"GET\");\n// result is `<Buffer 62 75 66>` as `GET` indicates returning the old value.\n```\n\n## Pipelining\n\nIf you want to send a batch of commands (e.g. > 5), you can use pipelining to queue\nthe commands in memory and then send them to Redis all at once. This way the performance improves by 50%~300% (See [benchmark section](#benchmarks)).\n\n`redis.pipeline()` creates a `Pipeline` instance. You can call any Redis\ncommands on it just like the `Redis` instance. The commands are queued in memory\nand flushed to Redis by calling the `exec` method:\n\n```javascript\nconst pipeline = redis.pipeline();\npipeline.set(\"foo\", \"bar\");\npipeline.del(\"cc\");\npipeline.exec((err, results) => {\n  // `err` is always null, and `results` is an array of responses\n  // corresponding to the sequence of queued commands.\n  // Each response follows the format `[err, result]`.\n});\n\n// You can even chain the commands:\nredis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .del(\"cc\")\n  .exec((err, results) => {});\n\n// `exec` also returns a Promise:\nconst promise = redis.pipeline().set(\"foo\", \"bar\").get(\"foo\").exec();\npromise.then((result) => {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nEach chained command can also have a callback, which will be invoked when the command\ngets a reply:\n\n```javascript\nredis\n  .pipeline()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\", (err, result) => {\n    // result === 'bar'\n  })\n  .exec((err, result) => {\n    // result[1][1] === 'bar'\n  });\n```\n\nIn addition to adding commands to the `pipeline` queue individually, you can also pass an array of commands and arguments to the constructor:\n\n```javascript\nredis\n  .pipeline([\n    [\"set\", \"foo\", \"bar\"],\n    [\"get\", \"foo\"],\n  ])\n  .exec(() => {\n    /* ... */\n  });\n```\n\n`#length` property shows how many commands in the pipeline:\n\n```javascript\nconst length = redis.pipeline().set(\"foo\", \"bar\").get(\"foo\").length;\n// length === 2\n```\n\n## Transaction\n\nMost of the time, the transaction commands `multi` & `exec` are used together with pipeline.\nTherefore, when `multi` is called, a `Pipeline` instance is created automatically by default,\nso you can use `multi` just like `pipeline`:\n\n```javascript\nredis\n  .multi()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\")\n  .exec((err, results) => {\n    // results === [[null, 'OK'], [null, 'bar']]\n  });\n```\n\nIf there's a syntax error in the transaction's command chain (e.g. wrong number of arguments, wrong command name, etc),\nthen none of the commands would be executed, and an error is returned:\n\n```javascript\nredis\n  .multi()\n  .set(\"foo\")\n  .set(\"foo\", \"new value\")\n  .exec((err, results) => {\n    // err:\n    //  { [ReplyError: EXECABORT Transaction discarded because of previous errors.]\n    //    name: 'ReplyError',\n    //    message: 'EXECABORT Transaction discarded because of previous errors.',\n    //    command: { name: 'exec', args: [] },\n    //    previousErrors:\n    //     [ { [ReplyError: ERR wrong number of arguments for 'set' command]\n    //         name: 'ReplyError',\n    //         message: 'ERR wrong number of arguments for \\'set\\' command',\n    //         command: [Object] } ] }\n  });\n```\n\nIn terms of the interface, `multi` differs from `pipeline` in that when specifying a callback\nto each chained command, the queueing state is passed to the callback instead of the result of the command:\n\n```javascript\nredis\n  .multi()\n  .set(\"foo\", \"bar\", (err, result) => {\n    // result === 'QUEUED'\n  })\n  .exec(/* ... */);\n```\n\nIf you want to use transaction without pipeline, pass `{ pipeline: false }` to `multi`,\nand every command will be sent to Redis immediately without waiting for an `exec` invocation:\n\n```javascript\nredis.multi({ pipeline: false });\nredis.set(\"foo\", \"bar\");\nredis.get(\"foo\");\nredis.exec((err, result) => {\n  // result === [[null, 'OK'], [null, 'bar']]\n});\n```\n\nThe constructor of `multi` also accepts a batch of commands:\n\n```javascript\nredis\n  .multi([\n    [\"set\", \"foo\", \"bar\"],\n    [\"get\", \"foo\"],\n  ])\n  .exec(() => {\n    /* ... */\n  });\n```\n\nInline transactions are supported by pipeline, which means you can group a subset of commands\nin the pipeline into a transaction:\n\n```javascript\nredis\n  .pipeline()\n  .get(\"foo\")\n  .multi()\n  .set(\"foo\", \"bar\")\n  .get(\"foo\")\n  .exec()\n  .get(\"foo\")\n  .exec();\n```\n\n## Lua Scripting\n\nioredis supports all of the scripting commands such as `EVAL`, `EVALSHA` and `SCRIPT`.\nHowever, it's tedious to use in real world scenarios since developers have to take\ncare of script caching and to detect when to use `EVAL` and when to use `EVALSHA`.\nioredis exposes a `defineCommand` method to make scripting much easier to use:\n\n```javascript\nconst redis = new Redis();\n\n// This will define a command myecho:\nredis.defineCommand(\"myecho\", {\n  numberOfKeys: 2,\n  lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\",\n});\n\n// Now `myecho` can be used just like any other ordinary command,\n// and ioredis will try to use `EVALSHA` internally when possible for better performance.\nredis.myecho(\"k1\", \"k2\", \"a1\", \"a2\", (err, result) => {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n\n// `myechoBuffer` is also defined automatically to return buffers instead of strings:\nredis.myechoBuffer(\"k1\", \"k2\", \"a1\", \"a2\", (err, result) => {\n  // result[0] equals to Buffer.from('k1');\n});\n\n// And of course it works with pipeline:\nredis.pipeline().set(\"foo\", \"bar\").myecho(\"k1\", \"k2\", \"a1\", \"a2\").exec();\n```\n\n### Dynamic Keys\n\nIf the number of keys can't be determined when defining a command, you can\nomit the `numberOfKeys` property and pass the number of keys as the first argument\nwhen you call the command:\n\n```javascript\nredis.defineCommand(\"echoDynamicKeyNumber\", {\n  lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\",\n});\n\n// Now you have to pass the number of keys as the first argument every time\n// you invoke the `echoDynamicKeyNumber` command:\nredis.echoDynamicKeyNumber(2, \"k1\", \"k2\", \"a1\", \"a2\", (err, result) => {\n  // result === ['k1', 'k2', 'a1', 'a2']\n});\n```\n\n### As Constructor Options\n\nBesides `defineCommand()`, you can also define custom commands with the `scripts` constructor option:\n\n```javascript\nconst redis = new Redis({\n  scripts: {\n    myecho: {\n      numberOfKeys: 2,\n      lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\",\n    },\n  },\n});\n```\n\n### TypeScript Usages\n\nYou can refer to [the example](examples/typescript/scripts.ts) for how to declare your custom commands.\n\n## Transparent Key Prefixing\n\nThis feature allows you to specify a string that will automatically be prepended\nto all the keys in a command, which makes it easier to manage your key\nnamespaces.\n\n**Warning** This feature won't apply to commands like [KEYS](http://redis.io/commands/KEYS) and [SCAN](http://redis.io/commands/scan) that take patterns rather than actual keys([#239](https://github.com/redis/ioredis/issues/239)),\nand this feature also won't apply to the replies of commands even if they are key names ([#325](https://github.com/redis/ioredis/issues/325)).\n\n```javascript\nconst fooRedis = new Redis({ keyPrefix: \"foo:\" });\nfooRedis.set(\"bar\", \"baz\"); // Actually sends SET foo:bar baz\n\nfooRedis.defineCommand(\"myecho\", {\n  numberOfKeys: 2,\n  lua: \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\",\n});\n\n// Works well with pipelining/transaction\nfooRedis\n  .pipeline()\n  // Sends SORT foo:list BY foo:weight_*->fieldname\n  .sort(\"list\", \"BY\", \"weight_*->fieldname\")\n  // Supports custom commands\n  // Sends EVALSHA xxx foo:k1 foo:k2 a1 a2\n  .myecho(\"k1\", \"k2\", \"a1\", \"a2\")\n  .exec();\n```\n\n## Transforming Arguments & Replies\n\nMost Redis commands take one or more Strings as arguments,\nand replies are sent back as a single String or an Array of Strings. However, sometimes\nyou may want something different. For instance, it would be more convenient if the `HGETALL`\ncommand returns a hash (e.g. `{ key: val1, key2: v2 }`) rather than an array of key values (e.g. `[key1, val1, key2, val2]`).\n\nioredis has a flexible system for transforming arguments and replies. There are two types\nof transformers, argument transformer and reply transformer:\n\n```javascript\nconst Redis = require(\"ioredis\");\n\n// Here's the built-in argument transformer converting\n// hmset('key', { k1: 'v1', k2: 'v2' })\n// or\n// hmset('key', new Map([['k1', 'v1'], ['k2', 'v2']]))\n// into\n// hmset('key', 'k1', 'v1', 'k2', 'v2')\nRedis.Command.setArgumentTransformer(\"hmset\", (args) => {\n  if (args.length === 2) {\n    if (args[1] instanceof Map) {\n      // utils is a internal module of ioredis\n      return [args[0], ...utils.convertMapToArray(args[1])];\n    }\n    if (typeof args[1] === \"object\" && args[1] !== null) {\n      return [args[0], ...utils.convertObjectToArray(args[1])];\n    }\n  }\n  return args;\n});\n\n// Here's the built-in reply transformer converting the HGETALL reply\n// ['k1', 'v1', 'k2', 'v2']\n// into\n// { k1: 'v1', 'k2': 'v2' }\nRedis.Command.setReplyTransformer(\"hgetall\", (result) => {\n  if (Array.isArray(result)) {\n    const obj = {};\n    for (let i = 0; i < result.length; i += 2) {\n      obj[result[i]] = result[i + 1];\n    }\n    return obj;\n  }\n  return result;\n});\n```\n\nThere are three built-in transformers, two argument transformers for `hmset` & `mset` and\na reply transformer for `hgetall`. Transformers for `hmset` and `hgetall` were mentioned\nabove, and the transformer for `mset` is similar to the one for `hmset`:\n\n```javascript\nredis.mset({ k1: \"v1\", k2: \"v2\" });\nredis.get(\"k1\", (err, result) => {\n  // result === 'v1';\n});\n\nredis.mset(\n  new Map([\n    [\"k3\", \"v3\"],\n    [\"k4\", \"v4\"],\n  ])\n);\nredis.get(\"k3\", (err, result) => {\n  // result === 'v3';\n});\n```\n\nAnother useful example of a reply transformer is one that changes `hgetall` to return array of arrays instead of objects which avoids an unwanted conversation of hash keys to strings when dealing with binary hash keys:\n\n```javascript\nRedis.Command.setReplyTransformer(\"hgetall\", (result) => {\n  const arr = [];\n  for (let i = 0; i < result.length; i += 2) {\n    arr.push([result[i], result[i + 1]]);\n  }\n  return arr;\n});\nredis.hset(\"h1\", Buffer.from([0x01]), Buffer.from([0x02]));\nredis.hset(\"h1\", Buffer.from([0x03]), Buffer.from([0x04]));\nredis.hgetallBuffer(\"h1\", (err, result) => {\n  // result === [ [ <Buffer 01>, <Buffer 02> ], [ <Buffer 03>, <Buffer 04> ] ];\n});\n```\n\n## Monitor\n\nRedis supports the MONITOR command,\nwhich lets you see all commands received by the Redis server across all client connections,\nincluding from other client libraries and other computers.\n\nThe `monitor` method returns a monitor instance.\nAfter you send the MONITOR command, no other commands are valid on that connection. ioredis will emit a monitor event for every new monitor message that comes across.\nThe callback for the monitor event takes a timestamp from the Redis server and an array of command arguments.\n\nHere is a simple example:\n\n```javascript\nredis.monitor((err, monitor) => {\n  monitor.on(\"monitor\", (time, args, source, database) => {});\n});\n```\n\nHere is another example illustrating an `async` function and `monitor.disconnect()`:\n\n```javascript\nasync () => {\n  const monitor = await redis.monitor();\n  monitor.on(\"monitor\", console.log);\n  // Any other tasks\n  monitor.disconnect();\n};\n```\n\n## Streamify Scanning\n\nRedis 2.8 added the `SCAN` command to incrementally iterate through the keys in the database. It's different from `KEYS` in that\n`SCAN` only returns a small number of elements each call, so it can be used in production without the downside\nof blocking the server for a long time. However, it requires recording the cursor on the client side each time\nthe `SCAN` command is called in order to iterate through all the keys correctly. Since it's a relatively common use case, ioredis\nprovides a streaming interface for the `SCAN` command to make things much easier. A readable stream can be created by calling `scanStream`:\n\n```javascript\nconst redis = new Redis();\n// Create a readable stream (object mode)\nconst stream = redis.scanStream();\nstream.on(\"data\", (resultKeys) => {\n  // `resultKeys` is an array of strings representing key names.\n  // Note that resultKeys may contain 0 keys, and that it will sometimes\n  // contain duplicates due to SCAN's implementation in Redis.\n  for (let i = 0; i < resultKeys.length; i++) {\n    console.log(resultKeys[i]);\n  }\n});\nstream.on(\"end\", () => {\n  console.log(\"all keys have been visited\");\n});\n```\n\n`scanStream` accepts an option, with which you can specify the `MATCH` pattern, the `TYPE` filter, and the `COUNT` argument:\n\n```javascript\nconst stream = redis.scanStream({\n  // only returns keys following the pattern of `user:*`\n  match: \"user:*\",\n  // only return objects that match a given type,\n  // (requires Redis >= 6.0)\n  type: \"zset\",\n  // returns approximately 100 elements per call\n  count: 100,\n});\n```\n\nJust like other commands, `scanStream` has a binary version `scanBufferStream`, which returns an array of buffers. It's useful when\nthe key names are not utf8 strings.\n\nThere are also `hscanStream`, `zscanStream` and `sscanStream` to iterate through elements in a hash, zset and set. The interface of each is\nsimilar to `scanStream` except the first argument is the key name:\n\n```javascript\nconst stream = redis.zscanStream(\"myhash\", {\n  match: \"age:??\",\n});\n```\nThe `hscanStream` also accepts the `noValues` option to specify whether Redis should return only the keys in the hash table without their corresponding values.\n```javascript\nconst stream = redis.hscanStream(\"myhash\", {\n  match: \"age:??\",\n  noValues: true,\n});\n```\nYou can learn more from the [Redis documentation](http://redis.io/commands/scan).\n\n**Useful Tips**\nIt's pretty common that doing an async task in the `data` handler. We'd like the scanning process to be paused until the async task to be finished. `Stream#pause()` and `Stream#resume()` do the trick. For example if we want to migrate data in Redis to MySQL:\n\n```javascript\nconst stream = redis.scanStream();\nstream.on(\"data\", (resultKeys) => {\n  // Pause the stream from scanning more keys until we've migrated the current keys.\n  stream.pause();\n\n  Promise.all(resultKeys.map(migrateKeyToMySQL)).then(() => {\n    // Resume the stream here.\n    stream.resume();\n  });\n});\n\nstream.on(\"end\", () => {\n  console.log(\"done migration\");\n});\n```\n\n## Auto-reconnect\n\nBy default, ioredis will try to reconnect when the connection to Redis is lost\nexcept when the connection is closed manually by `redis.disconnect()` or `redis.quit()`.\n\nIt's very flexible to control how long to wait to reconnect after disconnection\nusing the `retryStrategy` option:\n\n```javascript\nconst redis = new Redis({\n  // This is the default value of `retryStrategy`\n  retryStrategy(times) {\n    const delay = Math.min(times * 50, 2000);\n    return delay;\n  },\n});\n```\n\n`retryStrategy` is a function that will be called when the connection is lost.\nThe argument `times` means this is the nth reconnection being made and\nthe return value represents how long (in ms) to wait to reconnect. When the\nreturn value isn't a number, ioredis will stop trying to reconnect, and the connection\nwill be lost forever if the user doesn't call `redis.connect()` manually.\n\nWhen reconnected, the client will auto subscribe to channels that the previous connection subscribed to.\nThis behavior can be disabled by setting the `autoResubscribe` option to `false`.\n\nAnd if the previous connection has some unfulfilled commands (most likely blocking commands such as `brpop` and `blpop`),\nthe client will resend them when reconnected. This behavior can be disabled by setting the `autoResendUnfulfilledCommands` option to `false`.\n\nBy default, all pending commands will be flushed with an error every 20 retry attempts. That makes sure commands won't wait forever when the connection is down. You can change this behavior by setting `maxRetriesPerRequest`:\n\n```javascript\nconst redis = new Redis({\n  maxRetriesPerRequest: 1,\n});\n```\n\nSet maxRetriesPerRequest to `null` to disable this behavior, and every command will wait forever until the connection is alive again (which is the default behavior before ioredis v4).\n\n### Blocking Command Timeout\n\nioredis can apply a client-side timeout to blocking commands (such as `blpop`, `brpop`, `bzpopmin`, `bzmpop`, `blmpop`, `xread`, `xreadgroup`, etc.). This protects against scenarios where the TCP connection becomes a zombie (e.g., due to a s"}