{"d": {"exhaustive": {"nbHits": false, "typo": false}, "exhaustiveNbHits": false, "exhaustiveTypo": false, "hits": [{"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "Croffasia"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["vue", "production"], "value": "The Problem We're Solving<p>Setting up a <em>production</em>-ready <em>Vue</em>.js project takes days. You need to configure TypeScript, set up build tools, choose the right state management, configure linting, add UI components, set up testing\u2014and then teach your AI coding assistant how to work with your specific stack and patterns.<p>By the time you're done with setup, you've lost momentum on your actual idea.<p>The pattern is predictable:<p>Day 1-2: Research and configure build tools, TypeScript, linting \nDay 3-4: Set up state management, routing, UI components\nDay 5-6: Configure development workflow, AI coding instructions \nDay 7+: Finally start building your actual application<p>Most developers either skip best practices to move fast, or spend weeks on setup instead of building.<p>Our Solution: <em>Production</em>-Ready Starter + AI Instructions<p>Vibe Code Kit eliminates the setup phase entirely. You get a battle-tested <em>Vue</em>.js stack that's been refined through dozens of <em>production</em> applications, plus AI development instructions that teach Claude Code how to work effectively with your specific setup.<p>Technology Stack:<p>- <em>Vue</em> 3 with Composition API and TypeScript support\n- Vite for lightning-fast development and optimized builds\n- Pinia for global state management + Pinia Colada for data fetching\n- Tailwind CSS + DaisyUI for rapid UI development\n- VueUse composables library for common patterns\n- ESLint, Prettier, Husky for code quality<p>Each technology includes AI coding best practices that prevent Claude Code from reinventing patterns.<p>How It Works<p>- Blueprint-Driven Development: Enhanced R&amp;D workflow commands guide Claude Code through proper project analysis and feature planning\n- Specialized AI Agents: Built-in agents for standards checking, code validation, and codebase research\n- Stack-Specific Instructions: AI learns the proper patterns for each library in your stack\n- <em>Production</em> Configuration: Everything pre-configured for deployment from day one\n- The result: Turn your ideas into <em>production</em> <em>Vue</em>.js apps in minutes, not days.<p>Real Impact\nSince using this approach:<p>- New <em>Vue</em>.js projects start with feature development, not configuration\n- Claude Code consistently follows <em>Vue</em> 3 Composition API best practices\n- AI agents catch architectural issues before they become problems\n- <em>Production</em> deployments work from day one<p>Technical Details<p>Built on <em>Vue</em> 3 ecosystem best practices. Includes comprehensive Claude Code integration with specialized agents for <em>Vue</em>.js development. Works with existing AI-assisted development workflows and supports rapid prototyping to <em>production</em> scaling.<p>Currently supporting <em>Vue</em>.js projects with plans for React and other frameworks.<p>Try It\nEarly access available at <a href=\"https://vibecodekit.dev\" rel=\"nofollow\">https://vibecodekit.dev</a><p>This isn't about replacing <em>Vue</em> CLI or Vite\u2014it's about getting a <em>production</em>-ready foundation with AI that actually understands your stack. Would love feedback from <em>Vue</em>.js developers who've struggled with project setup overhead.<p>Questions I'm curious about:<p>- How much time do you spend on initial <em>Vue</em>.js project configuration?\n- What's been your experience with AI coding assistants on <em>Vue</em> projects?\n- What would convince you to use a pre-configured starter over building from scratch?"}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Show HN: Vibe Code Kit code with confidence"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://vibecodekit.dev"}}, "_tags": ["story", "author_Croffasia", "story_45216336", "show_hn"], "author": "Croffasia", "children": [45235122], "created_at": "2025-09-11T21:34:46Z", "created_at_i": 1757626486, "num_comments": 1, "objectID": "45216336", "points": 3, "story_id": 45216336, "story_text": "The Problem We&#x27;re Solving<p>Setting up a production-ready Vue.js project takes days. You need to configure TypeScript, set up build tools, choose the right state management, configure linting, add UI components, set up testing\u2014and then teach your AI coding assistant how to work with your specific stack and patterns.<p>By the time you&#x27;re done with setup, you&#x27;ve lost momentum on your actual idea.<p>The pattern is predictable:<p>Day 1-2: Research and configure build tools, TypeScript, linting \nDay 3-4: Set up state management, routing, UI components\nDay 5-6: Configure development workflow, AI coding instructions \nDay 7+: Finally start building your actual application<p>Most developers either skip best practices to move fast, or spend weeks on setup instead of building.<p>Our Solution: Production-Ready Starter + AI Instructions<p>Vibe Code Kit eliminates the setup phase entirely. You get a battle-tested Vue.js stack that&#x27;s been refined through dozens of production applications, plus AI development instructions that teach Claude Code how to work effectively with your specific setup.<p>Technology Stack:<p>- Vue 3 with Composition API and TypeScript support\n- Vite for lightning-fast development and optimized builds\n- Pinia for global state management + Pinia Colada for data fetching\n- Tailwind CSS + DaisyUI for rapid UI development\n- VueUse composables library for common patterns\n- ESLint, Prettier, Husky for code quality<p>Each technology includes AI coding best practices that prevent Claude Code from reinventing patterns.<p>How It Works<p>- Blueprint-Driven Development: Enhanced R&amp;D workflow commands guide Claude Code through proper project analysis and feature planning\n- Specialized AI Agents: Built-in agents for standards checking, code validation, and codebase research\n- Stack-Specific Instructions: AI learns the proper patterns for each library in your stack\n- Production Configuration: Everything pre-configured for deployment from day one\n- The result: Turn your ideas into production Vue.js apps in minutes, not days.<p>Real Impact\nSince using this approach:<p>- New Vue.js projects start with feature development, not configuration\n- Claude Code consistently follows Vue 3 Composition API best practices\n- AI agents catch architectural issues before they become problems\n- Production deployments work from day one<p>Technical Details<p>Built on Vue 3 ecosystem best practices. Includes comprehensive Claude Code integration with specialized agents for Vue.js development. Works with existing AI-assisted development workflows and supports rapid prototyping to production scaling.<p>Currently supporting Vue.js projects with plans for React and other frameworks.<p>Try It\nEarly access available at <a href=\"https:&#x2F;&#x2F;vibecodekit.dev\" rel=\"nofollow\">https:&#x2F;&#x2F;vibecodekit.dev</a><p>This isn&#x27;t about replacing Vue CLI or Vite\u2014it&#x27;s about getting a production-ready foundation with AI that actually understands your stack. Would love feedback from Vue.js developers who&#x27;ve struggled with project setup overhead.<p>Questions I&#x27;m curious about:<p>- How much time do you spend on initial Vue.js project configuration?\n- What&#x27;s been your experience with AI coding assistants on Vue projects?\n- What would convince you to use a pre-configured starter over building from scratch?", "title": "Show HN: Vibe Code Kit code with confidence", "updated_at": "2025-10-06T15:47:47Z", "url": "https://vibecodekit.dev"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "benhowdle"}, "title": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["vue", "production"], "value": "Notes on using <em>Vue</em> and React in <em>production</em>"}, "url": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["vue", "production"], "value": "https://benhowdle.im/notes-on-using-<em>vue</em>-and-react-in-<em>production</em>.html"}}, "_tags": ["story", "author_benhowdle", "story_16677828"], "author": "benhowdle", "created_at": "2018-03-26T10:10:49Z", "created_at_i": 1522059049, "num_comments": 0, "objectID": "16677828", "points": 2, "story_id": 16677828, "title": "Notes on using Vue and React in production", "updated_at": "2024-09-20T02:17:40Z", "url": "https://benhowdle.im/notes-on-using-vue-and-react-in-production.html"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "daiwei"}, "title": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["vue", "production"], "value": "<em>Vue</em> React Perf \u2013 Use <em>production</em> mode for React that strips out all the warnings"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://github.com/footballradar/VueReactPerf/pull/3"}}, "_tags": ["story", "author_daiwei", "story_11764985"], "author": "daiwei", "created_at": "2016-05-24T19:56:00Z", "created_at_i": 1464119760, "num_comments": 0, "objectID": "11764985", "points": 2, "story_id": 11764985, "title": "Vue React Perf \u2013 Use production mode for React that strips out all the warnings", "updated_at": "2024-09-19T23:16:20Z", "url": "https://github.com/footballradar/VueReactPerf/pull/3"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "Fatpandac"}, "title": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["vue", "production"], "value": "Why <em>Vue</em>.config.<em>production</em>Tip Not Work?"}, "url": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["vue", "production"], "value": "https://www.fatpandac.com/docs/2023/03/why_<em>vue</em>.config.<em>production</em>tip_not_work"}}, "_tags": ["story", "author_Fatpandac", "story_35351631"], "author": "Fatpandac", "created_at": "2023-03-29T02:46:52Z", "created_at_i": 1680058012, "num_comments": 0, "objectID": "35351631", "points": 1, "story_id": 35351631, "title": "Why Vue.config.productionTip Not Work?", "updated_at": "2024-09-20T13:39:00Z", "url": "https://www.fatpandac.com/docs/2023/03/why_vue.config.productiontip_not_work"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "Hendrixer"}, "story_text": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["vue"], "value": "<em>Vue</em> is hot right now. Curious to know who's using it, why, and what for. Or just links to some live apps."}, "title": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["vue", "production"], "value": "Ask HN: What are some big <em>Vue</em>.js projects in <em>production</em> right now?"}}, "_tags": ["story", "author_Hendrixer", "story_14817454", "ask_hn"], "author": "Hendrixer", "children": [14817736, 14817744, 14817768, 14817775, 14817815, 14818043, 14818162, 14818352, 14818492, 14819137, 14819194, 14819816, 14821033, 14821268, 14824806, 14824816], "created_at": "2017-07-21T01:24:01Z", "created_at_i": 1500600241, "num_comments": 28, "objectID": "14817454", "points": 42, "story_id": 14817454, "story_text": "Vue is hot right now. Curious to know who&#x27;s using it, why, and what for. Or just links to some live apps.", "title": "Ask HN: What are some big Vue.js projects in production right now?", "updated_at": "2024-09-20T01:05:14Z"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "adzicg"}, "title": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["vue", "production"], "value": "<em>Vue</em>.js and AWS Lambda: Developing <em>Production</em>-Ready Apps"}, "url": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["vue", "production"], "value": "https://auth0.com/blog/<em>vue</em>-js-and-lambda-developing-<em>production</em>-ready-apps-part-2/"}}, "_tags": ["story", "author_adzicg", "story_17455610"], "author": "adzicg", "created_at": "2018-07-04T06:34:19Z", "created_at_i": 1530686059, "num_comments": 0, "objectID": "17455610", "points": 2, "story_id": 17455610, "title": "Vue.js and AWS Lambda: Developing Production-Ready Apps", "updated_at": "2024-09-20T02:43:21Z", "url": "https://auth0.com/blog/vue-js-and-lambda-developing-production-ready-apps-part-2/"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "brndnbuilds"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["vue", "production"], "value": "Hi Everyone,<p>TunnlTo is a tool for controlling which Windows applications, processes, and IP addresses can use a WireGuard VPN tunnel. Here are some examples of how it could be used:<p>- Route only FireFox through a privacy VPN\n- Route Slack and Microsoft Office through a work VPN\n- Route a game through a gaming VPN\n- Stop a game from routing through a privacy VPN\n- Stop a browser from routing through a work VPN\n- Route a specific IP address range through a privacy VPN\n- Route all traffic through a privacy VPN except a specific IP address range<p>I have been collaborating on this project with the creator of WireSock - Vadim Smirnov.<p><i>&quot;WireSock VPN Client is a lightweight command line WireGuard VPN client for Windows that has advanced features not available in the official WireGuard for Windows such as selective application tunneling and disallowed IP addresses.<p>WireSock VPN Client combines the power of Windows Packet Filter and BoringTun (user space WireGuard implementation in Rust) to provide exceptional performance, security and scalability.&quot;</i><p>The TunnlTo app is built with Tauri and I've used boring old HTML, CSS (bootstrap) and JavaScript as I had major JS framework fatigue. I have previously built a <em>production</em> app with Electron and <em>Vue</em>. Tauri appealed to me for its use of Rust and its small installation sizes. I tried Tauri pre version 1.0 and had a bit of trouble but this time around its been a positive experience. The docs and the Discord community have come a long way.<p>I would appreciate any feedback about the project so I can get an idea of what direction to take it in next. Vadim will be around a little later if anyone is curious about the WireGuard implementation and wants to know more.<p>Thanks for reading!"}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Show HN: TunnlTo \u2013 Windows WireGuard split tunnel client built with Rust, Tauri"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://github.com/TunnlTo/desktop-app"}}, "_tags": ["story", "author_brndnbuilds", "story_34602444", "show_hn"], "author": "brndnbuilds", "children": [34602472, 34605231, 34605232, 34605268, 34605360, 34605470, 34605578, 34605602, 34606411, 34606651, 34606944, 34609097, 34609476, 34609639, 34610409], "created_at": "2023-01-31T21:28:41Z", "created_at_i": 1675200521, "num_comments": 45, "objectID": "34602444", "points": 136, "story_id": 34602444, "story_text": "Hi Everyone,<p>TunnlTo is a tool for controlling which Windows applications, processes, and IP addresses can use a WireGuard VPN tunnel. Here are some examples of how it could be used:<p>- Route only FireFox through a privacy VPN\n- Route Slack and Microsoft Office through a work VPN\n- Route a game through a gaming VPN\n- Stop a game from routing through a privacy VPN\n- Stop a browser from routing through a work VPN\n- Route a specific IP address range through a privacy VPN\n- Route all traffic through a privacy VPN except a specific IP address range<p>I have been collaborating on this project with the creator of WireSock - Vadim Smirnov.<p><i>&quot;WireSock VPN Client is a lightweight command line WireGuard VPN client for Windows that has advanced features not available in the official WireGuard for Windows such as selective application tunneling and disallowed IP addresses.<p>WireSock VPN Client combines the power of Windows Packet Filter and BoringTun (user space WireGuard implementation in Rust) to provide exceptional performance, security and scalability.&quot;</i><p>The TunnlTo app is built with Tauri and I&#x27;ve used boring old HTML, CSS (bootstrap) and JavaScript as I had major JS framework fatigue. I have previously built a production app with Electron and Vue. Tauri appealed to me for its use of Rust and its small installation sizes. I tried Tauri pre version 1.0 and had a bit of trouble but this time around its been a positive experience. The docs and the Discord community have come a long way.<p>I would appreciate any feedback about the project so I can get an idea of what direction to take it in next. Vadim will be around a little later if anyone is curious about the WireGuard implementation and wants to know more.<p>Thanks for reading!", "title": "Show HN: TunnlTo \u2013 Windows WireGuard split tunnel client built with Rust, Tauri", "updated_at": "2024-09-20T13:09:47Z", "url": "https://github.com/TunnlTo/desktop-app"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "katttrrr"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["vue", "production"], "value": "Okay, this is very much a general discussion topic, but it's something I've long discussed with other engineers and I'd really appreciate HN's input. It seems like a vast amount of extremely hyped up new frameworks quickly fall off for use in real <em>production</em> applications. For example, <em>Vue</em> was extremely hyped up but React quickly won out for most real world applications. Same goes for numerous new frameworks and libraries, as I'm sure you all know. My question is if we could come up with some sort of a framework of criteria to help us determine if and when we should start trying to apply the 'next big thing' in our real projects. It's so important to keep our skill sets up-to-date, but obviously we can stay current with everything to a substantial level of expertise and actual understanding without trying it in a real world application. Looking forward to hearing how everyone approaches this."}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Keeping Up with Coding Ecosystem"}}, "_tags": ["story", "author_katttrrr", "story_20528279", "ask_hn"], "author": "katttrrr", "children": [20528447, 20528567, 20530477], "created_at": "2019-07-25T18:54:35Z", "created_at_i": 1564080875, "num_comments": 6, "objectID": "20528279", "points": 1, "story_id": 20528279, "story_text": "Okay, this is very much a general discussion topic, but it&#x27;s something I&#x27;ve long discussed with other engineers and I&#x27;d really appreciate HN&#x27;s input. It seems like a vast amount of extremely hyped up new frameworks quickly fall off for use in real production applications. For example, Vue was extremely hyped up but React quickly won out for most real world applications. Same goes for numerous new frameworks and libraries, as I&#x27;m sure you all know. My question is if we could come up with some sort of a framework of criteria to help us determine if and when we should start trying to apply the &#x27;next big thing&#x27; in our real projects. It&#x27;s so important to keep our skill sets up-to-date, but obviously we can stay current with everything to a substantial level of expertise and actual understanding without trying it in a real world application. Looking forward to hearing how everyone approaches this.", "title": "Keeping Up with Coding Ecosystem", "updated_at": "2024-09-20T04:36:02Z"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "truth_seeker"}, "title": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["vue", "production"], "value": "Ask HN: Is Flutter Web <em>Production</em> Ready? Mature Compared to Angular/<em>Vue</em>/React?"}}, "_tags": ["story", "author_truth_seeker", "story_26940458", "ask_hn"], "author": "truth_seeker", "children": [26940801, 26945261, 26951469], "created_at": "2021-04-26T08:25:58Z", "created_at_i": 1619425558, "num_comments": 6, "objectID": "26940458", "points": 10, "story_id": 26940458, "title": "Ask HN: Is Flutter Web Production Ready? Mature Compared to Angular/Vue/React?", "updated_at": "2024-09-20T08:25:45Z"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "mike210"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["vue", "production"], "value": "Everyone hates <em>production</em> bugs. Users get frustrated.  Engineers get paged.  Development gets delayed.  But what if many of those bugs could be fixed automatically?<p>Enter Paladin, a tool I built that automatically sends you a pull request to fix bugs shortly after they occur.<p>A little over a month ago, I posted my hacky but effective AI setup for fixing <em>production</em> bugs to Reddit (<a href=\"https://redd.it/1jibmtc\" rel=\"nofollow\">https://redd.it/1jibmtc</a>).  300+ devs messaged me or commented wanting to try it out, so I\u2019ve been spending the past weeks refining it into Paladin, and excited to release it today!<p>How it works:<p>Paladin hooks into your application\u2019s error handling with an SDK, triggering a \u201crun\u201d when an exception is thrown.  During the run, Paladin pulls your code on Github and uses LLMs to fix the error, sending you the fix as a PR over Slack in ~90 seconds.   Here\u2019s a two minute demo: <a href=\"https://youtu.be/0bm8nq99Nrw\" rel=\"nofollow\">https://youtu.be/0bm8nq99Nrw</a>.<p>In early testing, Paladin solves over 55% of real <em>production</em> errors on the first try and makes useful progress on many others.  It\u2019s able to do well by supplying deep context to the LLMs: the stack trace, execution state, repo code, and more.  When it works well, it allows you to fix bugs more quickly, meaning less downtime for users and saved engineering time.<p>Eliminating context switching has been an unexpected win for me, because I work best in long, focused stretches.  When a bug hits affecting real users,  I have to drop everything mid-feature to stash changes, debug, and mentally shift contexts, and then try to return. I\u2019ve found PR reviews and tweaks to be much less disruptive.<p>Getting started (Free, no card required)\n1. Sign up at <a href=\"https://app.paladin.run/signup\" rel=\"nofollow\">https://app.paladin.run/signup</a>\n2. Follow instructions to connect your Github and Slack (or just email)\n3. Choose and install the correct SDK into your app\n4. Configure to send errors to Paladin\n5. Done!<p>Paladin supports React, React Native, Laravel, Flutter, Django, Node, Next, Vanilla Javascript, Express, FastAPI, PHP, Vanilla Python, Nest, <em>Vue</em>, Android, iOS, Rails, Flask, and many more  thanks to Sentry\u2019s MIT licensed client SDKs (your errors do not go to Sentry, they are just used to capture errors).  If you have a client and server, I\u2019d start with your server.<p>Notes on privacy, performance, and future plans below:<p>Paladin will never abuse repo access for any type of training or sharing, and only pulls it for making fixes.  An LLM provider (Google/Anthropic/OpenAI) processes part of your code, so if you can\u2019t use tools like Cursor/Windsurf, you probably can\u2019t use Paladin.<p>On performance, my personal set is admittedly very limited, but I think the performance makes sense to me given current bests on benchmarks like Aider Polyglot and SWE-bench Verified.  I\u2019d expect these numbers to get much better as models progress. I\u2019d also expect Paladin to fall short where current frontier LLMs do: uncommon frameworks, libraries or languages.<p>In the future, I am planning on having two usage options:\n- Free: if you bring your own OpenRouter API key\n- Paid: if Paladin pays for the model costs<p>Really looking forward to hearing feedback and ideas!"}, "title": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["production"], "value": "Show HN: Paladin \u2013 An AI trigger to fix your sh*t <em>production</em> bugs"}}, "_tags": ["story", "author_mike210", "story_43906288", "show_hn"], "author": "mike210", "created_at": "2025-05-06T15:32:21Z", "created_at_i": 1746545541, "num_comments": 0, "objectID": "43906288", "points": 5, "story_id": 43906288, "story_text": "Everyone hates production bugs. Users get frustrated.  Engineers get paged.  Development gets delayed.  But what if many of those bugs could be fixed automatically?<p>Enter Paladin, a tool I built that automatically sends you a pull request to fix bugs shortly after they occur.<p>A little over a month ago, I posted my hacky but effective AI setup for fixing production bugs to Reddit (<a href=\"https:&#x2F;&#x2F;redd.it&#x2F;1jibmtc\" rel=\"nofollow\">https:&#x2F;&#x2F;redd.it&#x2F;1jibmtc</a>).  300+ devs messaged me or commented wanting to try it out, so I\u2019ve been spending the past weeks refining it into Paladin, and excited to release it today!<p>How it works:<p>Paladin hooks into your application\u2019s error handling with an SDK, triggering a \u201crun\u201d when an exception is thrown.  During the run, Paladin pulls your code on Github and uses LLMs to fix the error, sending you the fix as a PR over Slack in ~90 seconds.   Here\u2019s a two minute demo: <a href=\"https:&#x2F;&#x2F;youtu.be&#x2F;0bm8nq99Nrw\" rel=\"nofollow\">https:&#x2F;&#x2F;youtu.be&#x2F;0bm8nq99Nrw</a>.<p>In early testing, Paladin solves over 55% of real production errors on the first try and makes useful progress on many others.  It\u2019s able to do well by supplying deep context to the LLMs: the stack trace, execution state, repo code, and more.  When it works well, it allows you to fix bugs more quickly, meaning less downtime for users and saved engineering time.<p>Eliminating context switching has been an unexpected win for me, because I work best in long, focused stretches.  When a bug hits affecting real users,  I have to drop everything mid-feature to stash changes, debug, and mentally shift contexts, and then try to return. I\u2019ve found PR reviews and tweaks to be much less disruptive.<p>Getting started (Free, no card required)\n1. Sign up at <a href=\"https:&#x2F;&#x2F;app.paladin.run&#x2F;signup\" rel=\"nofollow\">https:&#x2F;&#x2F;app.paladin.run&#x2F;signup</a>\n2. Follow instructions to connect your Github and Slack (or just email)\n3. Choose and install the correct SDK into your app\n4. Configure to send errors to Paladin\n5. Done!<p>Paladin supports React, React Native, Laravel, Flutter, Django, Node, Next, Vanilla Javascript, Express, FastAPI, PHP, Vanilla Python, Nest, Vue, Android, iOS, Rails, Flask, and many more  thanks to Sentry\u2019s MIT licensed client SDKs (your errors do not go to Sentry, they are just used to capture errors).  If you have a client and server, I\u2019d start with your server.<p>Notes on privacy, performance, and future plans below:<p>Paladin will never abuse repo access for any type of training or sharing, and only pulls it for making fixes.  An LLM provider (Google&#x2F;Anthropic&#x2F;OpenAI) processes part of your code, so if you can\u2019t use tools like Cursor&#x2F;Windsurf, you probably can\u2019t use Paladin.<p>On performance, my personal set is admittedly very limited, but I think the performance makes sense to me given current bests on benchmarks like Aider Polyglot and SWE-bench Verified.  I\u2019d expect these numbers to get much better as models progress. I\u2019d also expect Paladin to fall short where current frontier LLMs do: uncommon frameworks, libraries or languages.<p>In the future, I am planning on having two usage options:\n- Free: if you bring your own OpenRouter API key\n- Paid: if Paladin pays for the model costs<p>Really looking forward to hearing feedback and ideas!", "title": "Show HN: Paladin \u2013 An AI trigger to fix your sh*t production bugs", "updated_at": "2025-05-06T16:19:46Z"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "greatNespresso"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["vue", "production"], "value": "Hi folks,<p>Having played for long with Node on toy projects (mainly web targeted as the question suggests) I have always enjoyed the freedom of composing packages for everything, in a light Flaskish way and it turned out to always be sufficient for my needs.<p>Today, however, I am considering launching a more ambitious app, and I am feeling doubtful about my koa + sequelize + passport traditionnal backend setup for this use case.<p>Still, if React and <em>Vue</em> owns all the attention on the web right now, I haven't managed to find out a thread on the usual/accepted Node stack for backend, currently in use on <em>production</em> web app, as the prod and cons associated.<p>Are Frameworks like Meteor the usual way of going as in other languages like Python or Ruby, is MEAN still a/THE thing for Node considering the drawbacks associated with NoSQL, do you rather externalize services to PAAS like Firebase ?<p>Having, again, no experience with Node business apps, I would be eagerly curious and thankful for you to share your stack and opinion :)<p>Thanks !"}, "title": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["production"], "value": "Ask HN: Node stack for <em>production</em> web app in 2018"}}, "_tags": ["story", "author_greatNespresso", "story_17509748", "ask_hn"], "author": "greatNespresso", "children": [17510922, 17512423], "created_at": "2018-07-11T19:45:46Z", "created_at_i": 1531338346, "num_comments": 4, "objectID": "17509748", "points": 3, "story_id": 17509748, "story_text": "Hi folks,<p>Having played for long with Node on toy projects (mainly web targeted as the question suggests) I have always enjoyed the freedom of composing packages for everything, in a light Flaskish way and it turned out to always be sufficient for my needs.<p>Today, however, I am considering launching a more ambitious app, and I am feeling doubtful about my koa + sequelize + passport traditionnal backend setup for this use case.<p>Still, if React and Vue owns all the attention on the web right now, I haven&#x27;t managed to find out a thread on the usual&#x2F;accepted Node stack for backend, currently in use on production web app, as the prod and cons associated.<p>Are Frameworks like Meteor the usual way of going as in other languages like Python or Ruby, is MEAN still a&#x2F;THE thing for Node considering the drawbacks associated with NoSQL, do you rather externalize services to PAAS like Firebase ?<p>Having, again, no experience with Node business apps, I would be eagerly curious and thankful for you to share your stack and opinion :)<p>Thanks !", "title": "Ask HN: Node stack for production web app in 2018", "updated_at": "2024-09-20T02:42:52Z"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "plakhlani2"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["vue", "production"], "value": "Brick Starter is a .NET-based SaaS starter kit designed to help teams ship <em>production</em>-ready applications faster by handling the \u201cboring but hard\u201d parts of SaaS: auth, multi-tenancy, billing integration, infrastructure, and a modern frontend stack.<p>It ships with a modular architecture on .NET Core 8, support for multiple frontends (Angular, React/Next.js, <em>Vue</em>, Blazor, ASP.NET Core), and patterns for background jobs, caching, configuration, and observability. The goal is to let you start from a solid, opinionated base with good defaults, instead of wiring together boilerplate for every new project.<p>If you\u2019re building a new SaaS or modernizing an existing app, feedback on what\u2019s missing or feels over-engineered would be especially useful"}, "title": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["production"], "value": "Show HN: Brick Starter \u2013 .NET SaaS starter kit to ship <em>production</em> apps faster"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://www.brickstarter.net"}}, "_tags": ["story", "author_plakhlani2", "story_46189116", "show_hn"], "author": "plakhlani2", "children": [46189122], "created_at": "2025-12-08T06:35:10Z", "created_at_i": 1765175710, "num_comments": 1, "objectID": "46189116", "points": 2, "story_id": 46189116, "story_text": "Brick Starter is a .NET-based SaaS starter kit designed to help teams ship production-ready applications faster by handling the \u201cboring but hard\u201d parts of SaaS: auth, multi-tenancy, billing integration, infrastructure, and a modern frontend stack.<p>It ships with a modular architecture on .NET Core 8, support for multiple frontends (Angular, React&#x2F;Next.js, Vue, Blazor, ASP.NET Core), and patterns for background jobs, caching, configuration, and observability. The goal is to let you start from a solid, opinionated base with good defaults, instead of wiring together boilerplate for every new project.<p>If you\u2019re building a new SaaS or modernizing an existing app, feedback on what\u2019s missing or feels over-engineered would be especially useful", "title": "Show HN: Brick Starter \u2013 .NET SaaS starter kit to ship production apps faster", "updated_at": "2025-12-08T09:22:13Z", "url": "https://www.brickstarter.net"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "hankimis"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["vue", "production"], "value": "I kept running into the same problem with AI-generated frontend code: most tokens go to boilerplate, and the AI can never pick a consistent pattern. So I built a language where there's only one way to write things.<p>0x is indentation-based (think Python), declarative, and compiles to React JSX, <em>Vue</em> 3 SFC, or Svelte 5. A counter component is 18 lines in 0x vs 96 in <em>production</em> React.<p>page Counter:\n  state count: int = 0\n  fn increment():\n    count += 1\n  layout col gap=16 padding=24 center:\n    text &quot;{count}&quot; size=4xl color=cyan\n    button &quot;+1&quot; style=primary -&gt; increment()\nThe compiler is ~3K lines of TypeScript, zero dependencies. Pipeline: Lexer \u2192 Parser \u2192 AST \u2192 CodeGen (one pass per target). It handles state, derived values, typed variables, functions, flexbox layouts, control flow (if/elif/else, each, match), lifecycle hooks, API calls with loading/error states.<p>I chose indentation-based syntax because it's the most token-efficient structure I could find. No curly braces, no semicolons, no JSX closing tags, no import boilerplate. For an LLM, fewer structural decisions = fewer hallucinations.<p>There's a built-in MCP server so Claude and Cursor can compile inline. Also works as a library:<p>import { compile } from '0x-lang/compiler';\nconst result = compile(source, { target: 'react' });\nI'm curious about two things:<p>Is &quot;designed for AI&quot; a real market, or is this too niche?<p>For folks who've built compilers \u2014 any obvious mistakes you see in the architecture?<p>Website: <a href=\"https://0xlang.com\" rel=\"nofollow\">https://0xlang.com</a>\nGitHub: <a href=\"https://github.com/hankimis/0x-lang\" rel=\"nofollow\">https://github.com/hankimis/0x-lang</a>\nnpm: <a href=\"https://www.npmjs.com/package/0x-lang\" rel=\"nofollow\">https://www.npmjs.com/package/0x-lang</a>"}, "title": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["vue"], "value": "Show HN: 0x \u2013 A language that compiles to React, <em>Vue</em>, and Svelte (80% less code)"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://www.0xlang.com/"}}, "_tags": ["story", "author_hankimis", "story_46959021", "show_hn"], "author": "hankimis", "created_at": "2026-02-10T12:47:09Z", "created_at_i": 1770727629, "num_comments": 0, "objectID": "46959021", "points": 2, "story_id": 46959021, "story_text": "I kept running into the same problem with AI-generated frontend code: most tokens go to boilerplate, and the AI can never pick a consistent pattern. So I built a language where there&#x27;s only one way to write things.<p>0x is indentation-based (think Python), declarative, and compiles to React JSX, Vue 3 SFC, or Svelte 5. A counter component is 18 lines in 0x vs 96 in production React.<p>page Counter:\n  state count: int = 0\n  fn increment():\n    count += 1\n  layout col gap=16 padding=24 center:\n    text &quot;{count}&quot; size=4xl color=cyan\n    button &quot;+1&quot; style=primary -&gt; increment()\nThe compiler is ~3K lines of TypeScript, zero dependencies. Pipeline: Lexer \u2192 Parser \u2192 AST \u2192 CodeGen (one pass per target). It handles state, derived values, typed variables, functions, flexbox layouts, control flow (if&#x2F;elif&#x2F;else, each, match), lifecycle hooks, API calls with loading&#x2F;error states.<p>I chose indentation-based syntax because it&#x27;s the most token-efficient structure I could find. No curly braces, no semicolons, no JSX closing tags, no import boilerplate. For an LLM, fewer structural decisions = fewer hallucinations.<p>There&#x27;s a built-in MCP server so Claude and Cursor can compile inline. Also works as a library:<p>import { compile } from &#x27;0x-lang&#x2F;compiler&#x27;;\nconst result = compile(source, { target: &#x27;react&#x27; });\nI&#x27;m curious about two things:<p>Is &quot;designed for AI&quot; a real market, or is this too niche?<p>For folks who&#x27;ve built compilers \u2014 any obvious mistakes you see in the architecture?<p>Website: <a href=\"https:&#x2F;&#x2F;0xlang.com\" rel=\"nofollow\">https:&#x2F;&#x2F;0xlang.com</a>\nGitHub: <a href=\"https:&#x2F;&#x2F;github.com&#x2F;hankimis&#x2F;0x-lang\" rel=\"nofollow\">https:&#x2F;&#x2F;github.com&#x2F;hankimis&#x2F;0x-lang</a>\nnpm: <a href=\"https:&#x2F;&#x2F;www.npmjs.com&#x2F;package&#x2F;0x-lang\" rel=\"nofollow\">https:&#x2F;&#x2F;www.npmjs.com&#x2F;package&#x2F;0x-lang</a>", "title": "Show HN: 0x \u2013 A language that compiles to React, Vue, and Svelte (80% less code)", "updated_at": "2026-02-10T16:17:10Z", "url": "https://www.0xlang.com/"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "gls2ro"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["vue", "production"], "value": "I am currently starting a personal project with Rails 5.1 which I would like to release it in a couple of months and see if I can grow it.<p>I already decided to use <em>Vue</em>.js as the main FE framework.<p>(the reason for both of them is that I know them - rails for a couple of years, vuejs I am still learning but I can do basic stuff).<p>Currently I'm facing a decision as I dont want to create my own CSS framework:<p>1) Should I use Bootstrap v4 - alpha with Bootstrap <em>Vue</em> (https://bootstrap-<em>vue</em>.github.io)\nReasons: easy to find help with Bootstrap and probably a library which will last?<p>2) Should I just use http://vuetifyjs.com? Is it ready for being use in <em>production</em>?<p>3) Should I use a combination of Bootstrap v4 CSS styles + http://element.eleme.io for the Javascript elements?<p>The frontend part will be a mix of Turbolinks/Rails and Vuejs and not an independent Vuejs app."}, "title": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["vue"], "value": "Ask HN: What front end framework should I choose with Rails and <em>Vue</em>.js?"}}, "_tags": ["story", "author_gls2ro", "story_14542999", "ask_hn"], "author": "gls2ro", "children": [14633098], "created_at": "2017-06-13T05:26:59Z", "created_at_i": 1497331619, "num_comments": 1, "objectID": "14542999", "points": 1, "story_id": 14542999, "story_text": "I am currently starting a personal project with Rails 5.1 which I would like to release it in a couple of months and see if I can grow it.<p>I already decided to use Vue.js as the main FE framework.<p>(the reason for both of them is that I know them - rails for a couple of years, vuejs I am still learning but I can do basic stuff).<p>Currently I&#x27;m facing a decision as I dont want to create my own CSS framework:<p>1) Should I use Bootstrap v4 - alpha with Bootstrap Vue (https:&#x2F;&#x2F;bootstrap-vue.github.io)\nReasons: easy to find help with Bootstrap and probably a library which will last?<p>2) Should I just use http:&#x2F;&#x2F;vuetifyjs.com? Is it ready for being use in production?<p>3) Should I use a combination of Bootstrap v4 CSS styles + http:&#x2F;&#x2F;element.eleme.io for the Javascript elements?<p>The frontend part will be a mix of Turbolinks&#x2F;Rails and Vuejs and not an independent Vuejs app.", "title": "Ask HN: What front end framework should I choose with Rails and Vue.js?", "updated_at": "2024-09-20T00:56:46Z"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "BLGardner"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["vue", "production"], "value": "Hi HN, I'm Barry and I've built Prism.Tools (<a href=\"https://blgardner.github.io/prism.tools/\" rel=\"nofollow\">https://blgardner.github.io/prism.tools/</a>) \u2013 a collection of client-side developer utilities that respect your privacy.<p>Many of these tools were used way back in the days when I ran a BBS and started my communities first ISP, serving three local communities with Dial-Up Internet, Web Hosting etc. The tools have been refined to reflect the changes in tech since then and designed for the Novice and Pro alike. As I locate more tools others may find useful I will refine and add them to the collection. Use them, Share them, or not. They will be here if you need them...<p>40+ dev tools (JSON formatters, regex tester, base64 encoder, Git command helper, etc.) that run entirely in your browser.\nZero tracking, zero analytics, zero data collection \u2013 everything processes locally.\nSelf-contained HTML files with no build process or frameworks.<p>I realized I had a lot of tools/utilities I've built over the years for my own use. I lothe having to 'sign-up' just to access/use simple utilities that I can create myself. I've refined them and put them in one safe place so I could easily access them if/when needed. I decided to make them available via Github Pages for anyone that may find them useful. Prism.Tools is the result.<p>Each tool is a standalone HTML file with embedded CSS and JavaScript. No frameworks, no npm packages, no build steps \u2013 just open the file and it works.<p>The entire toolset:<p>- 100% client-side processing \u2013 your data never leaves your browser.<p>- No external dependencies except for specific libraries from cdnjs.cloudflare.com (marked.js for markdown, exifr for image metadata, etc.)<p>- Consistent dark UI \u2013 every tool follows the same design language for familiarity.<p>- Vanilla JS where possible \u2013 only reaching for Public CDN Resources when necessary.<p>The constraint of &quot;single HTML file&quot; was intentional. It forces simplicity and ensures tools remain maintainable. It also means users can inspect, modify, or self-host any tool trivially.<p>These tools have helped me with debugging <em>production</em> issues, Quick formatting tasks, learning Git commands (the Git command helper has been particularly helpful)<p>Just visit <a href=\"https://blgardner.github.io/prism.tools/\" rel=\"nofollow\">https://blgardner.github.io/prism.tools/</a> and try any tool. No signup, no install.<p>What tools are missing that you find yourself needing?\nAny performance issues with specific tools?\nUI/UX friction points?<p>All tools follow the same privacy-first philosophy...\nYour data stays in your browser. No accounts, no tracking, no servers processing your information.\nThe project is also a demonstration that you don't always need React, <em>Vue</em>, or complex build pipelines \u2013 sometimes vanilla JavaScript in a single HTML file is exactly the right tool for the job.<p>Vanilla JavaScript (ES6+)\nCSS3 with CSS Grid\nMinimal external libraries: marked.js, exifr, highlight.js, sql-formatter (all from CDN)\nNo frameworks, no bundlers, no npm\nHosted on Github Pages<p>Happy to answer questions about the technical implementation, design decisions, or specific tools!<p>All tools are inspectable \u2013 just view source on any page to see exactly how they work!"}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Show HN: Prism.Tools \u2013 Free and privacy-focused developer utilities"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://blgardner.github.io/prism.tools/"}}, "_tags": ["story", "author_BLGardner", "story_46511469", "show_hn"], "author": "BLGardner", "children": [46511708, 46511795, 46511859, 46511871, 46512000, 46512294, 46512343, 46512351, 46512613, 46512655, 46512704, 46512854, 46512897, 46513035, 46513291, 46513520, 46513657, 46513848, 46514017, 46514145, 46514621, 46514641, 46515276, 46515391, 46515634, 46517127, 46517735, 46518037, 46519170, 46519339, 46520070, 46520193, 46524278, 46561168, 46590132], "created_at": "2026-01-06T12:33:49Z", "created_at_i": 1767702829, "num_comments": 104, "objectID": "46511469", "points": 380, "story_id": 46511469, "story_text": "Hi HN, I&#x27;m Barry and I&#x27;ve built Prism.Tools (<a href=\"https:&#x2F;&#x2F;blgardner.github.io&#x2F;prism.tools&#x2F;\" rel=\"nofollow\">https:&#x2F;&#x2F;blgardner.github.io&#x2F;prism.tools&#x2F;</a>) \u2013 a collection of client-side developer utilities that respect your privacy.<p>Many of these tools were used way back in the days when I ran a BBS and started my communities first ISP, serving three local communities with Dial-Up Internet, Web Hosting etc. The tools have been refined to reflect the changes in tech since then and designed for the Novice and Pro alike. As I locate more tools others may find useful I will refine and add them to the collection. Use them, Share them, or not. They will be here if you need them...<p>40+ dev tools (JSON formatters, regex tester, base64 encoder, Git command helper, etc.) that run entirely in your browser.\nZero tracking, zero analytics, zero data collection \u2013 everything processes locally.\nSelf-contained HTML files with no build process or frameworks.<p>I realized I had a lot of tools&#x2F;utilities I&#x27;ve built over the years for my own use. I lothe having to &#x27;sign-up&#x27; just to access&#x2F;use simple utilities that I can create myself. I&#x27;ve refined them and put them in one safe place so I could easily access them if&#x2F;when needed. I decided to make them available via Github Pages for anyone that may find them useful. Prism.Tools is the result.<p>Each tool is a standalone HTML file with embedded CSS and JavaScript. No frameworks, no npm packages, no build steps \u2013 just open the file and it works.<p>The entire toolset:<p>- 100% client-side processing \u2013 your data never leaves your browser.<p>- No external dependencies except for specific libraries from cdnjs.cloudflare.com (marked.js for markdown, exifr for image metadata, etc.)<p>- Consistent dark UI \u2013 every tool follows the same design language for familiarity.<p>- Vanilla JS where possible \u2013 only reaching for Public CDN Resources when necessary.<p>The constraint of &quot;single HTML file&quot; was intentional. It forces simplicity and ensures tools remain maintainable. It also means users can inspect, modify, or self-host any tool trivially.<p>These tools have helped me with debugging production issues, Quick formatting tasks, learning Git commands (the Git command helper has been particularly helpful)<p>Just visit <a href=\"https:&#x2F;&#x2F;blgardner.github.io&#x2F;prism.tools&#x2F;\" rel=\"nofollow\">https:&#x2F;&#x2F;blgardner.github.io&#x2F;prism.tools&#x2F;</a> and try any tool. No signup, no install.<p>What tools are missing that you find yourself needing?\nAny performance issues with specific tools?\nUI&#x2F;UX friction points?<p>All tools follow the same privacy-first philosophy...\nYour data stays in your browser. No accounts, no tracking, no servers processing your information.\nThe project is also a demonstration that you don&#x27;t always need React, Vue, or complex build pipelines \u2013 sometimes vanilla JavaScript in a single HTML file is exactly the right tool for the job.<p>Vanilla JavaScript (ES6+)\nCSS3 with CSS Grid\nMinimal external libraries: marked.js, exifr, highlight.js, sql-formatter (all from CDN)\nNo frameworks, no bundlers, no npm\nHosted on Github Pages<p>Happy to answer questions about the technical implementation, design decisions, or specific tools!<p>All tools are inspectable \u2013 just view source on any page to see exactly how they work!", "title": "Show HN: Prism.Tools \u2013 Free and privacy-focused developer utilities", "updated_at": "2026-01-23T16:44:01Z", "url": "https://blgardner.github.io/prism.tools/"}], "hitsPerPage": 15, "nbHits": 46, "nbPages": 4, "page": 0, "params": "query=vue+production&tags=story&hitsPerPage=15&advancedSyntax=true&analyticsTags=backend", "processingTimeMS": 7, "processingTimingsMS": {"_request": {"roundTrip": 13}, "afterFetch": {"format": {"highlighting": 1, "total": 1}}, "fetch": {"query": 4, "scanning": 1, "total": 6}, "total": 7}, "query": "vue production", "serverTimeMS": 8}}