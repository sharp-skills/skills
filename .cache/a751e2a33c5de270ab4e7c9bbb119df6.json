{"d": {"exhaustive": {"nbHits": false, "typo": false}, "exhaustiveNbHits": false, "exhaustiveTypo": false, "hits": [{"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "ricardodevelop"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["eslint", "production"], "value": "Hello everyone,<p>I\u2019ve created this starter project for creating <em>production</em> ready web apps in Vite and React that I hope some might find useful.<p>This template came about as a necessity to provide some standardization across new projects at work. A few of the initial goals when creating this project were to:<p>- Reduce setup time<p>- Standardize codebase with <em>ESLint</em> and Prettier<p>- Improve commit messages with tools like husky, commitizen and commitlint<p>- Improve codebase maintainability and scalability by providing a reasonable folder structure<p>- Simplify React Component development through use of tools like Storybook<p>- Improving codebase stability with unit and E2E tests via Vitest + React Testing Library and Playwright respectively<p>- Ease the deployment process by providing a simple starter Dockerfile<p>In addition to all the aforementioned goals, I also wanted to use modern tools such as React Query + Zustand for state management, React Hook Form + Zod for creating and validating forms, Tailwind CSS for building out UI\u2019s, etc.<p>I tried to cover everything I, and others, might need but recognize that everyones requirements are different. Luckily, this isn\u2019t a framework so removing unneeded packages or adding new ones is as simple it would normally be. The project itself doesn\u2019t come with a demo as its purpose is to simply provide a foundation for any new projects you might have in mind.<p>Feedback is always welcome and I appreciate anyone willing to checkout this project.<p>Thank you and have a great day."}, "title": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["production"], "value": "Show HN: Vite React Boilerplate \u2013 A <em>Production</em> Ready, Scalable Starter Template"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://github.com/RicardoValdovinos/vite-react-boilerplate"}}, "_tags": ["story", "author_ricardodevelop", "story_36926095", "show_hn"], "author": "ricardodevelop", "children": [36927690, 36928003], "created_at": "2023-07-29T23:49:15Z", "created_at_i": 1690674555, "num_comments": 5, "objectID": "36926095", "points": 18, "story_id": 36926095, "story_text": "Hello everyone,<p>I\u2019ve created this starter project for creating production ready web apps in Vite and React that I hope some might find useful.<p>This template came about as a necessity to provide some standardization across new projects at work. A few of the initial goals when creating this project were to:<p>- Reduce setup time<p>- Standardize codebase with ESLint and Prettier<p>- Improve commit messages with tools like husky, commitizen and commitlint<p>- Improve codebase maintainability and scalability by providing a reasonable folder structure<p>- Simplify React Component development through use of tools like Storybook<p>- Improving codebase stability with unit and E2E tests via Vitest + React Testing Library and Playwright respectively<p>- Ease the deployment process by providing a simple starter Dockerfile<p>In addition to all the aforementioned goals, I also wanted to use modern tools such as React Query + Zustand for state management, React Hook Form + Zod for creating and validating forms, Tailwind CSS for building out UI\u2019s, etc.<p>I tried to cover everything I, and others, might need but recognize that everyones requirements are different. Luckily, this isn\u2019t a framework so removing unneeded packages or adding new ones is as simple it would normally be. The project itself doesn\u2019t come with a demo as its purpose is to simply provide a foundation for any new projects you might have in mind.<p>Feedback is always welcome and I appreciate anyone willing to checkout this project.<p>Thank you and have a great day.", "title": "Show HN: Vite React Boilerplate \u2013 A Production Ready, Scalable Starter Template", "updated_at": "2024-09-20T14:45:12Z", "url": "https://github.com/RicardoValdovinos/vite-react-boilerplate"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "thesssaism"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["eslint", "production"], "value": "I recently ran an audit on our latest full-stack repo to figure out why &quot;spinning up a new project&quot; felt like such a heavy lift. I counted every file required just to reach a &quot;<em>production</em>-ready&quot; baseline\u2014before writing a single line of unique feature code.<p>The count was roughly 600 files.<p>To be clear, I'm not talking about a `create-react-app` sandbox. I mean a compliant, scalable SaaS foundation: Next.js frontend, Node.js/NestJS backend, mobile wrapper, CI/CD pipelines, and enough security config to pass a SOC2 audit.<p>It sounds ridiculous (and honestly, it feels ridiculous), but when I broke it down, I couldn't find many files I was willing to delete.<p>Here is where the bloat comes from:<p>First, the &quot;Configuration Hell&quot; accounts for about 40-50 files alone. We aren't just dealing with `package.json` anymore. It's `tsconfig.json` (base), `tsconfig.build.json`, `tsconfig.spec.json`... multiplied across frontend, backend, and shared libraries. Then add `.eslintrc.js`, `.prettierrc`, `jest.config.js`, `vitest.config.ts`, `nodemon.json`, and the Docker-compose variants for dev, test, and prod.<p>Then there\u2019s the DevOps and Quality layer. We have roughly 20-30 files for GitHub Actions workflows (lint, test, build, deploy, semantic release), Husky hooks (pre-commit, commit-msg), and pull request templates.<p>But the real multiplier is the separation of concerns. In a modern monorepo, a &quot;Hello World&quot; isn't just `console.log`. It\u2019s:\n- A NestJS module (Controller, Service, Module, DTO, Entity, Unit Test, E2E Test).\n- A Next.js slice (Page, Component, Type definition, API client wrapper).\n- A shared library entry.<p>We found that adding a single &quot;minimal&quot; API endpoint usually touches 5-7 files just to maintain architectural standards.<p>The trade-off is painful. On one hand, this setup handles the things we used to forget: security headers, proper logging, consistent error handling, and type safety across boundaries. It prevents the &quot;spaghetti code&quot; distinct to startups that scale too fast.<p>On the other hand, the cognitive load of managing a 600-file &quot;empty&quot; project is massive. Updating dependencies becomes a chore because a major version bump in one tool (like <em>ESLint</em>) cascades through forty config files.<p>I\u2019m curious how others are handling this &quot;starting line&quot; complexity.<p>Are you accepting the boilerplate as the cost of doing business? Or have you found a way to strip this down without sacrificing the compliance/safety guardrails that enterprise clients demand?<p>It feels like we've over-engineered the entry point of software development, but I\u2019m not sure what the alternative is for a serious project. We tried going &quot;lean&quot; initially, but spent weeks retrofitting auth and testing harnesses later\u2014which was worse.<p>Is there a middle ground I'm missing, or is ~600 files just the new normal?"}, "title": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["production"], "value": "Tell HN: A <em>production</em>-ready \"Hello World\" is now ~600 files"}}, "_tags": ["story", "author_thesssaism", "story_47074571", "ask_hn"], "author": "thesssaism", "children": [47074794, 47075001, 47075012, 47076406], "created_at": "2026-02-19T15:07:03Z", "created_at_i": 1771513623, "num_comments": 4, "objectID": "47074571", "points": 4, "story_id": 47074571, "story_text": "I recently ran an audit on our latest full-stack repo to figure out why &quot;spinning up a new project&quot; felt like such a heavy lift. I counted every file required just to reach a &quot;production-ready&quot; baseline\u2014before writing a single line of unique feature code.<p>The count was roughly 600 files.<p>To be clear, I&#x27;m not talking about a `create-react-app` sandbox. I mean a compliant, scalable SaaS foundation: Next.js frontend, Node.js&#x2F;NestJS backend, mobile wrapper, CI&#x2F;CD pipelines, and enough security config to pass a SOC2 audit.<p>It sounds ridiculous (and honestly, it feels ridiculous), but when I broke it down, I couldn&#x27;t find many files I was willing to delete.<p>Here is where the bloat comes from:<p>First, the &quot;Configuration Hell&quot; accounts for about 40-50 files alone. We aren&#x27;t just dealing with `package.json` anymore. It&#x27;s `tsconfig.json` (base), `tsconfig.build.json`, `tsconfig.spec.json`... multiplied across frontend, backend, and shared libraries. Then add `.eslintrc.js`, `.prettierrc`, `jest.config.js`, `vitest.config.ts`, `nodemon.json`, and the Docker-compose variants for dev, test, and prod.<p>Then there\u2019s the DevOps and Quality layer. We have roughly 20-30 files for GitHub Actions workflows (lint, test, build, deploy, semantic release), Husky hooks (pre-commit, commit-msg), and pull request templates.<p>But the real multiplier is the separation of concerns. In a modern monorepo, a &quot;Hello World&quot; isn&#x27;t just `console.log`. It\u2019s:\n- A NestJS module (Controller, Service, Module, DTO, Entity, Unit Test, E2E Test).\n- A Next.js slice (Page, Component, Type definition, API client wrapper).\n- A shared library entry.<p>We found that adding a single &quot;minimal&quot; API endpoint usually touches 5-7 files just to maintain architectural standards.<p>The trade-off is painful. On one hand, this setup handles the things we used to forget: security headers, proper logging, consistent error handling, and type safety across boundaries. It prevents the &quot;spaghetti code&quot; distinct to startups that scale too fast.<p>On the other hand, the cognitive load of managing a 600-file &quot;empty&quot; project is massive. Updating dependencies becomes a chore because a major version bump in one tool (like ESLint) cascades through forty config files.<p>I\u2019m curious how others are handling this &quot;starting line&quot; complexity.<p>Are you accepting the boilerplate as the cost of doing business? Or have you found a way to strip this down without sacrificing the compliance&#x2F;safety guardrails that enterprise clients demand?<p>It feels like we&#x27;ve over-engineered the entry point of software development, but I\u2019m not sure what the alternative is for a serious project. We tried going &quot;lean&quot; initially, but spent weeks retrofitting auth and testing harnesses later\u2014which was worse.<p>Is there a middle ground I&#x27;m missing, or is ~600 files just the new normal?", "title": "Tell HN: A production-ready \"Hello World\" is now ~600 files", "updated_at": "2026-02-20T00:09:42Z"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "yangxiaobo"}, "story_text": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["eslint"], "value": "Hi HN!<p>I've built Gemini Coder, an open platform that converts natural language descriptions into complete Next.js applications using Google's Gemini API.<p>Technical Implementation:\n- Next.js 14 with App Router\n- Integration with Google's Gemini API for code generation\n- Real-time code preview using Monaco Editor\n- Tailwind CSS for styling\n- Internationalization support using next-intl\n- Content management with Contentlayer<p>Core Features:\n- Advanced prompt engineering for accurate code generation\n- Structured output handling for consistent code quality\n- Built-in code formatting and best practices enforcement\n- Support for modern React patterns and hooks\n- Automatic TypeScript type generation<p>Current Specs:\n- Processing time: ~2-3 minutes per application\n- Output: Complete Next.js project structure\n- Zero vendor lock-in\n- Client-side preview capabilities<p>The platform is built with developer experience in mind, generating code that follows established patterns and best practices. All generated applications include proper TypeScript types, <em>ESLint</em> configurations, and modern React patterns.<p>Live demo: <a href=\"https://geminicoder.org/\" rel=\"nofollow\">https://geminicoder.org/</a><p>Looking for feedback especially on the code generation quality and developer experience. Future plans include adding more framework options and custom component libraries support."}, "title": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["production"], "value": "Show HN: Gemini Coder \u2013 Generate <em>production</em>-ready Next.js applications using AI"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://geminicoder.org/"}}, "_tags": ["story", "author_yangxiaobo", "story_42521734", "show_hn"], "author": "yangxiaobo", "created_at": "2024-12-27T12:56:19Z", "created_at_i": 1735304179, "num_comments": 0, "objectID": "42521734", "points": 2, "story_id": 42521734, "story_text": "Hi HN!<p>I&#x27;ve built Gemini Coder, an open platform that converts natural language descriptions into complete Next.js applications using Google&#x27;s Gemini API.<p>Technical Implementation:\n- Next.js 14 with App Router\n- Integration with Google&#x27;s Gemini API for code generation\n- Real-time code preview using Monaco Editor\n- Tailwind CSS for styling\n- Internationalization support using next-intl\n- Content management with Contentlayer<p>Core Features:\n- Advanced prompt engineering for accurate code generation\n- Structured output handling for consistent code quality\n- Built-in code formatting and best practices enforcement\n- Support for modern React patterns and hooks\n- Automatic TypeScript type generation<p>Current Specs:\n- Processing time: ~2-3 minutes per application\n- Output: Complete Next.js project structure\n- Zero vendor lock-in\n- Client-side preview capabilities<p>The platform is built with developer experience in mind, generating code that follows established patterns and best practices. All generated applications include proper TypeScript types, ESLint configurations, and modern React patterns.<p>Live demo: <a href=\"https:&#x2F;&#x2F;geminicoder.org&#x2F;\" rel=\"nofollow\">https:&#x2F;&#x2F;geminicoder.org&#x2F;</a><p>Looking for feedback especially on the code generation quality and developer experience. Future plans include adding more framework options and custom component libraries support.", "title": "Show HN: Gemini Coder \u2013 Generate production-ready Next.js applications using AI", "updated_at": "2024-12-27T13:56:46Z", "url": "https://geminicoder.org/"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "tdfirth"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["eslint", "production"], "value": "Hey HN - our team wants to open source a project called NASTY (NASTY Abstract Syntax Tree thingY) that we built for ourselves. NASTY was built to maintain testable/composable data pipelines. Our team was ripping our hair out trying to maintain dbt/SQL scripts across different data warehouses (Redshift, BigQuery, Postgres, Snowflake) on top of ever shifting data foundations maintained by our customer's internal data teams. NASTY is the result of our learnings from field experience.<p>We wanted to write abstractions so that we could reuse code. We wanted to bundle those abstractions into libraries. We wanted to statically analyze our models so that we caught more errors before <em>production</em>. We wanted a fast unit test suite that you could iterate on locally without connecting to a data warehouse.<p>In short, we wanted to use all the same practices we used for building our other software. Tools like dbt made a great start at importing these kinds of practices into analytics, but there are many great aspects of the software engineering workflow that still aren't easy to replicate in data.<p>We've found it to be a super productive way to work, and we thought others might want to use it too. It's very early days so we've put up a page for to explain it, and we've made some executable examples for people to have a go. Let us know what you think!<p>FAQ:<p>Is NASTY an ORM? A SQL builder?<p>Neither! NASTY is kinda it's own thing. NASTY is more like a minimal relational algebra programming language shipped as a Typescript library. It borrows a bunch of learnings from other programming languages and applies them to OLAP programming / data engineering. It's an important distinction, because it totally changes the way you can think about building transformations.<p>Why TypeScript? Why not Python?<p>The 100% honest answer is we had a ton of typescript experience and we had a node/react app with pulumi's TS apis. We like typescript and by being a library instead of a full programming language, we can leverage things like vitest, <em>eslint</em>, node, TS's language server, TSdoc, etc."}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Show HN: Nasty, a cross-warehouse, type-checked, unit-testable analytics library"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://getnasty.dev/"}}, "_tags": ["story", "author_tdfirth", "story_39641713", "show_hn"], "author": "tdfirth", "children": [39643214, 39643428, 39643572, 39645879], "created_at": "2024-03-08T15:10:28Z", "created_at_i": 1709910628, "num_comments": 6, "objectID": "39641713", "points": 47, "story_id": 39641713, "story_text": "Hey HN - our team wants to open source a project called NASTY (NASTY Abstract Syntax Tree thingY) that we built for ourselves. NASTY was built to maintain testable&#x2F;composable data pipelines. Our team was ripping our hair out trying to maintain dbt&#x2F;SQL scripts across different data warehouses (Redshift, BigQuery, Postgres, Snowflake) on top of ever shifting data foundations maintained by our customer&#x27;s internal data teams. NASTY is the result of our learnings from field experience.<p>We wanted to write abstractions so that we could reuse code. We wanted to bundle those abstractions into libraries. We wanted to statically analyze our models so that we caught more errors before production. We wanted a fast unit test suite that you could iterate on locally without connecting to a data warehouse.<p>In short, we wanted to use all the same practices we used for building our other software. Tools like dbt made a great start at importing these kinds of practices into analytics, but there are many great aspects of the software engineering workflow that still aren&#x27;t easy to replicate in data.<p>We&#x27;ve found it to be a super productive way to work, and we thought others might want to use it too. It&#x27;s very early days so we&#x27;ve put up a page for to explain it, and we&#x27;ve made some executable examples for people to have a go. Let us know what you think!<p>FAQ:<p>Is NASTY an ORM? A SQL builder?<p>Neither! NASTY is kinda it&#x27;s own thing. NASTY is more like a minimal relational algebra programming language shipped as a Typescript library. It borrows a bunch of learnings from other programming languages and applies them to OLAP programming &#x2F; data engineering. It&#x27;s an important distinction, because it totally changes the way you can think about building transformations.<p>Why TypeScript? Why not Python?<p>The 100% honest answer is we had a ton of typescript experience and we had a node&#x2F;react app with pulumi&#x27;s TS apis. We like typescript and by being a library instead of a full programming language, we can leverage things like vitest, eslint, node, TS&#x27;s language server, TSdoc, etc.", "title": "Show HN: Nasty, a cross-warehouse, type-checked, unit-testable analytics library", "updated_at": "2024-09-20T16:36:50Z", "url": "https://getnasty.dev/"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "ThailandJohn"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["eslint", "production"], "value": "I'm an infrastructure architect who started using AI assistants to write code 3 months ago. \nAfter building several systems with Claude, I noticed a pattern: the code always had security issues I could spot from my ops background, but I couldn't fix them myself since I can't actually write code.<p>Why I built this: I needed a way to verify AI-generated code was <em>production</em>-safe. \nExisting tools either required cloud uploads (privacy concern) or produced output too large for AI context windows. \nTheAuditor solves both problems - it runs completely offline and chunks findings into 65KB segments that fit in Claude/GPT-4 context limits.<p>What I discovered: Testing on real projects, TheAuditor consistently finds 50-200+ vulnerabilities in AI-generated code. \nThe patterns are remarkably consistent:\n- SQL queries using f-strings instead of parameterization\n- Hardcoded secrets (JWT_SECRET = &quot;secret&quot; appears in nearly every project)\n- Missing authentication on critical endpoints\n- Rate limiting using in-memory storage that resets on restart<p>Technical approach: TheAuditor runs 14 analysis phases in parallel, including taint analysis (tracking data from user input to dangerous sinks), pattern matching against 100+ security rules, and orchestrating industry tools (<em>ESLint</em>, Ruff, MyPy, Bandit). \nEverything outputs to structured JSON optimized for LLM consumption.<p>Interesting obstacle: When scanning files with vulnerabilities, antivirus software often quarantines our reports because they contain &quot;malicious&quot; SQL injection patterns - even though we're just documenting them. Had to implement pattern defanging to reduce false positives.<p>Current usage: Run aud full in any Python/JS/TS project. It generates a complete security audit in .pf/readthis/. \nThe AI can then read these reports and fix its own vulnerabilities. I've seen projects go from 185 critical issues to zero in 3-4 iterations.<p>The tool is particularly useful if you're using AI assistants for <em>production</em> code but worry about security. \nIt provides the &quot;ground truth&quot; that AI needs to self-correct.<p>Would appreciate feedback on:\n- Additional vulnerability patterns common in AI-generated code\n- Better ways to handle the antivirus false-positive issue\n- Integration ideas for different AI coding workflows<p>Thanks for taking a look! /TheAuditorTool"}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Show HN: TheAuditor \u2013 Offline security scanner for AI-generated code"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://github.com/TheAuditorTool/Auditor"}}, "_tags": ["story", "author_ThailandJohn", "story_45165897", "show_hn"], "author": "ThailandJohn", "children": [45166250, 45166292, 45166427, 45166432, 45166438, 45166450, 45167854], "created_at": "2025-09-08T08:28:15Z", "created_at_i": 1757320095, "num_comments": 32, "objectID": "45165897", "points": 13, "story_id": 45165897, "story_text": "I&#x27;m an infrastructure architect who started using AI assistants to write code 3 months ago. \nAfter building several systems with Claude, I noticed a pattern: the code always had security issues I could spot from my ops background, but I couldn&#x27;t fix them myself since I can&#x27;t actually write code.<p>Why I built this: I needed a way to verify AI-generated code was production-safe. \nExisting tools either required cloud uploads (privacy concern) or produced output too large for AI context windows. \nTheAuditor solves both problems - it runs completely offline and chunks findings into 65KB segments that fit in Claude&#x2F;GPT-4 context limits.<p>What I discovered: Testing on real projects, TheAuditor consistently finds 50-200+ vulnerabilities in AI-generated code. \nThe patterns are remarkably consistent:\n- SQL queries using f-strings instead of parameterization\n- Hardcoded secrets (JWT_SECRET = &quot;secret&quot; appears in nearly every project)\n- Missing authentication on critical endpoints\n- Rate limiting using in-memory storage that resets on restart<p>Technical approach: TheAuditor runs 14 analysis phases in parallel, including taint analysis (tracking data from user input to dangerous sinks), pattern matching against 100+ security rules, and orchestrating industry tools (ESLint, Ruff, MyPy, Bandit). \nEverything outputs to structured JSON optimized for LLM consumption.<p>Interesting obstacle: When scanning files with vulnerabilities, antivirus software often quarantines our reports because they contain &quot;malicious&quot; SQL injection patterns - even though we&#x27;re just documenting them. Had to implement pattern defanging to reduce false positives.<p>Current usage: Run aud full in any Python&#x2F;JS&#x2F;TS project. It generates a complete security audit in .pf&#x2F;readthis&#x2F;. \nThe AI can then read these reports and fix its own vulnerabilities. I&#x27;ve seen projects go from 185 critical issues to zero in 3-4 iterations.<p>The tool is particularly useful if you&#x27;re using AI assistants for production code but worry about security. \nIt provides the &quot;ground truth&quot; that AI needs to self-correct.<p>Would appreciate feedback on:\n- Additional vulnerability patterns common in AI-generated code\n- Better ways to handle the antivirus false-positive issue\n- Integration ideas for different AI coding workflows<p>Thanks for taking a look! &#x2F;TheAuditorTool", "title": "Show HN: TheAuditor \u2013 Offline security scanner for AI-generated code", "updated_at": "2025-12-15T13:42:18Z", "url": "https://github.com/TheAuditorTool/Auditor"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "mjurczyk"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["eslint", "production"], "value": "As a developer with a bit over 5 years experience, I am sometimes asked by my friends about starting their own Front-end career. Where do you begin? What is an outdated knowledge, and what important? How do you write code that is at least close to being &quot;<em>production</em>-ready&quot; these days?<p>That questions asked about Java are a little simpler for me - &quot;Take this book, this one and this. Here are the patterns, just remember these from this book. You'll learn the rest on the way.&quot; - few months later this person can be seen sitting as a Junior/Med in some software company. These languages do change, quite a lot, but Front-end is a bit more ... in a hurry - and learning from books does not work for it at all.<p>Even though Angular and React got most shares of the up-to-date <em>production</em> stack, Front-end environment is still not really settled.\nWhen I google &quot;javascript tutorial&quot;, it takes only about 12 pages until I first hear about anything related to ES6. \n&quot;Modules?&quot; - &quot;Not this time, mate. But we've got this cool quiz that you can finish and get a JavaScript certificate!&quot;\n&quot;When was your guide last updated?&quot; - &quot;1996, but javascript didn't change even a bit, trust us on that! Also, would you like to obtain a FREE JavaScript certificate?&quot;\n&quot;React, Angu...&quot; - &quot;Shhh, there, a certificate for your eager spirit!&quot;<p>When I was learning JavaScript a bit of time ago, there was only jQuery. And RequireJS. And that was pretty much all you needed. Today, new frameworks appear daily. It is not an easy path for a newcomer, when they have to learn at least 2-3 of these frameworks to even get started. And there seems to be no single, intuitive and reliable source to learn the basics from.<p>tl;dr;<p>Do you know any quality online tutorial that provide actual introductory knowledge of the current Front-end stack, in a beginners'-friendly form? (Vanilla, React or Angular, common tools like Webpack, <em>ESlint</em>, transpilers, maybe a bit about handling asynchronous code)"}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Ask HN: If you didn't know it, how would you learn Front-end today?"}}, "_tags": ["story", "author_mjurczyk", "story_12976249", "ask_hn"], "author": "mjurczyk", "children": [12976321, 12976993], "created_at": "2016-11-17T10:48:53Z", "created_at_i": 1479379733, "num_comments": 2, "objectID": "12976249", "points": 4, "story_id": 12976249, "story_text": "As a developer with a bit over 5 years experience, I am sometimes asked by my friends about starting their own Front-end career. Where do you begin? What is an outdated knowledge, and what important? How do you write code that is at least close to being &quot;production-ready&quot; these days?<p>That questions asked about Java are a little simpler for me - &quot;Take this book, this one and this. Here are the patterns, just remember these from this book. You&#x27;ll learn the rest on the way.&quot; - few months later this person can be seen sitting as a Junior&#x2F;Med in some software company. These languages do change, quite a lot, but Front-end is a bit more ... in a hurry - and learning from books does not work for it at all.<p>Even though Angular and React got most shares of the up-to-date production stack, Front-end environment is still not really settled.\nWhen I google &quot;javascript tutorial&quot;, it takes only about 12 pages until I first hear about anything related to ES6. \n&quot;Modules?&quot; - &quot;Not this time, mate. But we&#x27;ve got this cool quiz that you can finish and get a JavaScript certificate!&quot;\n&quot;When was your guide last updated?&quot; - &quot;1996, but javascript didn&#x27;t change even a bit, trust us on that! Also, would you like to obtain a FREE JavaScript certificate?&quot;\n&quot;React, Angu...&quot; - &quot;Shhh, there, a certificate for your eager spirit!&quot;<p>When I was learning JavaScript a bit of time ago, there was only jQuery. And RequireJS. And that was pretty much all you needed. Today, new frameworks appear daily. It is not an easy path for a newcomer, when they have to learn at least 2-3 of these frameworks to even get started. And there seems to be no single, intuitive and reliable source to learn the basics from.<p>tl;dr;<p>Do you know any quality online tutorial that provide actual introductory knowledge of the current Front-end stack, in a beginners&#x27;-friendly form? (Vanilla, React or Angular, common tools like Webpack, ESlint, transpilers, maybe a bit about handling asynchronous code)", "title": "Ask HN: If you didn't know it, how would you learn Front-end today?", "updated_at": "2024-09-20T00:00:53Z"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "sangsattawat"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["eslint", "production"], "value": "I used Claude Code heavily while trying to launch an app while being quite sick and my mental focus was not at its best. \nSo I relied 'too much' on Claude Code, and my Supabase keys slipped in a 'hidden' endpoint, causing some emails to be leaked.<p>After some deep introspection, and thinking about the explosion of Lovable, Replit, Cursor, Claude Code vibe-coded apps, I thought about what's the newest newest and most dreadful pain points in the dev arena right now. \nAnd I came up with the scenario of debugging some non-obvious errors, where your AI of choice will reply &quot;You're absolutely right! Let me fix that&quot;, but never nailing what's wrong in the codebase.<p>So I built Ubon for the last week, listing thoroughly all the pain points I have experienced myself as a software engineer (mostly front-end) for 15 years. Ubon catches the stuff that slips past linters - hardcoded API keys, broken links, missing alt attributes, insecure cookies. The kind of issues that only blow up in <em>production</em>.<p>And now I can use Ubon by adding it to my codebase (&quot;npx ubon scan .&quot;, or simply telling Claude Code &quot;install Ubon before commiting&quot;), and it will give outputs that either a developer or an AI agent can read to pinpoint real issues, pinpointing the line and suggested fix.<p>It's open-source, free to use, MIT licensed, and I won't abandon it after 7 days, haha. My hope is that it can become part of the workflow for AI agents or as a complement to linters like <em>ESlint</em>.<p>It makes me happy to share that after some deep testing, it works pretty well. I have tried with dozens of buggy codebases, and also simulated faulty repos generated by Cursor, Windsurf, Lovable, etc. to use Ubon on top of them, and the results are very good.<p>Would love feedback on what other checks would be useful. And if there's enough demand, I am happy to give online demos to get traction of users to enjoy Ubon."}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Show HN: Ubon \u2013 a solution for the \"You're absolutely right\" debugging dread"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://github.com/luisfer/ubon"}}, "_tags": ["story", "author_sangsattawat", "story_45029654", "show_hn"], "author": "sangsattawat", "children": [45069267], "created_at": "2025-08-26T17:27:56Z", "created_at_i": 1756229276, "num_comments": 1, "objectID": "45029654", "points": 4, "story_id": 45029654, "story_text": "I used Claude Code heavily while trying to launch an app while being quite sick and my mental focus was not at its best. \nSo I relied &#x27;too much&#x27; on Claude Code, and my Supabase keys slipped in a &#x27;hidden&#x27; endpoint, causing some emails to be leaked.<p>After some deep introspection, and thinking about the explosion of Lovable, Replit, Cursor, Claude Code vibe-coded apps, I thought about what&#x27;s the newest newest and most dreadful pain points in the dev arena right now. \nAnd I came up with the scenario of debugging some non-obvious errors, where your AI of choice will reply &quot;You&#x27;re absolutely right! Let me fix that&quot;, but never nailing what&#x27;s wrong in the codebase.<p>So I built Ubon for the last week, listing thoroughly all the pain points I have experienced myself as a software engineer (mostly front-end) for 15 years. Ubon catches the stuff that slips past linters - hardcoded API keys, broken links, missing alt attributes, insecure cookies. The kind of issues that only blow up in production.<p>And now I can use Ubon by adding it to my codebase (&quot;npx ubon scan .&quot;, or simply telling Claude Code &quot;install Ubon before commiting&quot;), and it will give outputs that either a developer or an AI agent can read to pinpoint real issues, pinpointing the line and suggested fix.<p>It&#x27;s open-source, free to use, MIT licensed, and I won&#x27;t abandon it after 7 days, haha. My hope is that it can become part of the workflow for AI agents or as a complement to linters like ESlint.<p>It makes me happy to share that after some deep testing, it works pretty well. I have tried with dozens of buggy codebases, and also simulated faulty repos generated by Cursor, Windsurf, Lovable, etc. to use Ubon on top of them, and the results are very good.<p>Would love feedback on what other checks would be useful. And if there&#x27;s enough demand, I am happy to give online demos to get traction of users to enjoy Ubon.", "title": "Show HN: Ubon \u2013 a solution for the \"You're absolutely right\" debugging dread", "updated_at": "2025-08-29T20:54:01Z", "url": "https://github.com/luisfer/ubon"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "creativedg"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["eslint", "production"], "value": "I started this boilerplate in July 2020 and I\u2019ve been maintaining it for 5 years. It began on Next.js 9 and kept upgrading to Next.js 15+ (App Router), while upgrading the stack over time (Tailwind 1 \u2192 4, <em>ESLint</em> 8, swapping Cypress \u2192 Playwright, etc.). The goal is simple: I kept rebuilding the same setup, so I packaged it and kept it updated.<p>What you get (preconfigured, keep only what you need):<p>- Next.js 15 (App Router) + TypeScript + Tailwind 4<p>- Auth with Clerk (magic links, MFA, social, passkeys)<p>- I18n via next-intl<p>- DB with Drizzle ORM (PGlite locally)<p>- Forms with React Hook Form + Zod validation<p>- Testing: Vitest (unit), Playwright (integration/E2E)<p>- CI with GitHub Actions; Storybook for UI work<p>- SEO (Open Graph, JSON-LD, sitemap, robots)<p>- Observability: Sentry, logging with LogTape, log management &amp; uptime/monitoring<p>- Security: Arcjet (bot detection, rate limiting, shield rules)<p>- DX details: <em>ESLint</em>/Prettier, Lefthook + lint-staged, Commitlint, absolute imports, bundle analyzer<p>- AI code review<p>It\u2019s free and open source (MIT). Today the project sits around 11.8k GitHub stars and 2.2k forks. I\u2019m still actively maintaining it and adding features.<p>Repo: <a href=\"https://github.com/ixartz/Next-js-Boilerplate\" rel=\"nofollow\">https://github.com/ixartz/Next-js-Boilerplate</a><p>Why I built it<p>Spinning up auth, a DB, i18n, tests, and lint/format/CI for each new app was repetitive. This gives me (and hopefully you) a <em>production</em>-ready base in minutes, with opinionated defaults you can start.<p>I\u2019m open to suggestions and feedback, what would you like to see next? I\u2019ll hang around in the comments to answer questions."}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Show HN: Open-source Next.js 15 boilerplate \u2013 auth, DB, intl, tests, monitoring"}}, "_tags": ["story", "author_creativedg", "story_45052744", "show_hn"], "author": "creativedg", "created_at": "2025-08-28T14:38:31Z", "created_at_i": 1756391911, "num_comments": 0, "objectID": "45052744", "points": 4, "story_id": 45052744, "story_text": "I started this boilerplate in July 2020 and I\u2019ve been maintaining it for 5 years. It began on Next.js 9 and kept upgrading to Next.js 15+ (App Router), while upgrading the stack over time (Tailwind 1 \u2192 4, ESLint 8, swapping Cypress \u2192 Playwright, etc.). The goal is simple: I kept rebuilding the same setup, so I packaged it and kept it updated.<p>What you get (preconfigured, keep only what you need):<p>- Next.js 15 (App Router) + TypeScript + Tailwind 4<p>- Auth with Clerk (magic links, MFA, social, passkeys)<p>- I18n via next-intl<p>- DB with Drizzle ORM (PGlite locally)<p>- Forms with React Hook Form + Zod validation<p>- Testing: Vitest (unit), Playwright (integration&#x2F;E2E)<p>- CI with GitHub Actions; Storybook for UI work<p>- SEO (Open Graph, JSON-LD, sitemap, robots)<p>- Observability: Sentry, logging with LogTape, log management &amp; uptime&#x2F;monitoring<p>- Security: Arcjet (bot detection, rate limiting, shield rules)<p>- DX details: ESLint&#x2F;Prettier, Lefthook + lint-staged, Commitlint, absolute imports, bundle analyzer<p>- AI code review<p>It\u2019s free and open source (MIT). Today the project sits around 11.8k GitHub stars and 2.2k forks. I\u2019m still actively maintaining it and adding features.<p>Repo: <a href=\"https:&#x2F;&#x2F;github.com&#x2F;ixartz&#x2F;Next-js-Boilerplate\" rel=\"nofollow\">https:&#x2F;&#x2F;github.com&#x2F;ixartz&#x2F;Next-js-Boilerplate</a><p>Why I built it<p>Spinning up auth, a DB, i18n, tests, and lint&#x2F;format&#x2F;CI for each new app was repetitive. This gives me (and hopefully you) a production-ready base in minutes, with opinionated defaults you can start.<p>I\u2019m open to suggestions and feedback, what would you like to see next? I\u2019ll hang around in the comments to answer questions.", "title": "Show HN: Open-source Next.js 15 boilerplate \u2013 auth, DB, intl, tests, monitoring", "updated_at": "2025-08-29T18:59:31Z"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "Croffasia"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["eslint", "production"], "value": "The Problem We're Solving<p>Setting up a <em>production</em>-ready Vue.js project takes days. You need to configure TypeScript, set up build tools, choose the right state management, configure linting, add UI components, set up testing\u2014and then teach your AI coding assistant how to work with your specific stack and patterns.<p>By the time you're done with setup, you've lost momentum on your actual idea.<p>The pattern is predictable:<p>Day 1-2: Research and configure build tools, TypeScript, linting \nDay 3-4: Set up state management, routing, UI components\nDay 5-6: Configure development workflow, AI coding instructions \nDay 7+: Finally start building your actual application<p>Most developers either skip best practices to move fast, or spend weeks on setup instead of building.<p>Our Solution: <em>Production</em>-Ready Starter + AI Instructions<p>Vibe Code Kit eliminates the setup phase entirely. You get a battle-tested Vue.js stack that's been refined through dozens of <em>production</em> applications, plus AI development instructions that teach Claude Code how to work effectively with your specific setup.<p>Technology Stack:<p>- Vue 3 with Composition API and TypeScript support\n- Vite for lightning-fast development and optimized builds\n- Pinia for global state management + Pinia Colada for data fetching\n- Tailwind CSS + DaisyUI for rapid UI development\n- VueUse composables library for common patterns\n- <em>ESLint</em>, Prettier, Husky for code quality<p>Each technology includes AI coding best practices that prevent Claude Code from reinventing patterns.<p>How It Works<p>- Blueprint-Driven Development: Enhanced R&amp;D workflow commands guide Claude Code through proper project analysis and feature planning\n- Specialized AI Agents: Built-in agents for standards checking, code validation, and codebase research\n- Stack-Specific Instructions: AI learns the proper patterns for each library in your stack\n- <em>Production</em> Configuration: Everything pre-configured for deployment from day one\n- The result: Turn your ideas into <em>production</em> Vue.js apps in minutes, not days.<p>Real Impact\nSince using this approach:<p>- New Vue.js projects start with feature development, not configuration\n- Claude Code consistently follows Vue 3 Composition API best practices\n- AI agents catch architectural issues before they become problems\n- <em>Production</em> deployments work from day one<p>Technical Details<p>Built on Vue 3 ecosystem best practices. Includes comprehensive Claude Code integration with specialized agents for Vue.js development. Works with existing AI-assisted development workflows and supports rapid prototyping to <em>production</em> scaling.<p>Currently supporting Vue.js projects with plans for React and other frameworks.<p>Try It\nEarly access available at <a href=\"https://vibecodekit.dev\" rel=\"nofollow\">https://vibecodekit.dev</a><p>This isn't about replacing Vue CLI or Vite\u2014it's about getting a <em>production</em>-ready foundation with AI that actually understands your stack. Would love feedback from Vue.js developers who've struggled with project setup overhead.<p>Questions I'm curious about:<p>- How much time do you spend on initial Vue.js project configuration?\n- What's been your experience with AI coding assistants on Vue projects?\n- What would convince you to use a pre-configured starter over building from scratch?"}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Show HN: Vibe Code Kit code with confidence"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://vibecodekit.dev"}}, "_tags": ["story", "author_Croffasia", "story_45216336", "show_hn"], "author": "Croffasia", "children": [45235122], "created_at": "2025-09-11T21:34:46Z", "created_at_i": 1757626486, "num_comments": 1, "objectID": "45216336", "points": 3, "story_id": 45216336, "story_text": "The Problem We&#x27;re Solving<p>Setting up a production-ready Vue.js project takes days. You need to configure TypeScript, set up build tools, choose the right state management, configure linting, add UI components, set up testing\u2014and then teach your AI coding assistant how to work with your specific stack and patterns.<p>By the time you&#x27;re done with setup, you&#x27;ve lost momentum on your actual idea.<p>The pattern is predictable:<p>Day 1-2: Research and configure build tools, TypeScript, linting \nDay 3-4: Set up state management, routing, UI components\nDay 5-6: Configure development workflow, AI coding instructions \nDay 7+: Finally start building your actual application<p>Most developers either skip best practices to move fast, or spend weeks on setup instead of building.<p>Our Solution: Production-Ready Starter + AI Instructions<p>Vibe Code Kit eliminates the setup phase entirely. You get a battle-tested Vue.js stack that&#x27;s been refined through dozens of production applications, plus AI development instructions that teach Claude Code how to work effectively with your specific setup.<p>Technology Stack:<p>- Vue 3 with Composition API and TypeScript support\n- Vite for lightning-fast development and optimized builds\n- Pinia for global state management + Pinia Colada for data fetching\n- Tailwind CSS + DaisyUI for rapid UI development\n- VueUse composables library for common patterns\n- ESLint, Prettier, Husky for code quality<p>Each technology includes AI coding best practices that prevent Claude Code from reinventing patterns.<p>How It Works<p>- Blueprint-Driven Development: Enhanced R&amp;D workflow commands guide Claude Code through proper project analysis and feature planning\n- Specialized AI Agents: Built-in agents for standards checking, code validation, and codebase research\n- Stack-Specific Instructions: AI learns the proper patterns for each library in your stack\n- Production Configuration: Everything pre-configured for deployment from day one\n- The result: Turn your ideas into production Vue.js apps in minutes, not days.<p>Real Impact\nSince using this approach:<p>- New Vue.js projects start with feature development, not configuration\n- Claude Code consistently follows Vue 3 Composition API best practices\n- AI agents catch architectural issues before they become problems\n- Production deployments work from day one<p>Technical Details<p>Built on Vue 3 ecosystem best practices. Includes comprehensive Claude Code integration with specialized agents for Vue.js development. Works with existing AI-assisted development workflows and supports rapid prototyping to production scaling.<p>Currently supporting Vue.js projects with plans for React and other frameworks.<p>Try It\nEarly access available at <a href=\"https:&#x2F;&#x2F;vibecodekit.dev\" rel=\"nofollow\">https:&#x2F;&#x2F;vibecodekit.dev</a><p>This isn&#x27;t about replacing Vue CLI or Vite\u2014it&#x27;s about getting a production-ready foundation with AI that actually understands your stack. Would love feedback from Vue.js developers who&#x27;ve struggled with project setup overhead.<p>Questions I&#x27;m curious about:<p>- How much time do you spend on initial Vue.js project configuration?\n- What&#x27;s been your experience with AI coding assistants on Vue projects?\n- What would convince you to use a pre-configured starter over building from scratch?", "title": "Show HN: Vibe Code Kit code with confidence", "updated_at": "2025-10-06T15:47:47Z", "url": "https://vibecodekit.dev"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "samuelstros"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["eslint", "production"], "value": "I am prepared to get hammered by HN. Remember the dropbox comment <a href=\"https://news.ycombinator.com/item?id=9224\" rel=\"nofollow\">https://news.ycombinator.com/item?id=9224</a> ?<p>Hey HN,<p>I think I've found what could make localization of software simpler and, by accident, might lead to a new generation of software that is powered by files (?), version control, and git enabled workflows like branches &amp;&amp; PRs.<p># What I am building<p>I am building &quot;Stripe for localization&quot; which means infrastructure that eases localization (i18n) via dev tools (CLI, automation via CI/CD, IDE extension, <em>ESLint</em> for translations), an editor for translators to manage translations, and potentially more (share your feedback!).<p># One major problem<p>Localization is a coordination issue between different departments. Creating translations is the easy part. But, how can developers and translators collaborate together with ease? How do developers know whether translations exist and they can deploy to <em>production</em>? How can translators provide feedback on the UI e.g. the German translation is too long and breaks the UI?<p># The insight<p>1. Software engineering teams use version control enabled workflows for localization: Conduct changes (commits) -&gt; Open a PR (preview, discuss &amp; automate) -&gt; deploy.<p>2. Trying to sync states of multiple teams, especially of one (software engineers) use version control workflows like branches with each other is a massive pain without the upside of version control powered automation (CI/CD).<p>3. Wait a second. The workflow of change -&gt; pr -&gt; agree are universal (?) to any content driven collaboration. Couldn't we achieve cross team collaboration and automation on one source of truth if we pull translators into git repos [0]?<p># Abusing git as backend<p>The either great or absolutely horrible decision now is to build everything on git, including the editor, a (newborn - be gentle with feedback :D) baby of VSCode + Figma to manage translations.<p>## Pros<p>- no hosting, accounts, and synchronization required.<p>- use git workflows like pull requests.<p>- automation via CI/CD.<p>- single source of truth that developers and translators \ncollaborate on.<p>- unified architecture for dev tools and apps\n- low barrier for adoption. just one config file is needed.<p>## Cons<p>- uff, abusing a CLI as backend that runs in the browser on top of a virtual filesystem is challenging.<p>- scalability issues. larger repos (&gt;30MB) take minutes to load or crash the browser<p>- complicated workflows. ask a translator what a commit is.<p>- the benefit of git might not justify the engineering and education effort we are conducted right now<p># Try it out yourself (and roast me)<p>You can test the editor here <a href=\"https://inlang.com/editor/github.com/inlang/example\" rel=\"nofollow\">https://inlang.com/editor/github.com/inlang/example</a>.<p>While we are at it, could you try to contribute a translation? Can be jibberish, but it would make my day if I the contribution flow works :D<p>## Footnotes<p>[0] March 2022 &quot;git as single source of truth&quot; - <a href=\"https://github.com/inlang/inlang/discussions/115\">https://github.com/inlang/inlang/discussions/115</a>"}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Show HN: Stripe for localization that abuses Git as back end"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://github.com/inlang/inlang"}}, "_tags": ["story", "author_samuelstros", "story_34710359", "show_hn"], "author": "samuelstros", "children": [34712740], "created_at": "2023-02-08T16:25:02Z", "created_at_i": 1675873502, "num_comments": 3, "objectID": "34710359", "points": 2, "story_id": 34710359, "story_text": "I am prepared to get hammered by HN. Remember the dropbox comment <a href=\"https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=9224\" rel=\"nofollow\">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=9224</a> ?<p>Hey HN,<p>I think I&#x27;ve found what could make localization of software simpler and, by accident, might lead to a new generation of software that is powered by files (?), version control, and git enabled workflows like branches &amp;&amp; PRs.<p># What I am building<p>I am building &quot;Stripe for localization&quot; which means infrastructure that eases localization (i18n) via dev tools (CLI, automation via CI&#x2F;CD, IDE extension, ESLint for translations), an editor for translators to manage translations, and potentially more (share your feedback!).<p># One major problem<p>Localization is a coordination issue between different departments. Creating translations is the easy part. But, how can developers and translators collaborate together with ease? How do developers know whether translations exist and they can deploy to production? How can translators provide feedback on the UI e.g. the German translation is too long and breaks the UI?<p># The insight<p>1. Software engineering teams use version control enabled workflows for localization: Conduct changes (commits) -&gt; Open a PR (preview, discuss &amp; automate) -&gt; deploy.<p>2. Trying to sync states of multiple teams, especially of one (software engineers) use version control workflows like branches with each other is a massive pain without the upside of version control powered automation (CI&#x2F;CD).<p>3. Wait a second. The workflow of change -&gt; pr -&gt; agree are universal (?) to any content driven collaboration. Couldn&#x27;t we achieve cross team collaboration and automation on one source of truth if we pull translators into git repos [0]?<p># Abusing git as backend<p>The either great or absolutely horrible decision now is to build everything on git, including the editor, a (newborn - be gentle with feedback :D) baby of VSCode + Figma to manage translations.<p>## Pros<p>- no hosting, accounts, and synchronization required.<p>- use git workflows like pull requests.<p>- automation via CI&#x2F;CD.<p>- single source of truth that developers and translators \ncollaborate on.<p>- unified architecture for dev tools and apps\n- low barrier for adoption. just one config file is needed.<p>## Cons<p>- uff, abusing a CLI as backend that runs in the browser on top of a virtual filesystem is challenging.<p>- scalability issues. larger repos (&gt;30MB) take minutes to load or crash the browser<p>- complicated workflows. ask a translator what a commit is.<p>- the benefit of git might not justify the engineering and education effort we are conducted right now<p># Try it out yourself (and roast me)<p>You can test the editor here <a href=\"https:&#x2F;&#x2F;inlang.com&#x2F;editor&#x2F;github.com&#x2F;inlang&#x2F;example\" rel=\"nofollow\">https:&#x2F;&#x2F;inlang.com&#x2F;editor&#x2F;github.com&#x2F;inlang&#x2F;example</a>.<p>While we are at it, could you try to contribute a translation? Can be jibberish, but it would make my day if I the contribution flow works :D<p>## Footnotes<p>[0] March 2022 &quot;git as single source of truth&quot; - <a href=\"https:&#x2F;&#x2F;github.com&#x2F;inlang&#x2F;inlang&#x2F;discussions&#x2F;115\">https:&#x2F;&#x2F;github.com&#x2F;inlang&#x2F;inlang&#x2F;discussions&#x2F;115</a>", "title": "Show HN: Stripe for localization that abuses Git as back end", "updated_at": "2024-09-20T13:10:57Z", "url": "https://github.com/inlang/inlang"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "mullion"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["eslint", "production"], "value": "Hi HN \u2014 I built Mullion, an OSS TS toolkit to prevent LLM context leaks (admin/user, internal/external boundaries).<p>- Owned&lt;T, Scope&gt; tags data with trust scope\n- scope crossing requires explicit bridge(...)\n- <em>ESLint</em> rules flag cross-scope use / leaked values\n- OpenTelemetry-compatible tracing + cost estimation\nintegrates with Vercel AI SDK<p>npm i @mullion/core @mullion/ai-sdk<p><a href=\"https://github.com/mullionlabs/mullion-ts\" rel=\"nofollow\">https://github.com/mullionlabs/mullion-ts</a><p>Feedback welcome: does this model match how you handle trust boundaries in <em>production</em>?"}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Show HN: Mullion \u2013 type-safe LLM context management for TypeScript"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://github.com/mullionlabs/mullion-ts"}}, "_tags": ["story", "author_mullion", "story_46588907", "show_hn"], "author": "mullion", "created_at": "2026-01-12T14:23:13Z", "created_at_i": 1768227793, "num_comments": 0, "objectID": "46588907", "points": 2, "story_id": 46588907, "story_text": "Hi HN \u2014 I built Mullion, an OSS TS toolkit to prevent LLM context leaks (admin&#x2F;user, internal&#x2F;external boundaries).<p>- Owned&lt;T, Scope&gt; tags data with trust scope\n- scope crossing requires explicit bridge(...)\n- ESLint rules flag cross-scope use &#x2F; leaked values\n- OpenTelemetry-compatible tracing + cost estimation\nintegrates with Vercel AI SDK<p>npm i @mullion&#x2F;core @mullion&#x2F;ai-sdk<p><a href=\"https:&#x2F;&#x2F;github.com&#x2F;mullionlabs&#x2F;mullion-ts\" rel=\"nofollow\">https:&#x2F;&#x2F;github.com&#x2F;mullionlabs&#x2F;mullion-ts</a><p>Feedback welcome: does this model match how you handle trust boundaries in production?", "title": "Show HN: Mullion \u2013 type-safe LLM context management for TypeScript", "updated_at": "2026-01-12T14:25:49Z", "url": "https://github.com/mullionlabs/mullion-ts"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "rhinorackattack"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["eslint", "production"], "value": "Disclaimer - the goal isn't to build a fully fledged company from this. Rather build a project that developers/startups will find useful as well as generate some income for myself.<p>I\u2019m working on a project to streamline the setup of tech stacks for startups. There are countless free repos on GitHub designed to help startups hit the ground running, but they usually just give you the code, leaving a lot of configuration work to be done. My solution is different: I want to offer a unified platform that integrates with a range of 3rd-party vendors and automatically sets up their cloud environments using API keys or OAuth.<p>The Vision:\nIn my dashboard, users will provide the necessary API keys, and we'll take care of the rest, automatically configuring and deploying the entire tech stack. At the end of the process, they'll have a backend and frontend deployed on AWS, a working RDS, and everything fully terraformed. Think of it as a one-click solution to build and deploy a comprehensive, ready-to-go environment.<p>What\u2019s in the box:<p>The repo is comprised of a monorepo with a FE with a basic auth page for login/logout, backend, shared types, an admin FE dashboard and a whole bunch of necessary and modern technologies to get your *SaaS portal* up and running. (SEO is available but the expectation is that this product is behind a paywall/authwall.<p>The Code:<p>- Monorepo with FE, BE and shared types\n- React + Next.js (frontend)\n- pnpm\n- Nest.js (server)\n- Tailwind\n- Material UI\n- Apollo (GraphQL)\n- Jest (Testing)\n- Typescript + <em>ESLint</em> + Prettier + Husky\n- Turbo\n- TypeORM\n- Segment\n- Database migrations\n- Docker\n- Logging (Pino.js)<p>Configuration:<p>- Terraform\n- GitHub Actions (CI/CD)\n- Local DB env with docker compose<p>Deployment (3rd Parties):<p>- Sentry\n- Auth0\n- Analytics\n- Stripe\n- Managed staging/<em>production</em> on AWS\n- Storage with S3\n- Langchain (ChatGPT)\n- Feature Flags (LaunchDarkly)\n- Mail (mailgun) + Notifications (SNS)\n- Postgres (RDS)\n- Lambdas with SAM<p>Features:<p>- Shared types\n- Langchain\n- Admin dashboard\n- CLI\n- Docs<p>Extras:<p>- Storybook\n- SEO\n- i18n<p>The Value Proposition:<p>- Unified Setup: Quickly deploy a <em>production</em>-ready tech stack with minimal configuration.\n- Reduced Complexity: Even with bots and automations, setting up AWS and other tools can be complex. This tool simplifies the entire process.<p>Why Build This:<p>- Complexity Management: Managing roles and deployments across various cloud platforms can be a headache. This tool pulls together all the essential components and simplifies the deployment process.\n- Engineer-Level Setup: You typically need an engineer to set up AWS, but this solution makes it trivial for non-tech founders to deploy a professional-grade infrastructure across a wide range of necessary services to run your start up.<p>I'm looking for feedback and validation on this idea. What do you think?<p>Some Initial Questions:<p>- I\u2019m not presenting vendor alternatives for the MVP. Maybe later I can present more vendor options, but for now I\u2019m trying to take the vendor decision-making process away from the startups so they can just focus on building the products. Will this present some problems?\n- I\u2019ve chosen AWS because startups often have to spend time learning about AWS and having users, env, compute, DBs, storage etc auto set up will allow them to focus on building their product and not on complex infrastructure. Once they\u2019re in the ecosystem, they can leverage more of it. I know there are more modern and streamlined alternatives to some of these services e.g. Vercel, Cloudflare, Firebase, Railway, Digital Ocean app platform, Render, Aptible; or when it comes to databases; planetDB or SurrealDB etc.<p>Business Model:<p>- Offer the code for free, once off fee for auto deployment and set up"}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Ask HN: Idea Validation"}}, "_tags": ["story", "author_rhinorackattack", "story_40314582", "ask_hn"], "author": "rhinorackattack", "children": [40314703, 40314823, 40380254], "created_at": "2024-05-10T01:08:44Z", "created_at_i": 1715303324, "num_comments": 3, "objectID": "40314582", "points": 1, "story_id": 40314582, "story_text": "Disclaimer - the goal isn&#x27;t to build a fully fledged company from this. Rather build a project that developers&#x2F;startups will find useful as well as generate some income for myself.<p>I\u2019m working on a project to streamline the setup of tech stacks for startups. There are countless free repos on GitHub designed to help startups hit the ground running, but they usually just give you the code, leaving a lot of configuration work to be done. My solution is different: I want to offer a unified platform that integrates with a range of 3rd-party vendors and automatically sets up their cloud environments using API keys or OAuth.<p>The Vision:\nIn my dashboard, users will provide the necessary API keys, and we&#x27;ll take care of the rest, automatically configuring and deploying the entire tech stack. At the end of the process, they&#x27;ll have a backend and frontend deployed on AWS, a working RDS, and everything fully terraformed. Think of it as a one-click solution to build and deploy a comprehensive, ready-to-go environment.<p>What\u2019s in the box:<p>The repo is comprised of a monorepo with a FE with a basic auth page for login&#x2F;logout, backend, shared types, an admin FE dashboard and a whole bunch of necessary and modern technologies to get your *SaaS portal* up and running. (SEO is available but the expectation is that this product is behind a paywall&#x2F;authwall.<p>The Code:<p>- Monorepo with FE, BE and shared types\n- React + Next.js (frontend)\n- pnpm\n- Nest.js (server)\n- Tailwind\n- Material UI\n- Apollo (GraphQL)\n- Jest (Testing)\n- Typescript + ESLint + Prettier + Husky\n- Turbo\n- TypeORM\n- Segment\n- Database migrations\n- Docker\n- Logging (Pino.js)<p>Configuration:<p>- Terraform\n- GitHub Actions (CI&#x2F;CD)\n- Local DB env with docker compose<p>Deployment (3rd Parties):<p>- Sentry\n- Auth0\n- Analytics\n- Stripe\n- Managed staging&#x2F;production on AWS\n- Storage with S3\n- Langchain (ChatGPT)\n- Feature Flags (LaunchDarkly)\n- Mail (mailgun) + Notifications (SNS)\n- Postgres (RDS)\n- Lambdas with SAM<p>Features:<p>- Shared types\n- Langchain\n- Admin dashboard\n- CLI\n- Docs<p>Extras:<p>- Storybook\n- SEO\n- i18n<p>The Value Proposition:<p>- Unified Setup: Quickly deploy a production-ready tech stack with minimal configuration.\n- Reduced Complexity: Even with bots and automations, setting up AWS and other tools can be complex. This tool simplifies the entire process.<p>Why Build This:<p>- Complexity Management: Managing roles and deployments across various cloud platforms can be a headache. This tool pulls together all the essential components and simplifies the deployment process.\n- Engineer-Level Setup: You typically need an engineer to set up AWS, but this solution makes it trivial for non-tech founders to deploy a professional-grade infrastructure across a wide range of necessary services to run your start up.<p>I&#x27;m looking for feedback and validation on this idea. What do you think?<p>Some Initial Questions:<p>- I\u2019m not presenting vendor alternatives for the MVP. Maybe later I can present more vendor options, but for now I\u2019m trying to take the vendor decision-making process away from the startups so they can just focus on building the products. Will this present some problems?\n- I\u2019ve chosen AWS because startups often have to spend time learning about AWS and having users, env, compute, DBs, storage etc auto set up will allow them to focus on building their product and not on complex infrastructure. Once they\u2019re in the ecosystem, they can leverage more of it. I know there are more modern and streamlined alternatives to some of these services e.g. Vercel, Cloudflare, Firebase, Railway, Digital Ocean app platform, Render, Aptible; or when it comes to databases; planetDB or SurrealDB etc.<p>Business Model:<p>- Offer the code for free, once off fee for auto deployment and set up", "title": "Ask HN: Idea Validation", "updated_at": "2025-02-26T22:31:53Z"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "iamspathan"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["eslint", "production"], "value": "Hi HN,<p>I built llm-authz-audit because I kept seeing the same security issues in LLM-powered applications: API keys hardcoded next to OpenAI calls, FastAPI endpoints serving chat completions with zero auth, user input concatenated straight into prompts, and shared conversation memory with no session isolation.<p>These aren't hypothetical \u2014 they're patterns I found repeatedly across open-source LLM projects and <em>production</em> codebases.<p>What it does:<p>It's a static analyzer (think <em>eslint</em>/semgrep but purpose-built for LLM security) that scans Python, JavaScript, and TypeScript codebases for authorization and security gaps. It ships with 13 analyzers and 27 rules covering the OWASP Top 10 for LLM Applications:<p>- Prompt injection risks (unsanitized input in prompts, missing delimiters)\n- Hardcoded API keys (OpenAI, Anthropic, HuggingFace, AWS, generic)\n- Unauthenticated LLM endpoints (FastAPI, Flask, Express)\n- LangChain/LlamaIndex tools without RBAC\n- RAG retrievals without document-level access controls\n- Over-permissioned MCP server configs\n- Shared conversation memory without user scoping\n- Missing rate limiting, audit logging, output filtering\n- Credentials forwarded to LLM via prompt templates\nWould love feedback from anyone building or securing LLM applications."}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Show HN: LLM AuthZ Audit \u2013 find auth gaps and prompt injection in LLM apps"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://github.com/aiauthz/llm-authz-audit"}}, "_tags": ["story", "author_iamspathan", "story_47031695", "show_hn"], "author": "iamspathan", "children": [47109662], "created_at": "2026-02-16T06:50:39Z", "created_at_i": 1771224639, "num_comments": 0, "objectID": "47031695", "points": 1, "story_id": 47031695, "story_text": "Hi HN,<p>I built llm-authz-audit because I kept seeing the same security issues in LLM-powered applications: API keys hardcoded next to OpenAI calls, FastAPI endpoints serving chat completions with zero auth, user input concatenated straight into prompts, and shared conversation memory with no session isolation.<p>These aren&#x27;t hypothetical \u2014 they&#x27;re patterns I found repeatedly across open-source LLM projects and production codebases.<p>What it does:<p>It&#x27;s a static analyzer (think eslint&#x2F;semgrep but purpose-built for LLM security) that scans Python, JavaScript, and TypeScript codebases for authorization and security gaps. It ships with 13 analyzers and 27 rules covering the OWASP Top 10 for LLM Applications:<p>- Prompt injection risks (unsanitized input in prompts, missing delimiters)\n- Hardcoded API keys (OpenAI, Anthropic, HuggingFace, AWS, generic)\n- Unauthenticated LLM endpoints (FastAPI, Flask, Express)\n- LangChain&#x2F;LlamaIndex tools without RBAC\n- RAG retrievals without document-level access controls\n- Over-permissioned MCP server configs\n- Shared conversation memory without user scoping\n- Missing rate limiting, audit logging, output filtering\n- Credentials forwarded to LLM via prompt templates\nWould love feedback from anyone building or securing LLM applications.", "title": "Show HN: LLM AuthZ Audit \u2013 find auth gaps and prompt injection in LLM apps", "updated_at": "2026-02-22T09:55:25Z", "url": "https://github.com/aiauthz/llm-authz-audit"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "dan_sim"}, "story_text": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["eslint"], "value": "You can find it on GitHub at http://github.com/dsimard/ready.js<p>Ready.js does 4 things :<p><pre><code>  * Check if your javascript are valid with <em>jslint</em>.\n  * Optimize and minify your javascript with Closure Compiler.\n  * Watch your javascript files for <em>jslint</em> while you're coding.\n  * Create an aggregated file of all your javascripts.\n</code></pre>\nIt's written in node.js but can be used in any kind of project (rails, django, plain HTML)."}, "title": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["production"], "value": "ShowHN (weekend project) : Ready.js - prepare your js for <em>production</em>"}, "url": {"matchLevel": "none", "matchedWords": [], "value": ""}}, "_tags": ["story", "author_dan_sim", "story_1830963", "ask_hn"], "author": "dan_sim", "children": [1830966], "created_at": "2010-10-25T18:35:41Z", "created_at_i": 1288031741, "num_comments": 1, "objectID": "1830963", "points": 4, "story_id": 1830963, "story_text": "You can find it on GitHub at http://github.com/dsimard/ready.js<p>Ready.js does 4 things :<p><pre><code>  * Check if your javascript are valid with jslint.\n  * Optimize and minify your javascript with Closure Compiler.\n  * Watch your javascript files for jslint while you're coding.\n  * Create an aggregated file of all your javascripts.\n</code></pre>\nIt's written in node.js but can be used in any kind of project (rails, django, plain HTML).", "title": "ShowHN (weekend project) : Ready.js - prepare your js for production", "updated_at": "2023-09-06T20:11:57Z", "url": ""}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "infocaptor"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["eslint", "production"], "value": "This is more of a practical question on web app development and deployment process.<p>Here is some background information.<p>I use PHP for server side scripting, javascript for client side. I use Netbeans and notepad++.<p>I user Firefox and firebug for debugging and testing.<p>The process I use is very amateurish, I code something in netbeans, something in notepad++ and since there is nothing to compile, I just refresh the firefox browser and test it. This is convenient and faster compared to the Java development enviornment where you would have to atleast compile and deploy the jar files before you could run them.<p>I have been thinking of putting a formal process in my development and find it hard putting it together. There are so many things to do before you can deploy your final web app. I keep hearing <em>jslint</em>, compression, unit testing (selenium), Ant, YUI compressor etc but I am now looking for some steps that I can take to make me more organized.<p>For e.g I use netbeans but don't use any projects within it. I directly update the files. I don't use any source control but use my Iomega backup that saves each save into a different version and at the end of the day I backup the dev directory to my Amazon s3 account. For me development environment is just a DEV directory, TEST is my intermediate stage and PROD is the final directory that gets pushed out to the server. But all these directories are in the same apache home. I have few php scripts that just copies the needed files into the <em>production</em> directory. Thats about it for my development approach.<p>I know I am missing the following - Regression testing (manual or automated ??) - automated testing (selenium ??) - automated deployment (ANT ??) - source control (svn ??) - quality control (<em>jslint</em> ??)<p>Can someone explain what are the missing steps and how to go about filling those steps in order to have more professional approach. I am looking for tools with example tutorials in streamlining the whole development to deployment stage.<p>For me just getting a hang of database, server side and client side development all in synchronization was itself a huge accomplishment. And now I feel there is lot missing before you can produce quality web application.<p>For e.g I see lot of mention about using automated testing but how to put in use with respect to javascript and php. How to use ANT for the deployment etc.<p>Is this all too much for a single or two person development team? Is there a way to automate all the above so that I just keep coding in netbeans and then run a batch file that is configured once and run it everytime to produce the code in the <em>production</em> directory?<p>Lot of these information is scattered on the web and here, if someone can guide I would be happy to consolidate here.<p>Thank you for your patience :)"}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Ask HN: How to convert from amateur web app developer to professional?"}, "url": {"matchLevel": "none", "matchedWords": [], "value": ""}}, "_tags": ["story", "author_infocaptor", "story_2232029", "ask_hn"], "author": "infocaptor", "children": [2232074, 2232104, 2234562], "created_at": "2011-02-17T18:09:42Z", "created_at_i": 1297966182, "num_comments": 4, "objectID": "2232029", "points": 5, "story_id": 2232029, "story_text": "This is more of a practical question on web app development and deployment process.<p>Here is some background information.<p>I use PHP for server side scripting, javascript for client side. I use Netbeans and notepad++.<p>I user Firefox and firebug for debugging and testing.<p>The process I use is very amateurish, I code something in netbeans, something in notepad++ and since there is nothing to compile, I just refresh the firefox browser and test it. This is convenient and faster compared to the Java development enviornment where you would have to atleast compile and deploy the jar files before you could run them.<p>I have been thinking of putting a formal process in my development and find it hard putting it together. There are so many things to do before you can deploy your final web app. I keep hearing jslint, compression, unit testing (selenium), Ant, YUI compressor etc but I am now looking for some steps that I can take to make me more organized.<p>For e.g I use netbeans but don't use any projects within it. I directly update the files. I don't use any source control but use my Iomega backup that saves each save into a different version and at the end of the day I backup the dev directory to my Amazon s3 account. For me development environment is just a DEV directory, TEST is my intermediate stage and PROD is the final directory that gets pushed out to the server. But all these directories are in the same apache home. I have few php scripts that just copies the needed files into the production directory. Thats about it for my development approach.<p>I know I am missing the following - Regression testing (manual or automated ??) - automated testing (selenium ??) - automated deployment (ANT ??) - source control (svn ??) - quality control (jslint ??)<p>Can someone explain what are the missing steps and how to go about filling those steps in order to have more professional approach. I am looking for tools with example tutorials in streamlining the whole development to deployment stage.<p>For me just getting a hang of database, server side and client side development all in synchronization was itself a huge accomplishment. And now I feel there is lot missing before you can produce quality web application.<p>For e.g I see lot of mention about using automated testing but how to put in use with respect to javascript and php. How to use ANT for the deployment etc.<p>Is this all too much for a single or two person development team? Is there a way to automate all the above so that I just keep coding in netbeans and then run a batch file that is configured once and run it everytime to produce the code in the production directory?<p>Lot of these information is scattered on the web and here, if someone can guide I would be happy to consolidate here.<p>Thank you for your patience :)", "title": "Ask HN: How to convert from amateur web app developer to professional?", "updated_at": "2024-09-19T17:31:39Z", "url": ""}], "hitsPerPage": 15, "nbHits": 15, "nbPages": 1, "page": 0, "params": "query=eslint+production&tags=story&hitsPerPage=15&advancedSyntax=true&analyticsTags=backend", "processingTimeMS": 9, "processingTimingsMS": {"_request": {"roundTrip": 14}, "afterFetch": {"format": {"highlighting": 2, "total": 2}}, "fetch": {"query": 5, "scanning": 1, "total": 7}, "total": 9}, "query": "eslint production", "serverTimeMS": 11}}