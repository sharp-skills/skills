{"d": {"exhaustive": {"nbHits": false, "typo": false}, "exhaustiveNbHits": false, "exhaustiveTypo": false, "hits": [{"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "abdusm"}, "story_text": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["supabase"], "value": "Here are the two other options I'm considering for app, but I want to understand if <em>Supabase</em> is a more efficient alternative. Thanks for help!<p>First way: (low cost)\nVPS server on DigitalOcean\nSetup node server and nginx\nAPI and frontend managed by pm2 and serve through nginx as proxy\nSetup managed PostgreSQL at DigitalOcean<p>Second Way:\nReact app on AWS Amplify/Heroku\nLambda/Serverless node API in aws\nPostgreSQL at aws"}, "title": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["supabase", "production"], "value": "Is <em>Supabase</em> <em>Production</em> Ready?"}}, "_tags": ["story", "author_abdusm", "story_30491167", "ask_hn"], "author": "abdusm", "children": [30491221], "created_at": "2022-02-27T18:41:28Z", "created_at_i": 1645987288, "num_comments": 4, "objectID": "30491167", "points": 1, "story_id": 30491167, "story_text": "Here are the two other options I&#x27;m considering for app, but I want to understand if Supabase is a more efficient alternative. Thanks for help!<p>First way: (low cost)\nVPS server on DigitalOcean\nSetup node server and nginx\nAPI and frontend managed by pm2 and serve through nginx as proxy\nSetup managed PostgreSQL at DigitalOcean<p>Second Way:\nReact app on AWS Amplify&#x2F;Heroku\nLambda&#x2F;Serverless node API in aws\nPostgreSQL at aws", "title": "Is Supabase Production Ready?", "updated_at": "2024-09-20T10:40:01Z"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "hzia"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["supabase", "production"], "value": "Hi HN, I\u2019m Hamza from GitStart (<a href=\"https://gitstart.com/\">https://gitstart.com/</a>). We\u2019re building a service for engineering teams to assign tickets and get back PRs. Here\u2019s a video of how it works: <a href=\"https://www.loom.com/share/61d46a5b07e04b45a51af2a5008ee173\" rel=\"nofollow noreferrer\">https://www.loom.com/share/61d46a5b07e04b45a51af2a5008ee173</a><p>We recruit devs who want to grow from remote countries, to work full-time on these tickets and review each other\u2019s PRs. For tech teams it\u2019s pay as you go, and they only pay if they merge the PRs (we pay our devs a base regardless). \nGitStart is very personal to me because I struggled myself to start my career as a junior dev. Being born in Pakistan made it super hard to find my first remote job. Things changed with Google Summer of Code, which was the first time I got paid to contribute to a large <em>production</em> codebase.<p>When I became a staff engineer, I started mentoring junior devs on their solo projects. I then realized what they really needed was <em>production</em> code experience, so I started sending them tickets from my backlog to grow them through code reviews. I also paid them for it. They learned a lot and I got a lot done, which started GitStart.<p>That\u2019s why, in the description above, we say \u201cdevs who want to grow\u201d. This is key to what we do\u2014we are not just a body shop or middleman, and we don\u2019t charge by the hour. We provide useful mentorship to junior devs. We want to be a meaningful part of their career path.<p>Our thesis (to use that slightly pretentious word) is that the economics work better this way as well. There is a lot of junior dev talent in these countries whose potential will bever be realized by hourly piecework. What\u2019s needed are longer term relationships and work engagements, over the course of which a junior dev can learn and grow on a large <em>production</em> codebase. Much of this has to do with learning the culture of effective tech teams.<p>On the other side, effective tech teams don\u2019t want hourly piecework either. Clients tell us they love having developers dedicated to their project, becoming more familiar with the code over time. This is the way for value to be maximized on both sides.<p>A number of commercial open source repos already use us, so you can check out some of the PRs created by GitStart here:<p>Cal.com: <a href=\"https://github.com/calcom/cal.com/pulls?q=is%3Apr+author%3Agitstart-calcom+is%3Aclosed\">https://github.com/calcom/cal.com/pulls?q=is%3Apr+author%3Ag...</a><p>SourceGraph: <a href=\"https://github.com/sourcegraph/sourcegraph/pulls?q=is%3Apr+author%3Agitstart-sourcegraph+is%3Aclosed\">https://github.com/sourcegraph/sourcegraph/pulls?q=is%3Apr+a...</a><p>StoryBooks: <a href=\"https://github.com/storybookjs/storybook/pulls?q=is%3Apr+author%3Agitstart+is%3Aclosed\">https://github.com/storybookjs/storybook/pulls?q=is%3Apr+aut...</a><p>Strapi: <a href=\"https://github.com/strapi/strapi/pulls?q=is%3Aclosed+is%3Apr+author%3Agitstart\">https://github.com/strapi/strapi/pulls?q=is%3Aclosed+is%3Apr...</a><p><em>Supabase</em>: <a href=\"https://github.com/supabase/supabase/pulls?q=is%3Apr+author%3Agitstart+is%3Aclosed\">https://github.com/<em>supabase</em>/<em>supabase</em>/pulls?q=is%3Apr+author%...</a><p>Twenty: <a href=\"https://github.com/twentyhq/twenty/pulls?q=is%3Apr+author%3Agitstart-twenty+is%3Aclosed\">https://github.com/twentyhq/twenty/pulls?q=is%3Apr+author%3A...</a><p>Our main technical challenge has been securing code sharing. One solution was building GitSlice, which enables creating sub-repos that sync with the upstream repo. When GitStart devs create PRs on the platform, GitSlice syncs them upstream while pulling back CI/CD checks and review comments. This enables our devs to contribute with limited codebase access.<p>To prevent slices from breaking, we verify they run within a docker container, which also enables us to build review environments. Fun fact: we managed to support native iOS and Android codebases by building and running them on appetize.io instead of docker.<p>There have been countless attempts at this space so we would love to hear your feedback on how we approached this problem or your past experiences working with junior devs in this way. We look forward to a good conversation!"}, "title": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["production"], "value": "Launch HN: GitStart (YC S19) \u2013 Remote junior devs working on <em>production</em> PRs"}}, "_tags": ["story", "author_hzia", "story_37033753", "launch_hn"], "author": "hzia", "children": [37034487, 37034490, 37034676, 37034788, 37034914, 37034942, 37034988, 37035005, 37035036, 37035079, 37035228, 37035298, 37035508, 37035563, 37035594, 37035928, 37035967, 37036187, 37036512, 37036710, 37036730, 37036946, 37036952, 37037151, 37037156, 37037343, 37037455, 37037558, 37037615, 37038155, 37038260, 37040590, 37040644, 37044221, 37044361, 37044731, 37045346, 37045351, 37045575, 37049012, 37052076, 37057079, 37062226], "created_at": "2023-08-07T12:54:18Z", "created_at_i": 1691412858, "num_comments": 192, "objectID": "37033753", "points": 235, "story_id": 37033753, "story_text": "Hi HN, I\u2019m Hamza from GitStart (<a href=\"https:&#x2F;&#x2F;gitstart.com&#x2F;\">https:&#x2F;&#x2F;gitstart.com&#x2F;</a>). We\u2019re building a service for engineering teams to assign tickets and get back PRs. Here\u2019s a video of how it works: <a href=\"https:&#x2F;&#x2F;www.loom.com&#x2F;share&#x2F;61d46a5b07e04b45a51af2a5008ee173\" rel=\"nofollow noreferrer\">https:&#x2F;&#x2F;www.loom.com&#x2F;share&#x2F;61d46a5b07e04b45a51af2a5008ee173</a><p>We recruit devs who want to grow from remote countries, to work full-time on these tickets and review each other\u2019s PRs. For tech teams it\u2019s pay as you go, and they only pay if they merge the PRs (we pay our devs a base regardless). \nGitStart is very personal to me because I struggled myself to start my career as a junior dev. Being born in Pakistan made it super hard to find my first remote job. Things changed with Google Summer of Code, which was the first time I got paid to contribute to a large production codebase.<p>When I became a staff engineer, I started mentoring junior devs on their solo projects. I then realized what they really needed was production code experience, so I started sending them tickets from my backlog to grow them through code reviews. I also paid them for it. They learned a lot and I got a lot done, which started GitStart.<p>That\u2019s why, in the description above, we say \u201cdevs who want to grow\u201d. This is key to what we do\u2014we are not just a body shop or middleman, and we don\u2019t charge by the hour. We provide useful mentorship to junior devs. We want to be a meaningful part of their career path.<p>Our thesis (to use that slightly pretentious word) is that the economics work better this way as well. There is a lot of junior dev talent in these countries whose potential will bever be realized by hourly piecework. What\u2019s needed are longer term relationships and work engagements, over the course of which a junior dev can learn and grow on a large production codebase. Much of this has to do with learning the culture of effective tech teams.<p>On the other side, effective tech teams don\u2019t want hourly piecework either. Clients tell us they love having developers dedicated to their project, becoming more familiar with the code over time. This is the way for value to be maximized on both sides.<p>A number of commercial open source repos already use us, so you can check out some of the PRs created by GitStart here:<p>Cal.com: <a href=\"https:&#x2F;&#x2F;github.com&#x2F;calcom&#x2F;cal.com&#x2F;pulls?q=is%3Apr+author%3Agitstart-calcom+is%3Aclosed\">https:&#x2F;&#x2F;github.com&#x2F;calcom&#x2F;cal.com&#x2F;pulls?q=is%3Apr+author%3Ag...</a><p>SourceGraph: <a href=\"https:&#x2F;&#x2F;github.com&#x2F;sourcegraph&#x2F;sourcegraph&#x2F;pulls?q=is%3Apr+author%3Agitstart-sourcegraph+is%3Aclosed\">https:&#x2F;&#x2F;github.com&#x2F;sourcegraph&#x2F;sourcegraph&#x2F;pulls?q=is%3Apr+a...</a><p>StoryBooks: <a href=\"https:&#x2F;&#x2F;github.com&#x2F;storybookjs&#x2F;storybook&#x2F;pulls?q=is%3Apr+author%3Agitstart+is%3Aclosed\">https:&#x2F;&#x2F;github.com&#x2F;storybookjs&#x2F;storybook&#x2F;pulls?q=is%3Apr+aut...</a><p>Strapi: <a href=\"https:&#x2F;&#x2F;github.com&#x2F;strapi&#x2F;strapi&#x2F;pulls?q=is%3Aclosed+is%3Apr+author%3Agitstart\">https:&#x2F;&#x2F;github.com&#x2F;strapi&#x2F;strapi&#x2F;pulls?q=is%3Aclosed+is%3Apr...</a><p>Supabase: <a href=\"https:&#x2F;&#x2F;github.com&#x2F;supabase&#x2F;supabase&#x2F;pulls?q=is%3Apr+author%3Agitstart+is%3Aclosed\">https:&#x2F;&#x2F;github.com&#x2F;supabase&#x2F;supabase&#x2F;pulls?q=is%3Apr+author%...</a><p>Twenty: <a href=\"https:&#x2F;&#x2F;github.com&#x2F;twentyhq&#x2F;twenty&#x2F;pulls?q=is%3Apr+author%3Agitstart-twenty+is%3Aclosed\">https:&#x2F;&#x2F;github.com&#x2F;twentyhq&#x2F;twenty&#x2F;pulls?q=is%3Apr+author%3A...</a><p>Our main technical challenge has been securing code sharing. One solution was building GitSlice, which enables creating sub-repos that sync with the upstream repo. When GitStart devs create PRs on the platform, GitSlice syncs them upstream while pulling back CI&#x2F;CD checks and review comments. This enables our devs to contribute with limited codebase access.<p>To prevent slices from breaking, we verify they run within a docker container, which also enables us to build review environments. Fun fact: we managed to support native iOS and Android codebases by building and running them on appetize.io instead of docker.<p>There have been countless attempts at this space so we would love to hear your feedback on how we approached this problem or your past experiences working with junior devs in this way. We look forward to a good conversation!", "title": "Launch HN: GitStart (YC S19) \u2013 Remote junior devs working on production PRs", "updated_at": "2025-08-31T04:32:44Z"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "artahian"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["supabase", "production"], "value": "Hi all, Aram and Eduard here - authors of Modelence (<a href=\"https://github.com/modelence/modelence\" rel=\"nofollow\">https://github.com/modelence/modelence</a>), an all-in-one backend platform for teams that love TypeScript + MongoDB. Think <em>Supabase</em>, but for MongoDB: auth, cron jobs, email, monitoring, without glue code before you can ship.<p>As Karpathy (and many of us) noted, getting from prototype to <em>production</em> is mostly painful integration work. The pieces exist, but stitching them together reliably is the hard part: <a href=\"https://x.com/karpathy/status/1905051558783418370\" rel=\"nofollow\">https://x.com/karpathy/status/1905051558783418370</a>. YC AI Startup School talk about this - <a href=\"https://www.youtube.com/watch?feature=shared&amp;t=1940&amp;v=LCEmiRjPEtQ\" rel=\"nofollow\">https://www.youtube.com/watch?feature=shared&amp;t=1940&amp;v=LCEmiR...</a><p>We intend to fill those gaps! What you get out of the box:<p>- Authentication / user management<p>- Database<p>- Email integration (3rd party, but things like user verification emails work out of the box)<p>- AI integration<p>- Cron jobs<p>- Monitoring / Telemetry<p>- Configs &amp; secrets<p>- Analytics (coming soon)<p>- File uploads (coming soon)<p>How it runs: A Node.js backend with MongoDB. It's frontend-agnostic, so you can use our minimal Vite + React starter or drop Modelence behind an existing Next.js (or any) frontend.<p>We're also building a managed cloud, similar to what Vercel is for Next.js, except Modelence focuses on the backend instead of the frontend (Vercel is great for content sites like landing pages, blogs, etc, but things like persistent connections and complex backend logic outgrow it quickly). You can find a quick demo here: <a href=\"https://www.youtube.com/watch?v=S4f22FyPpI8\" rel=\"nofollow\">https://www.youtube.com/watch?v=S4f22FyPpI8</a><p>We're looking for early users (especially TS teams on MongoDB). Tell us what's missing, what's confusing, and what you'd want before trusting this in prod. Happy to answer anything!"}, "title": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["supabase"], "value": "Show HN: Modelence \u2013 <em>Supabase</em> for MongoDB"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://github.com/modelence/modelence"}}, "_tags": ["story", "author_artahian", "story_44902227", "show_hn"], "author": "artahian", "children": [44904242, 44904405, 44904579, 44905283, 44908113, 44908336], "created_at": "2025-08-14T16:13:29Z", "created_at_i": 1755188009, "num_comments": 14, "objectID": "44902227", "points": 38, "story_id": 44902227, "story_text": "Hi all, Aram and Eduard here - authors of Modelence (<a href=\"https:&#x2F;&#x2F;github.com&#x2F;modelence&#x2F;modelence\" rel=\"nofollow\">https:&#x2F;&#x2F;github.com&#x2F;modelence&#x2F;modelence</a>), an all-in-one backend platform for teams that love TypeScript + MongoDB. Think Supabase, but for MongoDB: auth, cron jobs, email, monitoring, without glue code before you can ship.<p>As Karpathy (and many of us) noted, getting from prototype to production is mostly painful integration work. The pieces exist, but stitching them together reliably is the hard part: <a href=\"https:&#x2F;&#x2F;x.com&#x2F;karpathy&#x2F;status&#x2F;1905051558783418370\" rel=\"nofollow\">https:&#x2F;&#x2F;x.com&#x2F;karpathy&#x2F;status&#x2F;1905051558783418370</a>. YC AI Startup School talk about this - <a href=\"https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?feature=shared&amp;t=1940&amp;v=LCEmiRjPEtQ\" rel=\"nofollow\">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?feature=shared&amp;t=1940&amp;v=LCEmiR...</a><p>We intend to fill those gaps! What you get out of the box:<p>- Authentication &#x2F; user management<p>- Database<p>- Email integration (3rd party, but things like user verification emails work out of the box)<p>- AI integration<p>- Cron jobs<p>- Monitoring &#x2F; Telemetry<p>- Configs &amp; secrets<p>- Analytics (coming soon)<p>- File uploads (coming soon)<p>How it runs: A Node.js backend with MongoDB. It&#x27;s frontend-agnostic, so you can use our minimal Vite + React starter or drop Modelence behind an existing Next.js (or any) frontend.<p>We&#x27;re also building a managed cloud, similar to what Vercel is for Next.js, except Modelence focuses on the backend instead of the frontend (Vercel is great for content sites like landing pages, blogs, etc, but things like persistent connections and complex backend logic outgrow it quickly). You can find a quick demo here: <a href=\"https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=S4f22FyPpI8\" rel=\"nofollow\">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=S4f22FyPpI8</a><p>We&#x27;re looking for early users (especially TS teams on MongoDB). Tell us what&#x27;s missing, what&#x27;s confusing, and what you&#x27;d want before trusting this in prod. Happy to answer anything!", "title": "Show HN: Modelence \u2013 Supabase for MongoDB", "updated_at": "2026-02-03T19:39:53Z", "url": "https://github.com/modelence/modelence"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "thenorthbay"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["supabase", "production"], "value": "Wouldn't it be cool to have a <em>Supabase</em> for SQLite?<p>The core idea here is: let SQLite run next to your application on the server; but have all features a client-server database give you.<p>What's the spec for this?<p>- SQLite runs next to server as <em>production</em> database<p>- That way, reads and writes are very fast<p>- In dev, some sort of worker auto-copies the prod DB to the local repo. <em>Production</em> bugs can be reproduced easily and code fixed quickly<p>- Have an interface that lets you access, view, and modify data in the <em>production</em> DB, kind of like Firebase. Might need a server of its own... or couldn't that just be the app server itself?<p>- SQLite auto-backs up to a bucket (like Litestream)<p>I kinda really want this, but haven't found anything quite like it. I've seen Turso, but it seems they focus more on global replication instead of the OSS developer experience I'm looking for.<p>What do you think? What am I missing?"}, "title": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["supabase"], "value": "Ask HN: Wouldn't it be cool to have a <em>Supabase</em> for SQLite?"}}, "_tags": ["story", "author_thenorthbay", "story_40156219", "ask_hn"], "author": "thenorthbay", "children": [40156302, 40157229, 40157624, 40157757, 40157970, 40158110, 40158120, 40158209, 40158323, 40158501, 40159135, 40159461, 40160588, 40161131, 40162783, 40166440, 40166558, 40166702, 40166784, 40174540, 40190772], "created_at": "2024-04-25T11:41:52Z", "created_at_i": 1714045312, "num_comments": 26, "objectID": "40156219", "points": 26, "story_id": 40156219, "story_text": "Wouldn&#x27;t it be cool to have a Supabase for SQLite?<p>The core idea here is: let SQLite run next to your application on the server; but have all features a client-server database give you.<p>What&#x27;s the spec for this?<p>- SQLite runs next to server as production database<p>- That way, reads and writes are very fast<p>- In dev, some sort of worker auto-copies the prod DB to the local repo. Production bugs can be reproduced easily and code fixed quickly<p>- Have an interface that lets you access, view, and modify data in the production DB, kind of like Firebase. Might need a server of its own... or couldn&#x27;t that just be the app server itself?<p>- SQLite auto-backs up to a bucket (like Litestream)<p>I kinda really want this, but haven&#x27;t found anything quite like it. I&#x27;ve seen Turso, but it seems they focus more on global replication instead of the OSS developer experience I&#x27;m looking for.<p>What do you think? What am I missing?", "title": "Ask HN: Wouldn't it be cool to have a Supabase for SQLite?", "updated_at": "2025-12-04T16:34:20Z"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "antonoo"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["supabase", "production"], "value": "Hey HN! Last summer I was struggling to get my Figma designs shipped - stuck waiting for dev bandwidth and trying to hand off every iteration. Got really frustrated and decided to do something about it.<p>Today we're launching a native integration between Builder.io and Lovable that lets designers directly convert Figma designs into <em>production</em>-ready apps. No code, no BS, just a working app you can iterate on.<p>How it works:<p>- Design in Figma (supports Auto-Layout)<p>- Export through Builder.io's plugin (2 modes: quick or pixel-perfect)<p>- Opens in Lovable where you can add functionality via prompts<p>- Connect <em>Supabase</em> for backend/auth/db if needed<p>- One click deploy to cloudflare<p>We've been testing this with early users and seeing designers ship entire apps solo in hours instead of weeks. One designer built and deployed a complete employee directory app from their Figma design in an afternoon.<p>Try it out: <a href=\"https://www.figma.com/community/plugin/747985167520967365/builder-io-ai-powered-figma-to-code-react-vue-tailwind-more?ref=producthunt\" rel=\"nofollow\">https://www.figma.com/community/plugin/747985167520967365/bu...</a><p>Docs: <a href=\"https://www.builder.io/blog/lovable-builder\" rel=\"nofollow\">https://www.builder.io/blog/lovable-builder</a><p>Would love feedback from fellow designers and builders. Especially interested in hearing from others who've dealt with design-dev handoff pains, and what parts of your workflow can this help with?<p>Built by builder.io and Lovable.dev teams. We're around to answer questions!"}, "title": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["production"], "value": "Show HN: Turn Figma into working apps without coding (Designer \u2013> <em>Production</em>)"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://www.builder.io/blog/lovable-builder"}}, "_tags": ["story", "author_antonoo", "story_42795069", "show_hn"], "author": "antonoo", "children": [42795169], "created_at": "2025-01-22T17:14:51Z", "created_at_i": 1737566091, "num_comments": 2, "objectID": "42795069", "points": 11, "story_id": 42795069, "story_text": "Hey HN! Last summer I was struggling to get my Figma designs shipped - stuck waiting for dev bandwidth and trying to hand off every iteration. Got really frustrated and decided to do something about it.<p>Today we&#x27;re launching a native integration between Builder.io and Lovable that lets designers directly convert Figma designs into production-ready apps. No code, no BS, just a working app you can iterate on.<p>How it works:<p>- Design in Figma (supports Auto-Layout)<p>- Export through Builder.io&#x27;s plugin (2 modes: quick or pixel-perfect)<p>- Opens in Lovable where you can add functionality via prompts<p>- Connect Supabase for backend&#x2F;auth&#x2F;db if needed<p>- One click deploy to cloudflare<p>We&#x27;ve been testing this with early users and seeing designers ship entire apps solo in hours instead of weeks. One designer built and deployed a complete employee directory app from their Figma design in an afternoon.<p>Try it out: <a href=\"https:&#x2F;&#x2F;www.figma.com&#x2F;community&#x2F;plugin&#x2F;747985167520967365&#x2F;builder-io-ai-powered-figma-to-code-react-vue-tailwind-more?ref=producthunt\" rel=\"nofollow\">https:&#x2F;&#x2F;www.figma.com&#x2F;community&#x2F;plugin&#x2F;747985167520967365&#x2F;bu...</a><p>Docs: <a href=\"https:&#x2F;&#x2F;www.builder.io&#x2F;blog&#x2F;lovable-builder\" rel=\"nofollow\">https:&#x2F;&#x2F;www.builder.io&#x2F;blog&#x2F;lovable-builder</a><p>Would love feedback from fellow designers and builders. Especially interested in hearing from others who&#x27;ve dealt with design-dev handoff pains, and what parts of your workflow can this help with?<p>Built by builder.io and Lovable.dev teams. We&#x27;re around to answer questions!", "title": "Show HN: Turn Figma into working apps without coding (Designer \u2013> Production)", "updated_at": "2025-03-10T18:07:22Z", "url": "https://www.builder.io/blog/lovable-builder"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "ReclusiveCoder"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["supabase", "production"], "value": "Many developers default to Elasticsearch or Solr for search\u2014but for small to medium apps, that\u2019s often overkill. Postgres has had full-text search built in for years, and with <em>Supabase</em> you can query it directly in SQL.<p>I wrote a short guide showing how to set it up and get blazing-fast search without extra infrastructure:<p>https://dev.to/reclusivecoder/skip-elasticsearch-build-blazing-fast-full-text-search-right-in-<em>supabase</em>-58pf<p>Would love to hear if others are using Postgres full-text search in <em>production</em>, and at what point/scale you'd rather switch to Elasticsearch."}, "title": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["supabase"], "value": "Skip Elasticsearch: Build Fast Full-Text Search Right in <em>Supabase</em>"}}, "_tags": ["story", "author_ReclusiveCoder", "story_45459475", "ask_hn"], "author": "ReclusiveCoder", "children": [45479998], "created_at": "2025-10-03T05:53:39Z", "created_at_i": 1759470819, "num_comments": 1, "objectID": "45459475", "points": 7, "story_id": 45459475, "story_text": "Many developers default to Elasticsearch or Solr for search\u2014but for small to medium apps, that\u2019s often overkill. Postgres has had full-text search built in for years, and with Supabase you can query it directly in SQL.<p>I wrote a short guide showing how to set it up and get blazing-fast search without extra infrastructure:<p>https:&#x2F;&#x2F;dev.to&#x2F;reclusivecoder&#x2F;skip-elasticsearch-build-blazing-fast-full-text-search-right-in-supabase-58pf<p>Would love to hear if others are using Postgres full-text search in production, and at what point&#x2F;scale you&#x27;d rather switch to Elasticsearch.", "title": "Skip Elasticsearch: Build Fast Full-Text Search Right in Supabase", "updated_at": "2025-10-05T08:54:57Z"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "honoyomu"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["supabase", "production"], "value": "Hi HN, we just released InsForge: an open-source, agent-native alternative to <em>Supabase</em>/Firebase designed from the ground up for AI coding agents like Cline, Cursor, and Claude Code. We're building <em>Supabase</em>'s features in an AI-native way, enabling agents to build and manage full-stack applications autonomously. (GitHub: <a href=\"https://github.com/InsForge/InsForge\">https://github.com/InsForge/InsForge</a>)<p>With coding agents, coding is actually the easy part now. You can build a working prototype for your idea in a few hours and run it locally. But to make it <em>production</em>-ready, you still have a long list of things to do manually, which might take a week or so:\n1. Get API keys for external services\n2. Set up authentication\n3. Configure a database and storage\n4. Add payments\n5. Set up a custom domain\n6. Deploy on Vercel<p>And none of these is really &quot;coding.&quot; It's just you switching tabs, opening dashboards, copying tokens, pasting configs. The interesting part is your agents know exactly what to do. They can walk you through every step - &quot;go to this URL, click that button, paste this key&quot; - but they can't actually do it themselves. Why can't you just do it for me? Because all of these backend/devops platforms and services were built for humans, not for agents.<p>So we built InsForge. We built an MCP Server as middleware and redesigned the backend API to give agents persistent context, so they can:\n1. Learn how to use InsForge during the session (re-check documentation if needed)\n2. Understand the current backend structure before making changes, so configurations are more accurate\n3. Make changes, debug, check logs, and update settings on their own<p>Example: you type &quot;help me build an Instagram clone social media app&quot; in your Cursor/Claude Code, then it will communicate and configure the entire backend on InsForge:\n- Auth: Google + email/password login\n- Database Tables: users, posts, comments, likes, profiles\n- File Storage Buckets: avatars, post-images<p>And then it will write the fullstack application without you doing anything. You stay in your IDE or agent interface, focus on writing prompts and QA-ing the result, and let your agent handle the rest.<p>This is an early release, and we'd appreciate feedback from the community. Try it out and let us know what breaks or what features you'd want to see. We're trying to make prompt-to-<em>production</em> a reality!<p>P.S: In the coming weeks (by the end of August), we'll be launching a few new features:\n- Cloud Hosting Platform\n- Serverless Functions\n- Site Deploy<p>We'll be around in the comments!"}, "title": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["supabase"], "value": "Show HN: InsForge \u2013 Open-source agent-native alternative to <em>Supabase</em>"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://github.com/InsForge/InsForge"}}, "_tags": ["story", "author_honoyomu", "story_44772898", "show_hn"], "author": "honoyomu", "children": [44777654], "created_at": "2025-08-03T00:08:58Z", "created_at_i": 1754179738, "num_comments": 1, "objectID": "44772898", "points": 7, "story_id": 44772898, "story_text": "Hi HN, we just released InsForge: an open-source, agent-native alternative to Supabase&#x2F;Firebase designed from the ground up for AI coding agents like Cline, Cursor, and Claude Code. We&#x27;re building Supabase&#x27;s features in an AI-native way, enabling agents to build and manage full-stack applications autonomously. (GitHub: <a href=\"https:&#x2F;&#x2F;github.com&#x2F;InsForge&#x2F;InsForge\">https:&#x2F;&#x2F;github.com&#x2F;InsForge&#x2F;InsForge</a>)<p>With coding agents, coding is actually the easy part now. You can build a working prototype for your idea in a few hours and run it locally. But to make it production-ready, you still have a long list of things to do manually, which might take a week or so:\n1. Get API keys for external services\n2. Set up authentication\n3. Configure a database and storage\n4. Add payments\n5. Set up a custom domain\n6. Deploy on Vercel<p>And none of these is really &quot;coding.&quot; It&#x27;s just you switching tabs, opening dashboards, copying tokens, pasting configs. The interesting part is your agents know exactly what to do. They can walk you through every step - &quot;go to this URL, click that button, paste this key&quot; - but they can&#x27;t actually do it themselves. Why can&#x27;t you just do it for me? Because all of these backend&#x2F;devops platforms and services were built for humans, not for agents.<p>So we built InsForge. We built an MCP Server as middleware and redesigned the backend API to give agents persistent context, so they can:\n1. Learn how to use InsForge during the session (re-check documentation if needed)\n2. Understand the current backend structure before making changes, so configurations are more accurate\n3. Make changes, debug, check logs, and update settings on their own<p>Example: you type &quot;help me build an Instagram clone social media app&quot; in your Cursor&#x2F;Claude Code, then it will communicate and configure the entire backend on InsForge:\n- Auth: Google + email&#x2F;password login\n- Database Tables: users, posts, comments, likes, profiles\n- File Storage Buckets: avatars, post-images<p>And then it will write the fullstack application without you doing anything. You stay in your IDE or agent interface, focus on writing prompts and QA-ing the result, and let your agent handle the rest.<p>This is an early release, and we&#x27;d appreciate feedback from the community. Try it out and let us know what breaks or what features you&#x27;d want to see. We&#x27;re trying to make prompt-to-production a reality!<p>P.S: In the coming weeks (by the end of August), we&#x27;ll be launching a few new features:\n- Cloud Hosting Platform\n- Serverless Functions\n- Site Deploy<p>We&#x27;ll be around in the comments!", "title": "Show HN: InsForge \u2013 Open-source agent-native alternative to Supabase", "updated_at": "2025-08-03T20:20:42Z", "url": "https://github.com/InsForge/InsForge"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "selfdb_io"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["supabase", "production"], "value": "Hey HN!<p>We're a small team of developers who, like many of you, love the power and convenience of Backend-as-a-Service (BaaS) platforms. However, we've also felt the sting of vendor lock-in, wrestled with the complexities of self-hosting feature-rich open-source alternatives, and worried about unpredictable costs or the sudden disappearance of free tiers that many indie devs and small projects rely on.<p>We believe developers deserve more control and simplicity without sacrificing functionality. After countless hours spent navigating these challenges, we decided to build the solution we wished existed.<p>So, we built SelfDB: a self-hosted, open-source alternative to platforms like <em>Supabase</em> or Firebase. SelfDB provides a PostgreSQL database, secure JWT-based authentication (with anonymous access capabilities), integrated object storage, WebSocket-based real-time updates, and serverless cloud functions powered by Deno 2.0 \u2013 all packaged into a single, easy-to-deploy containerized platform.<p>Our goal is to give you the comprehensive features you expect from a modern BaaS, but with the freedom and control that comes from truly owning your backend stack.<p>Here\u2019s what SelfDB offers:<p>Full PostgreSQL Power: Your data, your schema, no compromises. Direct SQL access when you need it.<p>Robust Authentication: Secure user management with JWT tokens and flexible anonymous access.<p>Integrated Object Storage: A dedicated SelfDB Storage Service for your files and media.<p>Real-time Updates: Keep your applications in sync effortlessly using WebSockets.<p>Modern Cloud Functions: Write custom serverless logic with Deno 2.0, benefiting from its security-first approach and native TypeScript support.<p>Dead-Simple Deployment: This is where we really focused. Forget wrestling with a dozen different containers for a self-hosted BaaS. With SelfDB, you just need to unzip , configure your .env file, and run ./start.sh. That\u2019s it.<p>Truly Open &amp; Yours: Your SelfDB purchase includes full access to our source code, empowering you to redeploy the software as often as you need. While resale is not permitted, you have the freedom to modify the code to perfectly fit your requirements. Your purchase also grants you access to our exclusive customer portal. Here, you'll receive continuous, free updates and can connect with the vibrant SelfDB community to network, report bugs, and provide valuable feedback.<p><em>Production</em>-Ready: We've architected SelfDB with security, logging, and monitoring considerations from the outset, so you can build with confidence.\nUnder the hood, SelfDB leverages a FastAPI backend, known for its high performance and developer-friendly features , ensuring a responsive API. The cloud functions run in a Deno 2.0 environment, offering a modern and secure way to extend your backend. The entire platform is containerized using Docker and Docker Compose, with persistent data managed through Docker named volumes. You can get up and running locally with just a few commands: Full details, including the architecture diagram, are in zip you get when you buy Selfdb.<p>To celebrate our launch and thank the early adopters in the HN community, we're offering. This is a great way to try out the extended features while supporting the project. You can find more details and grab the offer at : <a href=\"https://selfdb.io\" rel=\"nofollow\">https://selfdb.io</a><p>We're incredibly excited to share SelfDB with you today!<p>SelfDB is new, and your feedback is invaluable to us. What are your biggest BaaS pain points? What features would you love to see in a self-hosted platform like SelfDB? We'll be here in the comments all day to answer your questions and hear your thoughts.<p>Thanks for checking out SelfDB!"}, "title": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["supabase"], "value": "Show HN: SelfDB \u2013 Ditch <em>Supabase</em> and Firebase Lock-In, Self-Host Simply"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://selfdb.io"}}, "_tags": ["story", "author_selfdb_io", "story_44222380", "show_hn"], "author": "selfdb_io", "children": [44222985, 44223865, 44224197, 44224760], "created_at": "2025-06-09T08:13:14Z", "created_at_i": 1749456794, "num_comments": 8, "objectID": "44222380", "points": 6, "story_id": 44222380, "story_text": "Hey HN!<p>We&#x27;re a small team of developers who, like many of you, love the power and convenience of Backend-as-a-Service (BaaS) platforms. However, we&#x27;ve also felt the sting of vendor lock-in, wrestled with the complexities of self-hosting feature-rich open-source alternatives, and worried about unpredictable costs or the sudden disappearance of free tiers that many indie devs and small projects rely on.<p>We believe developers deserve more control and simplicity without sacrificing functionality. After countless hours spent navigating these challenges, we decided to build the solution we wished existed.<p>So, we built SelfDB: a self-hosted, open-source alternative to platforms like Supabase or Firebase. SelfDB provides a PostgreSQL database, secure JWT-based authentication (with anonymous access capabilities), integrated object storage, WebSocket-based real-time updates, and serverless cloud functions powered by Deno 2.0 \u2013 all packaged into a single, easy-to-deploy containerized platform.<p>Our goal is to give you the comprehensive features you expect from a modern BaaS, but with the freedom and control that comes from truly owning your backend stack.<p>Here\u2019s what SelfDB offers:<p>Full PostgreSQL Power: Your data, your schema, no compromises. Direct SQL access when you need it.<p>Robust Authentication: Secure user management with JWT tokens and flexible anonymous access.<p>Integrated Object Storage: A dedicated SelfDB Storage Service for your files and media.<p>Real-time Updates: Keep your applications in sync effortlessly using WebSockets.<p>Modern Cloud Functions: Write custom serverless logic with Deno 2.0, benefiting from its security-first approach and native TypeScript support.<p>Dead-Simple Deployment: This is where we really focused. Forget wrestling with a dozen different containers for a self-hosted BaaS. With SelfDB, you just need to unzip , configure your .env file, and run .&#x2F;start.sh. That\u2019s it.<p>Truly Open &amp; Yours: Your SelfDB purchase includes full access to our source code, empowering you to redeploy the software as often as you need. While resale is not permitted, you have the freedom to modify the code to perfectly fit your requirements. Your purchase also grants you access to our exclusive customer portal. Here, you&#x27;ll receive continuous, free updates and can connect with the vibrant SelfDB community to network, report bugs, and provide valuable feedback.<p>Production-Ready: We&#x27;ve architected SelfDB with security, logging, and monitoring considerations from the outset, so you can build with confidence.\nUnder the hood, SelfDB leverages a FastAPI backend, known for its high performance and developer-friendly features , ensuring a responsive API. The cloud functions run in a Deno 2.0 environment, offering a modern and secure way to extend your backend. The entire platform is containerized using Docker and Docker Compose, with persistent data managed through Docker named volumes. You can get up and running locally with just a few commands: Full details, including the architecture diagram, are in zip you get when you buy Selfdb.<p>To celebrate our launch and thank the early adopters in the HN community, we&#x27;re offering. This is a great way to try out the extended features while supporting the project. You can find more details and grab the offer at : <a href=\"https:&#x2F;&#x2F;selfdb.io\" rel=\"nofollow\">https:&#x2F;&#x2F;selfdb.io</a><p>We&#x27;re incredibly excited to share SelfDB with you today!<p>SelfDB is new, and your feedback is invaluable to us. What are your biggest BaaS pain points? What features would you love to see in a self-hosted platform like SelfDB? We&#x27;ll be here in the comments all day to answer your questions and hear your thoughts.<p>Thanks for checking out SelfDB!", "title": "Show HN: SelfDB \u2013 Ditch Supabase and Firebase Lock-In, Self-Host Simply", "updated_at": "2025-11-23T20:53:54Z", "url": "https://selfdb.io"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "jumski"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["supabase", "production"], "value": "Hi HN, I'm jumski. I spent last year building pgflow - a workflow orchestration engine built entirely on <em>Supabase</em> primitives (Postgres, Queues, Edge Functions, Realtime).<p><i>How This Started</i><p>I was transitioning to <em>Supabase</em> and building a personal app with multi-step LLM pipelines. I needed these to trigger from DB changes, cron, and the browser - but every workflow solution required external services.<p>From my Sidekiq experience, I knew that having each step handler send the next message to the queue shouldn't be part of business logic - it's error-prone and scattered. I realized I could move all orchestration to SQL - let the database decide what runs next while handlers focus purely on their task. To make this work on <em>Supabase</em> without external services, I created a self-respawning worker on Edge Functions to bypass time limits.<p><i>The Problem</i><p>Building workflows on <em>Supabase</em> today means manually wiring pg_cron schedules, pgmq queues, Edge Functions, and state tables. For a simple article processing workflow (fetch \u2192 parallel summarize + extract \u2192 publish), you're writing ~240 lines across 3 queue setups, 3 Edge Functions, 3 cron schedules. Tedious boilerplate.<p><i>What pgflow Does</i><p>Same workflow, 20 lines:<p><pre><code>  new Flow&lt;{ url: string }&gt;({ slug: 'article_flow' })\n    .step({ slug: 'fetchArticle' },\n      (input) =&gt; scrapeUrl(input.run.url))\n    .step({ slug: 'summarize', dependsOn: ['fetchArticle'] },\n      (input) =&gt; summarize(input.fetchArticle))\n    .step({ slug: 'extractKeywords', dependsOn: ['fetchArticle'] },\n      (input) =&gt; extractKeywords(input.fetchArticle))\n    .step({ slug: 'publish', dependsOn: ['summarize', 'extractKeywords'] },\n      (input) =&gt; publishArticle(input.summarize, input.extractKeywords));\n</code></pre>\nFlow inputs and outputs are fully type-inferred - your IDE autocompletes dependencies and catches errors at compile time. The only type annotation needed is the flow input.<p>You write workflows in TypeScript, compile them to SQL inserts that define your graph structure, and pgflow handles everything else. Postgres IS the orchestrator - managing a DAG of state machines, using pgmq to distribute tasks to workers. All state changes are fully transactional.<p><i>vs Alternatives</i><p>Unlike DBOS which uses decorators on imperative code, you explicitly define your DAG upfront. Unlike Trigger.dev/Inngest, everything lives in your existing <em>Supabase</em> project. You can query workflow state directly with SQL, and start flows from DB triggers or pg_cron.<p><i>Try It</i><p>- Demo: <a href=\"https://demo.pgflow.dev\" rel=\"nofollow\">https://demo.pgflow.dev</a> (paste any article URL)<p>- Docs: <a href=\"https://pgflow.dev\" rel=\"nofollow\">https://pgflow.dev</a><p>- GitHub: <a href=\"https://github.com/pgflow-dev/pgflow\" rel=\"nofollow\">https://github.com/pgflow-dev/pgflow</a><p><i>Status:</i> Beta - teams are using it in <em>production</em>. Fully open source, Apache 2.0 licensed.<p><i>Questions for HN:</i><p>What <em>Supabase</em> automations are you currently duct-taping together?<p>What's stopping you from using existing workflow tools?<p>Also curious: is SQL-based orchestration taking the &quot;everything in the database&quot; philosophy one step too far?"}, "title": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["supabase"], "value": "Show HN: pgflow \u2013 Workflows for <em>Supabase</em>, no external services (Postgres-first)"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://demo.pgflow.dev/"}}, "_tags": ["story", "author_jumski", "story_45899152", "show_hn"], "author": "jumski", "created_at": "2025-11-12T12:06:13Z", "created_at_i": 1762949173, "num_comments": 0, "objectID": "45899152", "points": 4, "story_id": 45899152, "story_text": "Hi HN, I&#x27;m jumski. I spent last year building pgflow - a workflow orchestration engine built entirely on Supabase primitives (Postgres, Queues, Edge Functions, Realtime).<p><i>How This Started</i><p>I was transitioning to Supabase and building a personal app with multi-step LLM pipelines. I needed these to trigger from DB changes, cron, and the browser - but every workflow solution required external services.<p>From my Sidekiq experience, I knew that having each step handler send the next message to the queue shouldn&#x27;t be part of business logic - it&#x27;s error-prone and scattered. I realized I could move all orchestration to SQL - let the database decide what runs next while handlers focus purely on their task. To make this work on Supabase without external services, I created a self-respawning worker on Edge Functions to bypass time limits.<p><i>The Problem</i><p>Building workflows on Supabase today means manually wiring pg_cron schedules, pgmq queues, Edge Functions, and state tables. For a simple article processing workflow (fetch \u2192 parallel summarize + extract \u2192 publish), you&#x27;re writing ~240 lines across 3 queue setups, 3 Edge Functions, 3 cron schedules. Tedious boilerplate.<p><i>What pgflow Does</i><p>Same workflow, 20 lines:<p><pre><code>  new Flow&lt;{ url: string }&gt;({ slug: &#x27;article_flow&#x27; })\n    .step({ slug: &#x27;fetchArticle&#x27; },\n      (input) =&gt; scrapeUrl(input.run.url))\n    .step({ slug: &#x27;summarize&#x27;, dependsOn: [&#x27;fetchArticle&#x27;] },\n      (input) =&gt; summarize(input.fetchArticle))\n    .step({ slug: &#x27;extractKeywords&#x27;, dependsOn: [&#x27;fetchArticle&#x27;] },\n      (input) =&gt; extractKeywords(input.fetchArticle))\n    .step({ slug: &#x27;publish&#x27;, dependsOn: [&#x27;summarize&#x27;, &#x27;extractKeywords&#x27;] },\n      (input) =&gt; publishArticle(input.summarize, input.extractKeywords));\n</code></pre>\nFlow inputs and outputs are fully type-inferred - your IDE autocompletes dependencies and catches errors at compile time. The only type annotation needed is the flow input.<p>You write workflows in TypeScript, compile them to SQL inserts that define your graph structure, and pgflow handles everything else. Postgres IS the orchestrator - managing a DAG of state machines, using pgmq to distribute tasks to workers. All state changes are fully transactional.<p><i>vs Alternatives</i><p>Unlike DBOS which uses decorators on imperative code, you explicitly define your DAG upfront. Unlike Trigger.dev&#x2F;Inngest, everything lives in your existing Supabase project. You can query workflow state directly with SQL, and start flows from DB triggers or pg_cron.<p><i>Try It</i><p>- Demo: <a href=\"https:&#x2F;&#x2F;demo.pgflow.dev\" rel=\"nofollow\">https:&#x2F;&#x2F;demo.pgflow.dev</a> (paste any article URL)<p>- Docs: <a href=\"https:&#x2F;&#x2F;pgflow.dev\" rel=\"nofollow\">https:&#x2F;&#x2F;pgflow.dev</a><p>- GitHub: <a href=\"https:&#x2F;&#x2F;github.com&#x2F;pgflow-dev&#x2F;pgflow\" rel=\"nofollow\">https:&#x2F;&#x2F;github.com&#x2F;pgflow-dev&#x2F;pgflow</a><p><i>Status:</i> Beta - teams are using it in production. Fully open source, Apache 2.0 licensed.<p><i>Questions for HN:</i><p>What Supabase automations are you currently duct-taping together?<p>What&#x27;s stopping you from using existing workflow tools?<p>Also curious: is SQL-based orchestration taking the &quot;everything in the database&quot; philosophy one step too far?", "title": "Show HN: pgflow \u2013 Workflows for Supabase, no external services (Postgres-first)", "updated_at": "2025-11-19T14:18:55Z", "url": "https://demo.pgflow.dev/"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "4htmlgames"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["supabase", "production"], "value": "I built a boilerplate that lets developers launch an AI image generation app in hours instead of weeks.\nIt includes Next.js 15, <em>Supabase</em> auth/storage, Stripe integration, rate limiting, and support for 50+ Replicate models out of the box.\nThe goal was to avoid rebuilding the same auth, credits, webhooks, and image pipeline every time.\nWould love feedback on architecture, DX, and what features are missing for real <em>production</em> use.<p>Landing Page / Waitlist here: <a href=\"https://lacy-yoke-439.notion.site/PlutoSaaS-Build-Your-AI-Image-SaaS-in-Minutes-eeae4c7f9f1c42e590aee330dd070198\" rel=\"nofollow\">https://lacy-yoke-439.notion.site/PlutoSaaS-Build-Your-AI-Im...</a>"}, "title": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["supabase"], "value": "Show HN: AI Image Generation Boilerplate (Next.js and <em>Supabase</em> and Stripe)"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://lacy-yoke-439.notion.site/PlutoSaaS-Build-Your-AI-Image-SaaS-in-Minutes-eeae4c7f9f1c42e590aee330dd070198"}}, "_tags": ["story", "author_4htmlgames", "story_46146331", "show_hn"], "author": "4htmlgames", "created_at": "2025-12-04T11:23:29Z", "created_at_i": 1764847409, "num_comments": 0, "objectID": "46146331", "points": 2, "story_id": 46146331, "story_text": "I built a boilerplate that lets developers launch an AI image generation app in hours instead of weeks.\nIt includes Next.js 15, Supabase auth&#x2F;storage, Stripe integration, rate limiting, and support for 50+ Replicate models out of the box.\nThe goal was to avoid rebuilding the same auth, credits, webhooks, and image pipeline every time.\nWould love feedback on architecture, DX, and what features are missing for real production use.<p>Landing Page &#x2F; Waitlist here: <a href=\"https:&#x2F;&#x2F;lacy-yoke-439.notion.site&#x2F;PlutoSaaS-Build-Your-AI-Image-SaaS-in-Minutes-eeae4c7f9f1c42e590aee330dd070198\" rel=\"nofollow\">https:&#x2F;&#x2F;lacy-yoke-439.notion.site&#x2F;PlutoSaaS-Build-Your-AI-Im...</a>", "title": "Show HN: AI Image Generation Boilerplate (Next.js and Supabase and Stripe)", "updated_at": "2025-12-04T11:31:18Z", "url": "https://lacy-yoke-439.notion.site/PlutoSaaS-Build-Your-AI-Image-SaaS-in-Minutes-eeae4c7f9f1c42e590aee330dd070198"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "Razikus"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["supabase", "production"], "value": "Hey everyone!<p>I\u2019ve built a <em>production</em>-ready SaaS template using Next.js 15, <em>Supabase</em>, and Tailwind CSS. This template includes everything needed to quickly launch your SaaS product, including authentication, user management, file storage, and more.<p>It also have migrations, configs, and can be started under 10 minutes<p>Video of deployment:\n<a href=\"https://www.youtube.com/watch?v=kzbXavLndmE\" rel=\"nofollow\">https://www.youtube.com/watch?v=kzbXavLndmE</a>"}, "title": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["supabase"], "value": "Show HN: <em>Supabase</em> Next.js SaaS Template \u2013 With Auth, RLS, and File Management"}, "url": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["supabase"], "value": "https://github.com/Razikus/<em>supabase</em>-nextjs-template"}}, "_tags": ["story", "author_Razikus", "story_42882489", "show_hn"], "author": "Razikus", "children": [42882499, 42882632, 42886443], "created_at": "2025-01-30T21:46:07Z", "created_at_i": 1738273567, "num_comments": 3, "objectID": "42882489", "points": 1, "story_id": 42882489, "story_text": "Hey everyone!<p>I\u2019ve built a production-ready SaaS template using Next.js 15, Supabase, and Tailwind CSS. This template includes everything needed to quickly launch your SaaS product, including authentication, user management, file storage, and more.<p>It also have migrations, configs, and can be started under 10 minutes<p>Video of deployment:\n<a href=\"https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=kzbXavLndmE\" rel=\"nofollow\">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=kzbXavLndmE</a>", "title": "Show HN: Supabase Next.js SaaS Template \u2013 With Auth, RLS, and File Management", "updated_at": "2025-02-02T20:35:42Z", "url": "https://github.com/Razikus/supabase-nextjs-template"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "aiseoscan"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["supabase", "production"], "value": "I made CyberChecker after finding exposed Stripe keys in <em>production</em> apps 73% of the time<p>I was doing security audits and kept finding the same issues: API keys in JavaScript bundles, missing CSP headers, exposed .env files, <em>Supabase</em> anon keys without RLS. Basic stuff that's trivial to exploit but somehow everywhere.<p>Built an automated scanner that runs 50+ checks in ~60 seconds: SSL/TLS config, security headers, OWASP Top 10, secrets detection, SQL injection patterns. Free scan shows vulnerability count, $39 for the full report with exact locations + copy-paste fixes.<p>Tech stack: Next.js, <em>Supabase</em> for storage, custom scanners (no third-party APIs), Vercel edge functions.<p>The scary part: 94% of sites I've scanned have at least one critical vulnerability. Most are completely unaware.<p><a href=\"https://cyber-checker.com\" rel=\"nofollow\">https://cyber-checker.com</a>"}, "title": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["production"], "value": "Show HN:I made CyberChecker after finding exposed Stripe keys in <em>production</em>"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://www.cyber-checker.com/"}}, "_tags": ["story", "author_aiseoscan", "story_46898458", "show_hn"], "author": "aiseoscan", "created_at": "2026-02-05T11:17:10Z", "created_at_i": 1770290230, "num_comments": 0, "objectID": "46898458", "points": 1, "story_id": 46898458, "story_text": "I made CyberChecker after finding exposed Stripe keys in production apps 73% of the time<p>I was doing security audits and kept finding the same issues: API keys in JavaScript bundles, missing CSP headers, exposed .env files, Supabase anon keys without RLS. Basic stuff that&#x27;s trivial to exploit but somehow everywhere.<p>Built an automated scanner that runs 50+ checks in ~60 seconds: SSL&#x2F;TLS config, security headers, OWASP Top 10, secrets detection, SQL injection patterns. Free scan shows vulnerability count, $39 for the full report with exact locations + copy-paste fixes.<p>Tech stack: Next.js, Supabase for storage, custom scanners (no third-party APIs), Vercel edge functions.<p>The scary part: 94% of sites I&#x27;ve scanned have at least one critical vulnerability. Most are completely unaware.<p><a href=\"https:&#x2F;&#x2F;cyber-checker.com\" rel=\"nofollow\">https:&#x2F;&#x2F;cyber-checker.com</a>", "title": "Show HN:I made CyberChecker after finding exposed Stripe keys in production", "updated_at": "2026-02-05T11:18:59Z", "url": "https://www.cyber-checker.com/"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "AlexNicita"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["supabase", "production"], "value": "Staying fresh with the &quot;startup stack&quot;... so I made Vocaware.com: an AI voice agent that picks up the phone, talks naturally, takes notes, and connects to your workflows.<p>It\u2019s built with shadcn/ui + Next.js, Twilio for telephony, OpenAI for reasoning + speech, Stripe for payments, and <em>Supabase</em> + Railway for the backend. Basically a modern full-stack AI app \u2014 start to finish \u2014 that actually works in <em>production</em>.<p>Right now you can:<p>* Get a phone number instantly<p>* Have an AI answer calls 24/7<p>* Build agent conversation workflows<p>* View transcripts, summaries, and analytics in real time<p>I built it in a few weeks. It\u2019s live and works surprisingly well \u2014 but now I\u2019m trying to figure out what\u2019s next:<p>* Should I pick a vertical (e.g. real estate, service businesses, golf courses, ...)?<p>* Offer free trials?<p>* Make it open-source and developer-first?<p>* Go onsite with customers and implement it?<p>Would love any feedback, advice, or collaboration ideas from other builders.<p>\u2014 Alex (x.com/NicitaAlex)"}, "title": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["supabase"], "value": "Show HN: Vocaware \u2013 AI Voice Agents (Shadcn, Twilio, OpenAI, <em>Supabase</em>, Next.js)"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://vocaware.com"}}, "_tags": ["story", "author_AlexNicita", "story_45891135", "show_hn"], "author": "AlexNicita", "created_at": "2025-11-11T18:42:46Z", "created_at_i": 1762886566, "num_comments": 0, "objectID": "45891135", "points": 1, "story_id": 45891135, "story_text": "Staying fresh with the &quot;startup stack&quot;... so I made Vocaware.com: an AI voice agent that picks up the phone, talks naturally, takes notes, and connects to your workflows.<p>It\u2019s built with shadcn&#x2F;ui + Next.js, Twilio for telephony, OpenAI for reasoning + speech, Stripe for payments, and Supabase + Railway for the backend. Basically a modern full-stack AI app \u2014 start to finish \u2014 that actually works in production.<p>Right now you can:<p>* Get a phone number instantly<p>* Have an AI answer calls 24&#x2F;7<p>* Build agent conversation workflows<p>* View transcripts, summaries, and analytics in real time<p>I built it in a few weeks. It\u2019s live and works surprisingly well \u2014 but now I\u2019m trying to figure out what\u2019s next:<p>* Should I pick a vertical (e.g. real estate, service businesses, golf courses, ...)?<p>* Offer free trials?<p>* Make it open-source and developer-first?<p>* Go onsite with customers and implement it?<p>Would love any feedback, advice, or collaboration ideas from other builders.<p>\u2014 Alex (x.com&#x2F;NicitaAlex)", "title": "Show HN: Vocaware \u2013 AI Voice Agents (Shadcn, Twilio, OpenAI, Supabase, Next.js)", "updated_at": "2025-11-11T18:46:09Z", "url": "https://vocaware.com"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "paulmbw"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["supabase", "production"], "value": "Hey HN,<p>I spent way too much time building mobile apps from scratch, so I made LaunchToday (Expo boilerplate) to fix that. It\u2019s a <em>production</em>-ready starter kit that includes:<p>- Authentication (Magic links, OAuth, etc.)\n- Backend integration (Works with Firebase, <em>Supabase</em>, or your own API)\n- Payments (Stripe &amp; IAP)\n- Localization, monitoring, dark mode, and more<p>Since launching, startups have used it to cut weeks off development time. If you're a YC company building a mobile app, don\u2019t start from scratch\u2014focus on your product instead.<p>Would love to hear your thoughts! What\u2019s been your biggest pain point in mobile development?"}, "title": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["production"], "value": "Show HN: I made a <em>production</em>-ready expo boilerplate to launch mobile apps fast"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://launchtoday.dev/"}}, "_tags": ["story", "author_paulmbw", "story_43389413", "show_hn"], "author": "paulmbw", "created_at": "2025-03-17T15:11:48Z", "created_at_i": 1742224308, "num_comments": 0, "objectID": "43389413", "points": 1, "story_id": 43389413, "story_text": "Hey HN,<p>I spent way too much time building mobile apps from scratch, so I made LaunchToday (Expo boilerplate) to fix that. It\u2019s a production-ready starter kit that includes:<p>- Authentication (Magic links, OAuth, etc.)\n- Backend integration (Works with Firebase, Supabase, or your own API)\n- Payments (Stripe &amp; IAP)\n- Localization, monitoring, dark mode, and more<p>Since launching, startups have used it to cut weeks off development time. If you&#x27;re a YC company building a mobile app, don\u2019t start from scratch\u2014focus on your product instead.<p>Would love to hear your thoughts! What\u2019s been your biggest pain point in mobile development?", "title": "Show HN: I made a production-ready expo boilerplate to launch mobile apps fast", "updated_at": "2025-03-17T15:15:46Z", "url": "https://launchtoday.dev/"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "waleedlatif1"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["supabase", "production"], "value": "Hey HN, Waleed here. We're building Sim (<a href=\"https://sim.ai/\">https://sim.ai/</a>), an open-source visual editor to build agentic workflows. Repo here: <a href=\"https://github.com/simstudioai/sim/\" rel=\"nofollow\">https://github.com/simstudioai/sim/</a>. Docs here: <a href=\"https://docs.sim.ai\">https://docs.sim.ai</a>.<p>You can run Sim locally using Docker, with no execution limits or other restrictions.<p>We started building Sim almost a year ago after repeatedly troubleshooting why our agents failed in <em>production</em>. Code-first frameworks felt hard to debug because of implicit control flow, and workflow platforms added more overhead than they removed. We wanted granular control and easy observability without piecing everything together ourselves.<p>We launched Sim [1][2] as a drag-and-drop canvas around 6 months ago. Since then, we've added:<p>- 138 blocks: Slack, GitHub, Linear, Notion, <em>Supabase</em>, SSH, TTS, SFTP, MongoDB, S3, Pinecone, ...<p>- Tool calling with granular control: forced, auto<p>- Agent memory: conversation memory with sliding window support (by last n messages or tokens)<p>- Trace spans: detailed logging and observability for nested workflows and tool calling<p>- Native RAG: upload documents, we chunk, embed with pgvector, and expose vector search to agents<p>- Workflow deployment versioning with rollbacks<p>- MCP support, Human-in-the-loop block<p>- Copilot to build workflows using natural language (just shipped a new version that also acts as a superagent and can call into any of your connected services directly, not just build workflows)<p>Under the hood, the workflow is a DAG with concurrent execution by default. Nodes run as soon as their dependencies (upstream blocks) are satisfied. Loops (for, forEach, while, do-while) and parallel fan-out/join are also first-class primitives.<p>Agent blocks are pass-through to the provider. You pick your model (OpenAI, Anthropic, Gemini, Ollama, vLLM), and and we pass through prompts, tools, and response format directly to the provider API. We normalize response shapes for block interoperability, but we're not adding layers that obscure what's happening.<p>We're currently working on our own MCP server and the ability to deploy workflows as MCP servers. Would love to hear your thoughts and where we should take it next :)<p>[1] <a href=\"https://news.ycombinator.com/item?id=43823096\">https://news.ycombinator.com/item?id=43823096</a><p>[2] <a href=\"https://news.ycombinator.com/item?id=44052766\">https://news.ycombinator.com/item?id=44052766</a>"}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Show HN: Sim \u2013 Apache-2.0 n8n alternative"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://github.com/simstudioai/sim"}}, "_tags": ["story", "author_waleedlatif1", "story_46234186", "show_hn"], "author": "waleedlatif1", "children": [46235878, 46236104, 46236129, 46236422, 46237382, 46237417, 46238673, 46238813, 46239574, 46240560, 46241088, 46241089, 46241968, 46241970, 46244396, 46244712, 46245239, 46256736, 46321424], "created_at": "2025-12-11T17:20:11Z", "created_at_i": 1765473611, "num_comments": 61, "objectID": "46234186", "points": 240, "story_id": 46234186, "story_text": "Hey HN, Waleed here. We&#x27;re building Sim (<a href=\"https:&#x2F;&#x2F;sim.ai&#x2F;\">https:&#x2F;&#x2F;sim.ai&#x2F;</a>), an open-source visual editor to build agentic workflows. Repo here: <a href=\"https:&#x2F;&#x2F;github.com&#x2F;simstudioai&#x2F;sim&#x2F;\" rel=\"nofollow\">https:&#x2F;&#x2F;github.com&#x2F;simstudioai&#x2F;sim&#x2F;</a>. Docs here: <a href=\"https:&#x2F;&#x2F;docs.sim.ai\">https:&#x2F;&#x2F;docs.sim.ai</a>.<p>You can run Sim locally using Docker, with no execution limits or other restrictions.<p>We started building Sim almost a year ago after repeatedly troubleshooting why our agents failed in production. Code-first frameworks felt hard to debug because of implicit control flow, and workflow platforms added more overhead than they removed. We wanted granular control and easy observability without piecing everything together ourselves.<p>We launched Sim [1][2] as a drag-and-drop canvas around 6 months ago. Since then, we&#x27;ve added:<p>- 138 blocks: Slack, GitHub, Linear, Notion, Supabase, SSH, TTS, SFTP, MongoDB, S3, Pinecone, ...<p>- Tool calling with granular control: forced, auto<p>- Agent memory: conversation memory with sliding window support (by last n messages or tokens)<p>- Trace spans: detailed logging and observability for nested workflows and tool calling<p>- Native RAG: upload documents, we chunk, embed with pgvector, and expose vector search to agents<p>- Workflow deployment versioning with rollbacks<p>- MCP support, Human-in-the-loop block<p>- Copilot to build workflows using natural language (just shipped a new version that also acts as a superagent and can call into any of your connected services directly, not just build workflows)<p>Under the hood, the workflow is a DAG with concurrent execution by default. Nodes run as soon as their dependencies (upstream blocks) are satisfied. Loops (for, forEach, while, do-while) and parallel fan-out&#x2F;join are also first-class primitives.<p>Agent blocks are pass-through to the provider. You pick your model (OpenAI, Anthropic, Gemini, Ollama, vLLM), and and we pass through prompts, tools, and response format directly to the provider API. We normalize response shapes for block interoperability, but we&#x27;re not adding layers that obscure what&#x27;s happening.<p>We&#x27;re currently working on our own MCP server and the ability to deploy workflows as MCP servers. Would love to hear your thoughts and where we should take it next :)<p>[1] <a href=\"https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=43823096\">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=43823096</a><p>[2] <a href=\"https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=44052766\">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=44052766</a>", "title": "Show HN: Sim \u2013 Apache-2.0 n8n alternative", "updated_at": "2026-01-13T19:45:40Z", "url": "https://github.com/simstudioai/sim"}], "hitsPerPage": 15, "nbHits": 71, "nbPages": 5, "page": 0, "params": "query=supabase+production&tags=story&hitsPerPage=15&advancedSyntax=true&analyticsTags=backend", "processingTimeMS": 11, "processingTimingsMS": {"_request": {"roundTrip": 21}, "afterFetch": {"format": {"highlighting": 1, "total": 2}}, "fetch": {"query": 8, "scanning": 1, "total": 10}, "total": 11}, "query": "supabase production", "serverTimeMS": 14}}