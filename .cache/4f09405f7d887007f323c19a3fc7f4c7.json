{"d": "<!--\n  -- This file is auto-generated from README_js.md. Changes should be made there.\n  -->\n\n# uuid [![CI](https://github.com/uuidjs/uuid/workflows/CI/badge.svg)](https://github.com/uuidjs/uuid/actions?query=workflow%3ACI) [![Browser](https://github.com/uuidjs/uuid/workflows/Browser/badge.svg)](https://github.com/uuidjs/uuid/actions/workflows/browser.yml)\n\nFor the creation of [RFC9562](https://www.rfc-editor.org/rfc/rfc9562.html) (formerly [RFC4122](https://www.rfc-editor.org/rfc/rfc4122.html)) UUIDs\n\n- **Complete** - Support for all RFC9562 UUID versions\n- **Cross-platform** - Support for...\n  - [Typescript](#support)\n  - [Chrome, Safari, Firefox, and Edge](#support)\n  - [NodeJS](#support)\n  - [React Native / Expo](#react-native--expo)\n- **Secure** - Uses modern `crypto` API for random values\n- **Compact** - Zero-dependency, [tree-shakable](https://developer.mozilla.org/en-US/docs/Glossary/Tree_shaking)\n- **CLI** - [`uuid` command line](#command-line) utility\n\n<!-- prettier-ignore -->\n> [!NOTE]\n>\n> Starting with `uuid@12` CommonJS is no longer supported.  See [implications](https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c) and [motivation](https://github.com/uuidjs/uuid/issues/881) for details.\n\n## Quickstart\n\n**1. Install**\n\n```shell\nnpm install uuid\n```\n\n**2. Create a UUID**\n\n```javascript\nimport { v4 as uuidv4 } from 'uuid';\n\nuuidv4(); // \u21e8 '23c37ede-1c09-422a-8da8-42ad65cc33f9'\n```\n\nFor timestamp UUIDs, namespace UUIDs, and other options read on ...\n\n## API Summary\n\n|  |  |  |\n| --- | --- | --- |\n| [`uuid.NIL`](#uuidnil) | The nil UUID string (all zeros) | New in `uuid@8.3` |\n| [`uuid.MAX`](#uuidmax) | The max UUID string (all ones) | New in `uuid@9.1` |\n| [`uuid.parse()`](#uuidparsestr) | Convert UUID string to array of bytes | New in `uuid@8.3` |\n| [`uuid.stringify()`](#uuidstringifyarr-offset) | Convert array of bytes to UUID string | New in `uuid@8.3` |\n| [`uuid.v1()`](#uuidv1options-buffer-offset) | Create a version 1 (timestamp) UUID |  |\n| [`uuid.v1ToV6()`](#uuidv1tov6uuid) | Create a version 6 UUID from a version 1 UUID | New in `uuid@10` |\n| [`uuid.v3()`](#uuidv3name-namespace-buffer-offset) | Create a version 3 (namespace w/ MD5) UUID |  |\n| [`uuid.v4()`](#uuidv4options-buffer-offset) | Create a version 4 (random) UUID |  |\n| [`uuid.v5()`](#uuidv5name-namespace-buffer-offset) | Create a version 5 (namespace w/ SHA-1) UUID |  |\n| [`uuid.v6()`](#uuidv6options-buffer-offset) | Create a version 6 (timestamp, reordered) UUID | New in `uuid@10` |\n| [`uuid.v6ToV1()`](#uuidv6tov1uuid) | Create a version 1 UUID from a version 6 UUID | New in `uuid@10` |\n| [`uuid.v7()`](#uuidv7options-buffer-offset) | Create a version 7 (Unix Epoch time-based) UUID | New in `uuid@10` |\n| ~~[`uuid.v8()`](#uuidv8)~~ | \"Intentionally left blank\" |  |\n| [`uuid.validate()`](#uuidvalidatestr) | Test a string to see if it is a valid UUID | New in `uuid@8.3` |\n| [`uuid.version()`](#uuidversionstr) | Detect RFC version of a UUID | New in `uuid@8.3` |\n\n## API\n\n### uuid.NIL\n\nThe nil UUID string (all zeros).\n\nExample:\n\n```javascript\nimport { NIL as NIL_UUID } from 'uuid';\n\nNIL_UUID; // \u21e8 '00000000-0000-0000-0000-000000000000'\n```\n\n### uuid.MAX\n\nThe max UUID string (all ones).\n\nExample:\n\n```javascript\nimport { MAX as MAX_UUID } from 'uuid';\n\nMAX_UUID; // \u21e8 'ffffffff-ffff-ffff-ffff-ffffffffffff'\n```\n\n### uuid.parse(str)\n\nConvert UUID string to array of bytes\n\n|           |                                          |\n| --------- | ---------------------------------------- |\n| `str`     | A valid UUID `String`                    |\n| _returns_ | `Uint8Array[16]`                         |\n| _throws_  | `TypeError` if `str` is not a valid UUID |\n\n<!-- prettier-ignore -->\n> [!NOTE]\n> Ordering of values in the byte arrays used by `parse()` and `stringify()` follows the left &Rarr; right order of hex-pairs in UUID strings. As shown in the example below.\n\nExample:\n\n```javascript\nimport { parse as uuidParse } from 'uuid';\n\n// Parse a UUID\nuuidParse('6ec0bd7f-11c0-43da-975e-2a8ad9ebae0b'); // \u21e8\n// Uint8Array(16) [\n//   110, 192, 189, 127,  17,\n//   192,  67, 218, 151,  94,\n//    42, 138, 217, 235, 174,\n//    11\n// ]\n```\n\n### uuid.stringify(arr[, offset])\n\nConvert array of bytes to UUID string\n\n|                |                                                                              |\n| -------------- | ---------------------------------------------------------------------------- |\n| `arr`          | `Array`-like collection of 16 values (starting from `offset`) between 0-255. |\n| [`offset` = 0] | `Number` Starting index in the Array                                         |\n| _returns_      | `String`                                                                     |\n| _throws_       | `TypeError` if a valid UUID string cannot be generated                       |\n\n<!-- prettier-ignore -->\n> [!NOTE]\n> Ordering of values in the byte arrays used by `parse()` and `stringify()` follows the left &Rarr; right order of hex-pairs in UUID strings. As shown in the example below.\n\nExample:\n\n```javascript\nimport { stringify as uuidStringify } from 'uuid';\n\nconst uuidBytes = Uint8Array.of(\n  0x6e,\n  0xc0,\n  0xbd,\n  0x7f,\n  0x11,\n  0xc0,\n  0x43,\n  0xda,\n  0x97,\n  0x5e,\n  0x2a,\n  0x8a,\n  0xd9,\n  0xeb,\n  0xae,\n  0x0b\n);\n\nuuidStringify(uuidBytes); // \u21e8 '6ec0bd7f-11c0-43da-975e-2a8ad9ebae0b'\n```\n\n### uuid.v1([options[, buffer[, offset]]])\n\nCreate an RFC version 1 (timestamp) UUID\n\n|  |  |\n| --- | --- |\n| [`options`] | `Object` with one or more of the following properties: |\n| [`options.node = (random)` ] | RFC \"node\" field as an `Array[6]` of byte values (per 4.1.6) |\n| [`options.clockseq = (random)`] | RFC \"clock sequence\" as a `Number` between 0 - 0x3fff |\n| [`options.msecs = (current time)`] | RFC \"timestamp\" field (`Number` of milliseconds, unix epoch) |\n| [`options.nsecs = 0`] | RFC \"timestamp\" field (`Number` of nanoseconds to add to `msecs`, should be 0-10,000) |\n| [`options.random = (random)`] | `Array` of 16 random bytes (0-255) used to generate other fields, above |\n| [`options.rng`] | Alternative to `options.random`, a `Function` that returns an `Array` of 16 random bytes (0-255) |\n| [`buffer`] | `Uint8Array` or `Uint8Array` subtype (e.g. Node.js `Buffer`). If provided, binary UUID is written into the array, starting at `offset` |\n| [`offset` = 0] | `Number` Index to start writing UUID bytes in `buffer` |\n| _returns_ | UUID `String` if no `buffer` is specified, otherwise returns `buffer` |\n| _throws_ | `Error` if more than 10M UUIDs/sec are requested |\n\nExample:\n\n```javascript\nimport { v1 as uuidv1 } from 'uuid';\n\nuuidv1(); // \u21e8 'a2bfad10-b358-11f0-8d45-6389dd784317'\n```\n\nExample using `options`:\n\n```javascript\nimport { v1 as uuidv1 } from 'uuid';\n\nconst options = {\n  node: Uint8Array.of(0x01, 0x23, 0x45, 0x67, 0x89, 0xab),\n  clockseq: 0x1234,\n  msecs: new Date('2011-11-01').getTime(),\n  nsecs: 5678,\n};\nuuidv1(options); // \u21e8 '710b962e-041c-11e1-9234-0123456789ab'\n```\n\n### uuid.v1ToV6(uuid)\n\nConvert a UUID from version 1 to version 6\n\n```javascript\nimport { v1ToV6 } from 'uuid';\n\nv1ToV6('92f62d9e-22c4-11ef-97e9-325096b39f47'); // \u21e8 '1ef22c49-2f62-6d9e-97e9-325096b39f47'\n```\n\n### uuid.v3(name, namespace[, buffer[, offset]])\n\nCreate an RFC version 3 (namespace w/ MD5) UUID\n\nAPI is identical to `v5()`, but uses \"v3\" instead.\n\n<!-- prettier-ignore -->\n> [!IMPORTANT]\n> Per the RFC, \"_If backward compatibility is not an issue, SHA-1 [Version 5] is preferred_.\"\n\n### uuid.v4([options[, buffer[, offset]]])\n\nCreate an RFC version 4 (random) UUID\n\n|  |  |\n| --- | --- |\n| [`options`] | `Object` with one or more of the following properties: |\n| [`options.random`] | `Array` of 16 random bytes (0-255) |\n| [`options.rng`] | Alternative to `options.random`, a `Function` that returns an `Array` of 16 random bytes (0-255) |\n| [`buffer`] | `Uint8Array` or `Uint8Array` subtype (e.g. Node.js `Buffer`). If provided, binary UUID is written into the array, starting at `offset` |\n| [`offset` = 0] | `Number` Index to start writing UUID bytes in `buffer` |\n| _returns_ | UUID `String` if no `buffer` is specified, otherwise returns `buffer` |\n\nExample:\n\n```javascript\nimport { v4 as uuidv4 } from 'uuid';\n\nuuidv4(); // \u21e8 '177fac08-7fee-4a08-abda-72eb3ce87fba'\n```\n\nExample using predefined `random` values:\n\n```javascript\nimport { v4 as uuidv4 } from 'uuid';\n\nconst v4options = {\n  random: Uint8Array.of(\n    0x10,\n    0x91,\n    0x56,\n    0xbe,\n    0xc4,\n    0xfb,\n    0xc1,\n    0xea,\n    0x71,\n    0xb4,\n    0xef,\n    0xe1,\n    0x67,\n    0x1c,\n    0x58,\n    0x36\n  ),\n};\nuuidv4(v4options); // \u21e8 '109156be-c4fb-41ea-b1b4-efe1671c5836'\n```\n\n### uuid.v5(name, namespace[, buffer[, offset]])\n\nCreate an RFC version 5 (namespace w/ SHA-1) UUID\n\n|  |  |\n| --- | --- |\n| `name` | `String \\| Array` |\n| `namespace` | `String \\| Array[16]` Namespace UUID |\n| [`buffer`] | `Uint8Array` or `Uint8Array` subtype (e.g. Node.js `Buffer`). If provided, binary UUID is written into the array, starting at `offset` |\n| [`offset` = 0] | `Number` Index to start writing UUID bytes in `buffer` |\n| _returns_ | UUID `String` if no `buffer` is specified, otherwise returns `buffer` |\n\n<!-- prettier-ignore -->\n> [!NOTE]\n> The RFC `DNS` and `URL` namespaces are available as `v5.DNS` and `v5.URL`.\n\nExample with custom namespace:\n\n```javascript\nimport { v5 as uuidv5 } from 'uuid';\n\n// Define a custom namespace.  Readers, create your own using something like\n// https://www.uuidgenerator.net/\nconst MY_NAMESPACE = '1b671a64-40d5-491e-99b0-da01ff1f3341';\n\nuuidv5('Hello, World!', MY_NAMESPACE); // \u21e8 '630eb68f-e0fa-5ecc-887a-7c7a62614681'\n```\n\nExample with RFC `URL` namespace:\n\n```javascript\nimport { v5 as uuidv5 } from 'uuid';\n\nuuidv5('https://www.w3.org/', uuidv5.URL); // \u21e8 'c106a26a-21bb-5538-8bf2-57095d1976c1'\n```\n\n### uuid.v6([options[, buffer[, offset]]])\n\nCreate an RFC version 6 (timestamp, reordered) UUID\n\nThis method takes the same arguments as uuid.v1().\n\n```javascript\nimport { v6 as uuidv6 } from 'uuid';\n\nuuidv6(); // \u21e8 '1f0b358a-2c04-6950-8ac9-a8f01d2998d6'\n```\n\nExample using `options`:\n\n```javascript\nimport { v6 as uuidv6 } from 'uuid';\n\nconst options = {\n  node: [0x01, 0x23, 0x45, 0x67, 0x89, 0xab],\n  clockseq: 0x1234,\n  msecs: new Date('2011-11-01').getTime(),\n  nsecs: 5678,\n};\nuuidv6(options); // \u21e8 '1e1041c7-10b9-662e-9234-0123456789ab'\n```\n\n### uuid.v6ToV1(uuid)\n\nConvert a UUID from version 6 to version 1\n\n```javascript\nimport { v6ToV1 } from 'uuid';\n\nv6ToV1('1ef22c49-2f62-6d9e-97e9-325096b39f47'); // \u21e8 '92f62d9e-22c4-11ef-97e9-325096b39f47'\n```\n\n### uuid.v7([options[, buffer[, offset]]])\n\nCreate an RFC version 7 (random) UUID\n\n|  |  |\n| --- | --- |\n| [`options`] | `Object` with one or more of the following properties: |\n| [`options.msecs = (current time)`] | RFC \"timestamp\" field (`Number` of milliseconds, unix epoch) |\n| [`options.random = (random)`] | `Array` of 16 random bytes (0-255) used to generate other fields, above |\n| [`options.rng`] | Alternative to `options.random`, a `Function` that returns an `Array` of 16 random bytes (0-255) |\n| [`options.seq = (random)`] | 32-bit sequence `Number` between 0 - 0xffffffff. This may be provided to help ensure uniqueness for UUIDs generated within the same millisecond time interval. Default = random value. |\n| [`buffer`] | `Uint8Array` or `Uint8Array` subtype (e.g. Node.js `Buffer`). If provided, binary UUID is written into the array, starting at `offset` |\n| [`offset` = 0] | `Number` Index to start writing UUID bytes in `buffer` |\n| _returns_ | UUID `String` if no `buffer` is specified, otherwise returns `buffer` |\n\nExample:\n\n```javascript\nimport { v7 as uuidv7 } from 'uuid';\n\nuuidv7(); // \u21e8 '019a26ab-9a66-71a9-a89e-63c35fce4a5a'\n```\n\n### ~~uuid.v8()~~\n\n**_\"Intentionally left blank\"_**\n\n<!-- prettier-ignore -->\n> [!NOTE]\n> Version 8 (experimental) UUIDs are \"[for experimental or vendor-specific use cases](https://www.rfc-editor.org/rfc/rfc9562.html#name-uuid-version-8)\".  The RFC does not define a creation algorithm for them, which is why this package does not offer a `v8()` method.  The `validate()` and `version()` methods do work with such UUIDs, however.\n\n### uuid.validate(str)\n\nTest a string to see if it is a valid UUID\n\n|           |                                                     |\n| --------- | --------------------------------------------------- |\n| `str`     | `String` to validate                                |\n| _returns_ | `true` if string is a valid UUID, `false` otherwise |\n\nExample:\n\n```javascript\nimport { validate as uuidValidate } from 'uuid';\n\nuuidValidate('not a UUID'); // \u21e8 false\nuuidValidate('6ec0bd7f-11c0-43da-975e-2a8ad9ebae0b'); // \u21e8 true\n```\n\nUsing `validate` and `version` together it is possible to do per-version validation, e.g. validate for only v4 UUIds.\n\n```javascript\nimport { version as uuidVersion } from 'uuid';\nimport { validate as uuidValidate } from 'uuid';\n\nfunction uuidValidateV4(uuid) {\n  return uuidValidate(uuid) && uuidVersion(uuid) === 4;\n}\n\nconst v1Uuid = 'd9428888-122b-11e1-b85c-61cd3cbb3210';\nconst v4Uuid = '109156be-c4fb-41ea-b1b4-efe1671c5836';\n\nuuidValidateV4(v4Uuid); // \u21e8 true\nuuidValidateV4(v1Uuid); // \u21e8 false\n```\n\n### uuid.version(str)\n\nDetect RFC version of a UUID\n\n|           |                                          |\n| --------- | ---------------------------------------- |\n| `str`     | A valid UUID `String`                    |\n| _returns_ | `Number` The RFC version of the UUID     |\n| _throws_  | `TypeError` if `str` is not a valid UUID |\n\nExample:\n\n```javascript\nimport { version as uuidVersion } from 'uuid';\n\nuuidVersion('45637ec4-c85f-11ea-87d0-0242ac130003'); // \u21e8 1\nuuidVersion('6ec0bd7f-11c0-43da-975e-2a8ad9ebae0b'); // \u21e8 4\n```\n\n<!-- prettier-ignore -->\n> [!NOTE]\n> This method returns `0` for the `NIL` UUID, and `15` for the `MAX` UUID.\n\n## Command Line\n\nUUIDs can be generated from the command line using `uuid`.\n\n```shell\n$ npx uuid\nddeb27fb-d9a0-4624-be4d-4615062daed4\n```\n\nThe default is to generate version 4 UUIDS, however the other versions are supported. Type `uuid --help` for details:\n\n```shell\n$ npx uuid --help\n\nUsage:\n  uuid\n  uuid v1\n  uuid v3 <name> <namespace uuid>\n  uuid v4\n  uuid v5 <name> <namespace uuid>\n  uuid v7\n  uuid --help\n\nNote: <namespace uuid> may be \"URL\" or \"DNS\" to use the corresponding UUIDs\ndefined by RFC9562\n```\n\n## `options` Handling for Timestamp UUIDs\n\nPrior to `uuid@11`, it was possible for `options` state to interfere with the internal state used to ensure uniqueness of timestamp-based UUIDs (the `v1()`, `v6()`, and `v7()` methods). Starting with `uuid@11`, this issue has been addressed by using the presence of the `options` argument as a flag to select between two possible behaviors:\n\n- Without `options`: Internal state is utilized to improve UUID uniqueness.\n- With `options`: Internal state is **NOT** used and, instead, appropriate defaults are applied as needed.\n\n## Support\n\n**Browsers**: `uuid` [builds are tested](/uuidjs/uuid/blob/main/wdio.conf.js) against the latest version of desktop Chrome, Safari, Firefox, and Edge. Mobile versions of these same browsers are expected to work but aren't currently tested.\n\n**Node**: `uuid` [builds are tested](https://github.com/uuidjs/uuid/blob/main/.github/workflows/ci.yml#L26-L27) against node ([LTS releases](https://github.com/nodejs/Release)), plus one prior. E.g. At the time of this writing `node@20` is the \"maintenance\" release and `node@24` is the \"current\" release, so `uuid` supports `node@18`-`node@24`.\n\n**Typescript**: TS versions released within the past two years are supported. [source](https://github.com/microsoft/TypeScript/issues/49088#issuecomment-2468723715)\n\n## Known issues\n\n<!-- This header is referenced as an anchor in src/rng-browser.ts -->\n\n### \"getRandomValues() not supported\"\n\nThis error occurs in environments where the standard [`crypto.getRandomValues()`](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues) API is not supported. This issue can be resolved by adding an appropriate polyfill:\n\n#### React Native / Expo\n\n1. Install [`react-native-get-random-values`](https://github.com/LinusU/react-native-get-random-values#readme)\n1. Import it _before_ `uuid`. Since `uuid` might also appear as a transitive dependency of some other imports it's safest to just import `react-native-get-random-values` as the very first thing in your entry point:\n\n```javascript\nimport 'react-native-get-random-values';\nimport { v4 as uuidv4 } from 'uuid';\n```\n\n---\n\nMarkdown generated from [README_js.md](README_js.md) by <a href=\"https://github.com/broofa/runmd\"><image height=\"13\" src=\"https://camo.githubusercontent.com/5c7c603cd1e6a43370b0a5063d457e0dabb74cf317adc7baba183acb686ee8d0/687474703a2f2f692e696d6775722e636f6d2f634a4b6f3662552e706e67\" /></a>\n"}