{"d": {"exhaustive": {"nbHits": false, "typo": false}, "exhaustiveNbHits": false, "exhaustiveTypo": false, "hits": [{"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "nirtamir"}, "title": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["vite"], "value": "Real world <em>vite</em> with react and TypeScript"}, "url": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["vite", "production"], "value": "https://nirtamir.com/blog/<em>vite</em>-in-<em>production</em>"}}, "_tags": ["story", "author_nirtamir", "story_26584794"], "author": "nirtamir", "created_at": "2021-03-25T20:11:53Z", "created_at_i": 1616703113, "num_comments": 0, "objectID": "26584794", "points": 1, "story_id": 26584794, "title": "Real world vite with react and TypeScript", "updated_at": "2024-09-20T08:16:09Z", "url": "https://nirtamir.com/blog/vite-in-production"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "ricardodevelop"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["vite", "production"], "value": "Hello everyone,<p>I\u2019ve created this starter project for creating <em>production</em> ready web apps in <em>Vite</em> and React that I hope some might find useful.<p>This template came about as a necessity to provide some standardization across new projects at work. A few of the initial goals when creating this project were to:<p>- Reduce setup time<p>- Standardize codebase with ESLint and Prettier<p>- Improve commit messages with tools like husky, commitizen and commitlint<p>- Improve codebase maintainability and scalability by providing a reasonable folder structure<p>- Simplify React Component development through use of tools like Storybook<p>- Improving codebase stability with unit and E2E tests via Vitest + React Testing Library and Playwright respectively<p>- Ease the deployment process by providing a simple starter Dockerfile<p>In addition to all the aforementioned goals, I also wanted to use modern tools such as React Query + Zustand for state management, React Hook Form + Zod for creating and validating forms, Tailwind CSS for building out UI\u2019s, etc.<p>I tried to cover everything I, and others, might need but recognize that everyones requirements are different. Luckily, this isn\u2019t a framework so removing unneeded packages or adding new ones is as simple it would normally be. The project itself doesn\u2019t come with a demo as its purpose is to simply provide a foundation for any new projects you might have in mind.<p>Feedback is always welcome and I appreciate anyone willing to checkout this project.<p>Thank you and have a great day."}, "title": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["vite", "production"], "value": "Show HN: <em>Vite</em> React Boilerplate \u2013 A <em>Production</em> Ready, Scalable Starter Template"}, "url": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["vite"], "value": "https://github.com/RicardoValdovinos/<em>vite</em>-react-boilerplate"}}, "_tags": ["story", "author_ricardodevelop", "story_36926095", "show_hn"], "author": "ricardodevelop", "children": [36927690, 36928003], "created_at": "2023-07-29T23:49:15Z", "created_at_i": 1690674555, "num_comments": 5, "objectID": "36926095", "points": 18, "story_id": 36926095, "story_text": "Hello everyone,<p>I\u2019ve created this starter project for creating production ready web apps in Vite and React that I hope some might find useful.<p>This template came about as a necessity to provide some standardization across new projects at work. A few of the initial goals when creating this project were to:<p>- Reduce setup time<p>- Standardize codebase with ESLint and Prettier<p>- Improve commit messages with tools like husky, commitizen and commitlint<p>- Improve codebase maintainability and scalability by providing a reasonable folder structure<p>- Simplify React Component development through use of tools like Storybook<p>- Improving codebase stability with unit and E2E tests via Vitest + React Testing Library and Playwright respectively<p>- Ease the deployment process by providing a simple starter Dockerfile<p>In addition to all the aforementioned goals, I also wanted to use modern tools such as React Query + Zustand for state management, React Hook Form + Zod for creating and validating forms, Tailwind CSS for building out UI\u2019s, etc.<p>I tried to cover everything I, and others, might need but recognize that everyones requirements are different. Luckily, this isn\u2019t a framework so removing unneeded packages or adding new ones is as simple it would normally be. The project itself doesn\u2019t come with a demo as its purpose is to simply provide a foundation for any new projects you might have in mind.<p>Feedback is always welcome and I appreciate anyone willing to checkout this project.<p>Thank you and have a great day.", "title": "Show HN: Vite React Boilerplate \u2013 A Production Ready, Scalable Starter Template", "updated_at": "2024-09-20T14:45:12Z", "url": "https://github.com/RicardoValdovinos/vite-react-boilerplate"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "Croffasia"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["vite", "production"], "value": "The Problem We're Solving<p>Setting up a <em>production</em>-ready Vue.js project takes days. You need to configure TypeScript, set up build tools, choose the right state management, configure linting, add UI components, set up testing\u2014and then teach your AI coding assistant how to work with your specific stack and patterns.<p>By the time you're done with setup, you've lost momentum on your actual idea.<p>The pattern is predictable:<p>Day 1-2: Research and configure build tools, TypeScript, linting \nDay 3-4: Set up state management, routing, UI components\nDay 5-6: Configure development workflow, AI coding instructions \nDay 7+: Finally start building your actual application<p>Most developers either skip best practices to move fast, or spend weeks on setup instead of building.<p>Our Solution: <em>Production</em>-Ready Starter + AI Instructions<p>Vibe Code Kit eliminates the setup phase entirely. You get a battle-tested Vue.js stack that's been refined through dozens of <em>production</em> applications, plus AI development instructions that teach Claude Code how to work effectively with your specific setup.<p>Technology Stack:<p>- Vue 3 with Composition API and TypeScript support\n- <em>Vite</em> for lightning-fast development and optimized builds\n- Pinia for global state management + Pinia Colada for data fetching\n- Tailwind CSS + DaisyUI for rapid UI development\n- VueUse composables library for common patterns\n- ESLint, Prettier, Husky for code quality<p>Each technology includes AI coding best practices that prevent Claude Code from reinventing patterns.<p>How It Works<p>- Blueprint-Driven Development: Enhanced R&amp;D workflow commands guide Claude Code through proper project analysis and feature planning\n- Specialized AI Agents: Built-in agents for standards checking, code validation, and codebase research\n- Stack-Specific Instructions: AI learns the proper patterns for each library in your stack\n- <em>Production</em> Configuration: Everything pre-configured for deployment from day one\n- The result: Turn your ideas into <em>production</em> Vue.js apps in minutes, not days.<p>Real Impact\nSince using this approach:<p>- New Vue.js projects start with feature development, not configuration\n- Claude Code consistently follows Vue 3 Composition API best practices\n- AI agents catch architectural issues before they become problems\n- <em>Production</em> deployments work from day one<p>Technical Details<p>Built on Vue 3 ecosystem best practices. Includes comprehensive Claude Code integration with specialized agents for Vue.js development. Works with existing AI-assisted development workflows and supports rapid prototyping to <em>production</em> scaling.<p>Currently supporting Vue.js projects with plans for React and other frameworks.<p>Try It\nEarly access available at <a href=\"https://vibecodekit.dev\" rel=\"nofollow\">https://vibecodekit.dev</a><p>This isn't about replacing Vue CLI or <em>Vite</em>\u2014it's about getting a <em>production</em>-ready foundation with AI that actually understands your stack. Would love feedback from Vue.js developers who've struggled with project setup overhead.<p>Questions I'm curious about:<p>- How much time do you spend on initial Vue.js project configuration?\n- What's been your experience with AI coding assistants on Vue projects?\n- What would convince you to use a pre-configured starter over building from scratch?"}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Show HN: Vibe Code Kit code with confidence"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://vibecodekit.dev"}}, "_tags": ["story", "author_Croffasia", "story_45216336", "show_hn"], "author": "Croffasia", "children": [45235122], "created_at": "2025-09-11T21:34:46Z", "created_at_i": 1757626486, "num_comments": 1, "objectID": "45216336", "points": 3, "story_id": 45216336, "story_text": "The Problem We&#x27;re Solving<p>Setting up a production-ready Vue.js project takes days. You need to configure TypeScript, set up build tools, choose the right state management, configure linting, add UI components, set up testing\u2014and then teach your AI coding assistant how to work with your specific stack and patterns.<p>By the time you&#x27;re done with setup, you&#x27;ve lost momentum on your actual idea.<p>The pattern is predictable:<p>Day 1-2: Research and configure build tools, TypeScript, linting \nDay 3-4: Set up state management, routing, UI components\nDay 5-6: Configure development workflow, AI coding instructions \nDay 7+: Finally start building your actual application<p>Most developers either skip best practices to move fast, or spend weeks on setup instead of building.<p>Our Solution: Production-Ready Starter + AI Instructions<p>Vibe Code Kit eliminates the setup phase entirely. You get a battle-tested Vue.js stack that&#x27;s been refined through dozens of production applications, plus AI development instructions that teach Claude Code how to work effectively with your specific setup.<p>Technology Stack:<p>- Vue 3 with Composition API and TypeScript support\n- Vite for lightning-fast development and optimized builds\n- Pinia for global state management + Pinia Colada for data fetching\n- Tailwind CSS + DaisyUI for rapid UI development\n- VueUse composables library for common patterns\n- ESLint, Prettier, Husky for code quality<p>Each technology includes AI coding best practices that prevent Claude Code from reinventing patterns.<p>How It Works<p>- Blueprint-Driven Development: Enhanced R&amp;D workflow commands guide Claude Code through proper project analysis and feature planning\n- Specialized AI Agents: Built-in agents for standards checking, code validation, and codebase research\n- Stack-Specific Instructions: AI learns the proper patterns for each library in your stack\n- Production Configuration: Everything pre-configured for deployment from day one\n- The result: Turn your ideas into production Vue.js apps in minutes, not days.<p>Real Impact\nSince using this approach:<p>- New Vue.js projects start with feature development, not configuration\n- Claude Code consistently follows Vue 3 Composition API best practices\n- AI agents catch architectural issues before they become problems\n- Production deployments work from day one<p>Technical Details<p>Built on Vue 3 ecosystem best practices. Includes comprehensive Claude Code integration with specialized agents for Vue.js development. Works with existing AI-assisted development workflows and supports rapid prototyping to production scaling.<p>Currently supporting Vue.js projects with plans for React and other frameworks.<p>Try It\nEarly access available at <a href=\"https:&#x2F;&#x2F;vibecodekit.dev\" rel=\"nofollow\">https:&#x2F;&#x2F;vibecodekit.dev</a><p>This isn&#x27;t about replacing Vue CLI or Vite\u2014it&#x27;s about getting a production-ready foundation with AI that actually understands your stack. Would love feedback from Vue.js developers who&#x27;ve struggled with project setup overhead.<p>Questions I&#x27;m curious about:<p>- How much time do you spend on initial Vue.js project configuration?\n- What&#x27;s been your experience with AI coding assistants on Vue projects?\n- What would convince you to use a pre-configured starter over building from scratch?", "title": "Show HN: Vibe Code Kit code with confidence", "updated_at": "2025-10-06T15:47:47Z", "url": "https://vibecodekit.dev"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "mireklzicar"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["vite", "production"], "value": "I\u2019ve wrapped an open-source chemical structure editor in an a <em>production</em>-ready Docker image and React/<em>Vite</em> front-end so you can drop a full-featured molecule editor into any web app\u2014or run it standalone\u2014without touching a line of Java/Spring code.<p>GitHub: <a href=\"https://github.com/miroslav-lzicar/ketcher-docker\">https://github.com/miroslav-lzicar/ketcher-docker</a><p>Live demo (static hosting + iframe-friendly headers): <a href=\"https://ketcher.mireklzicar.com\" rel=\"nofollow\">https://ketcher.mireklzicar.com</a><p>Blog (iframe demo)\n<a href=\"https://mireklzicar.com/blog/ketcher-docker-deployment/\" rel=\"nofollow\">https://mireklzicar.com/blog/ketcher-docker-deployment/</a>"}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Show HN: Ketcher Docker \u2013 Self-Hosting Advanced Chemical Structure Editor"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://github.com/mireklzicar/ketcher-docker"}}, "_tags": ["story", "author_mireklzicar", "story_44414374", "show_hn"], "author": "mireklzicar", "created_at": "2025-06-29T16:37:01Z", "created_at_i": 1751215021, "num_comments": 0, "objectID": "44414374", "points": 3, "story_id": 44414374, "story_text": "I\u2019ve wrapped an open-source chemical structure editor in an a production-ready Docker image and React&#x2F;Vite front-end so you can drop a full-featured molecule editor into any web app\u2014or run it standalone\u2014without touching a line of Java&#x2F;Spring code.<p>GitHub: <a href=\"https:&#x2F;&#x2F;github.com&#x2F;miroslav-lzicar&#x2F;ketcher-docker\">https:&#x2F;&#x2F;github.com&#x2F;miroslav-lzicar&#x2F;ketcher-docker</a><p>Live demo (static hosting + iframe-friendly headers): <a href=\"https:&#x2F;&#x2F;ketcher.mireklzicar.com\" rel=\"nofollow\">https:&#x2F;&#x2F;ketcher.mireklzicar.com</a><p>Blog (iframe demo)\n<a href=\"https:&#x2F;&#x2F;mireklzicar.com&#x2F;blog&#x2F;ketcher-docker-deployment&#x2F;\" rel=\"nofollow\">https:&#x2F;&#x2F;mireklzicar.com&#x2F;blog&#x2F;ketcher-docker-deployment&#x2F;</a>", "title": "Show HN: Ketcher Docker \u2013 Self-Hosting Advanced Chemical Structure Editor", "updated_at": "2025-07-05T17:57:48Z", "url": "https://github.com/mireklzicar/ketcher-docker"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "aleclarsoniv"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["vite", "production"], "value": "Hey all, I'm the creator of @pg-nano/pg-parser. I'm using it in pg-nano[1] to statically analyze Postgres schemas spread across multiple SQL files for a couple of reasons:<p>1. Each CREATE statement needs to be in topological order, so pg-nano's dev command can execute them without issue.<p>2. pg-nano has a plugin system like <em>Vite</em> that allows SQL generation based on the parsed schema.<p>Probably to the surprise of no one, working with an untyped AST feels like you're back in the days of JavaScript, because well... you are. Most of you know by now just how great TypeScript and static types in general are, especially if you appreciate SQL.<p>So why is this project worth sharing with you?<p>Well, writing the AST type definitions by hand would have taken me way too much time. It would also be a bear to keep up-to-date as Postgres continues to evolve.<p>To my surprise, I discovered that libpg_query, the C library used under-the-hood, includes JSON definitions in their /srcdata/ folder. I figured I could use them to <i>generate</i> the type definitions. Genius, right? Okay... maybe not <i>genius</i>, but still cool, I think.<p>You see, those JSON definitions provided by libpg_query? They don't exactly contain the TypeScript definitions (was that obvious?). No, no. I had to <i>translate</i> them into TypeScript definitions. (I'm sure <i>you</i> could have done it, yes yes. But did you? No siree bob)<p>It was pain-staking, but overall really not too hard. Time-consuming? Yes, but not as much as writing the type definitions by hand. So... was it worth it? Only time will tell. I hope you find it as useful as I do. And that's all I've got, so thanks for reading.<p>P.S. The build for Windows is broken, so if anyone could lend a hand, you would be a true hero.<p>[1]: <a href=\"https://github.com/pg-nano/pg-nano\">https://github.com/pg-nano/pg-nano</a> (not ready for <em>production</em> use)"}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Show HN: Parse your Postgres queries into a fully-typed AST in TypeScript"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://github.com/pg-nano/pg-parser"}}, "_tags": ["story", "author_aleclarsoniv", "story_41576956", "show_hn"], "author": "aleclarsoniv", "children": [41582274, 41612650, 41613569, 41613768, 41614979, 41617540, 41618528, 41619472, 41619783, 41621946, 41628854], "created_at": "2024-09-18T07:49:34Z", "created_at_i": 1726645774, "num_comments": 21, "objectID": "41576956", "points": 116, "story_id": 41576956, "story_text": "Hey all, I&#x27;m the creator of @pg-nano&#x2F;pg-parser. I&#x27;m using it in pg-nano[1] to statically analyze Postgres schemas spread across multiple SQL files for a couple of reasons:<p>1. Each CREATE statement needs to be in topological order, so pg-nano&#x27;s dev command can execute them without issue.<p>2. pg-nano has a plugin system like Vite that allows SQL generation based on the parsed schema.<p>Probably to the surprise of no one, working with an untyped AST feels like you&#x27;re back in the days of JavaScript, because well... you are. Most of you know by now just how great TypeScript and static types in general are, especially if you appreciate SQL.<p>So why is this project worth sharing with you?<p>Well, writing the AST type definitions by hand would have taken me way too much time. It would also be a bear to keep up-to-date as Postgres continues to evolve.<p>To my surprise, I discovered that libpg_query, the C library used under-the-hood, includes JSON definitions in their &#x2F;srcdata&#x2F; folder. I figured I could use them to <i>generate</i> the type definitions. Genius, right? Okay... maybe not <i>genius</i>, but still cool, I think.<p>You see, those JSON definitions provided by libpg_query? They don&#x27;t exactly contain the TypeScript definitions (was that obvious?). No, no. I had to <i>translate</i> them into TypeScript definitions. (I&#x27;m sure <i>you</i> could have done it, yes yes. But did you? No siree bob)<p>It was pain-staking, but overall really not too hard. Time-consuming? Yes, but not as much as writing the type definitions by hand. So... was it worth it? Only time will tell. I hope you find it as useful as I do. And that&#x27;s all I&#x27;ve got, so thanks for reading.<p>P.S. The build for Windows is broken, so if anyone could lend a hand, you would be a true hero.<p>[1]: <a href=\"https:&#x2F;&#x2F;github.com&#x2F;pg-nano&#x2F;pg-nano\">https:&#x2F;&#x2F;github.com&#x2F;pg-nano&#x2F;pg-nano</a> (not ready for production use)", "title": "Show HN: Parse your Postgres queries into a fully-typed AST in TypeScript", "updated_at": "2025-07-10T23:20:38Z", "url": "https://github.com/pg-nano/pg-parser"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "artahian"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["vite", "production"], "value": "Hi all, Aram and Eduard here - authors of Modelence (<a href=\"https://github.com/modelence/modelence\" rel=\"nofollow\">https://github.com/modelence/modelence</a>), an all-in-one backend platform for teams that love TypeScript + MongoDB. Think Supabase, but for MongoDB: auth, cron jobs, email, monitoring, without glue code before you can ship.<p>As Karpathy (and many of us) noted, getting from prototype to <em>production</em> is mostly painful integration work. The pieces exist, but stitching them together reliably is the hard part: <a href=\"https://x.com/karpathy/status/1905051558783418370\" rel=\"nofollow\">https://x.com/karpathy/status/1905051558783418370</a>. YC AI Startup School talk about this - <a href=\"https://www.youtube.com/watch?feature=shared&amp;t=1940&amp;v=LCEmiRjPEtQ\" rel=\"nofollow\">https://www.youtube.com/watch?feature=shared&amp;t=1940&amp;v=LCEmiR...</a><p>We intend to fill those gaps! What you get out of the box:<p>- Authentication / user management<p>- Database<p>- Email integration (3rd party, but things like user verification emails work out of the box)<p>- AI integration<p>- Cron jobs<p>- Monitoring / Telemetry<p>- Configs &amp; secrets<p>- Analytics (coming soon)<p>- File uploads (coming soon)<p>How it runs: A Node.js backend with MongoDB. It's frontend-agnostic, so you can use our minimal <em>Vite</em> + React starter or drop Modelence behind an existing Next.js (or any) frontend.<p>We're also building a managed cloud, similar to what Vercel is for Next.js, except Modelence focuses on the backend instead of the frontend (Vercel is great for content sites like landing pages, blogs, etc, but things like persistent connections and complex backend logic outgrow it quickly). You can find a quick demo here: <a href=\"https://www.youtube.com/watch?v=S4f22FyPpI8\" rel=\"nofollow\">https://www.youtube.com/watch?v=S4f22FyPpI8</a><p>We're looking for early users (especially TS teams on MongoDB). Tell us what's missing, what's confusing, and what you'd want before trusting this in prod. Happy to answer anything!"}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Show HN: Modelence \u2013 Supabase for MongoDB"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://github.com/modelence/modelence"}}, "_tags": ["story", "author_artahian", "story_44902227", "show_hn"], "author": "artahian", "children": [44904242, 44904405, 44904579, 44905283, 44908113, 44908336], "created_at": "2025-08-14T16:13:29Z", "created_at_i": 1755188009, "num_comments": 14, "objectID": "44902227", "points": 38, "story_id": 44902227, "story_text": "Hi all, Aram and Eduard here - authors of Modelence (<a href=\"https:&#x2F;&#x2F;github.com&#x2F;modelence&#x2F;modelence\" rel=\"nofollow\">https:&#x2F;&#x2F;github.com&#x2F;modelence&#x2F;modelence</a>), an all-in-one backend platform for teams that love TypeScript + MongoDB. Think Supabase, but for MongoDB: auth, cron jobs, email, monitoring, without glue code before you can ship.<p>As Karpathy (and many of us) noted, getting from prototype to production is mostly painful integration work. The pieces exist, but stitching them together reliably is the hard part: <a href=\"https:&#x2F;&#x2F;x.com&#x2F;karpathy&#x2F;status&#x2F;1905051558783418370\" rel=\"nofollow\">https:&#x2F;&#x2F;x.com&#x2F;karpathy&#x2F;status&#x2F;1905051558783418370</a>. YC AI Startup School talk about this - <a href=\"https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?feature=shared&amp;t=1940&amp;v=LCEmiRjPEtQ\" rel=\"nofollow\">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?feature=shared&amp;t=1940&amp;v=LCEmiR...</a><p>We intend to fill those gaps! What you get out of the box:<p>- Authentication &#x2F; user management<p>- Database<p>- Email integration (3rd party, but things like user verification emails work out of the box)<p>- AI integration<p>- Cron jobs<p>- Monitoring &#x2F; Telemetry<p>- Configs &amp; secrets<p>- Analytics (coming soon)<p>- File uploads (coming soon)<p>How it runs: A Node.js backend with MongoDB. It&#x27;s frontend-agnostic, so you can use our minimal Vite + React starter or drop Modelence behind an existing Next.js (or any) frontend.<p>We&#x27;re also building a managed cloud, similar to what Vercel is for Next.js, except Modelence focuses on the backend instead of the frontend (Vercel is great for content sites like landing pages, blogs, etc, but things like persistent connections and complex backend logic outgrow it quickly). You can find a quick demo here: <a href=\"https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=S4f22FyPpI8\" rel=\"nofollow\">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=S4f22FyPpI8</a><p>We&#x27;re looking for early users (especially TS teams on MongoDB). Tell us what&#x27;s missing, what&#x27;s confusing, and what you&#x27;d want before trusting this in prod. Happy to answer anything!", "title": "Show HN: Modelence \u2013 Supabase for MongoDB", "updated_at": "2026-02-03T19:39:53Z", "url": "https://github.com/modelence/modelence"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "Eldodi"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["vite", "production"], "value": "Hi HN!<p>Two weeks ago at their Dev Days, OpenAI unveiled ChatGPT apps, interactive widgets that render inside ChatGPT using the Apps SDK and MCP. Building them using their template repository was surprisingly painful: every time you make a change on your React widget, you need to rerun the entire build pipeline to get fresh JS and CSS assets. The dev feedback loop was pretty terrible.<p>That\u2019s why I built a TypeScript starter that gets you up and running in under a minute. Clone, npm install, npm run dev, paste your ngrok URL into ChatGPT, and you're iterating on widgets with Hot Module Reload in the ChatGPT interface, just like building a regular web app. When you're ready to ship, the <em>production</em> build pipeline deploys instantly to Alpic or any other PaaS.<p>What's included:\n- <em>Vite</em> dev server with Hot Module Reload (HMR) piggy-backed on your MCP server Express server\n- Skybridge framework: an abstraction layer I built on top of OpenAI's skybridge runtime that maps MCP tool invocations to React widgets, eliminating manual iframe communication and component wiring.\n- <em>Production</em> build pipeline: one-click deploy to Alpic.ai (with bundling, hosting, auth, MCP-specific analytics included) or elsewhere\n- No lock-in: uses the official MCP SDK, works with OpenAI's examples<p>Quick start:<p>git clone <a href=\"https://github.com/alpic-ai/apps-sdk-template\" rel=\"nofollow\">https://github.com/alpic-ai/apps-sdk-template</a><p>cd apps-sdk-template<p>pnpm install &amp;&amp; pnpm run dev<p>ngrok http 3000<p># Add <a href=\"https://your-url.ngrok-free.app/mcp\" rel=\"nofollow\">https://your-url.ngrok-free.app/mcp</a> to <i>ChatGPT Settings</i> \u2192 <i>Connectors</i><p>Feedback welcome, especially if you hit rough edges or want specific features!<p>Starter Kit GitHub \u2192 <a href=\"https://github.com/alpic-ai/apps-sdk-template\" rel=\"nofollow\">https://github.com/alpic-ai/apps-sdk-template</a><p>Skybridge Github \u2192 <a href=\"https://github.com/alpic-ai/skybridge\" rel=\"nofollow\">https://github.com/alpic-ai/skybridge</a>"}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Show HN: OpenAI ChatGPT App starter DevXP feels like 2010, I built a better one"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://github.com/alpic-ai/apps-sdk-template"}}, "_tags": ["story", "author_Eldodi", "story_45684003", "show_hn"], "author": "Eldodi", "children": [45684158, 45684243], "created_at": "2025-10-23T16:44:18Z", "created_at_i": 1761237858, "num_comments": 2, "objectID": "45684003", "points": 19, "story_id": 45684003, "story_text": "Hi HN!<p>Two weeks ago at their Dev Days, OpenAI unveiled ChatGPT apps, interactive widgets that render inside ChatGPT using the Apps SDK and MCP. Building them using their template repository was surprisingly painful: every time you make a change on your React widget, you need to rerun the entire build pipeline to get fresh JS and CSS assets. The dev feedback loop was pretty terrible.<p>That\u2019s why I built a TypeScript starter that gets you up and running in under a minute. Clone, npm install, npm run dev, paste your ngrok URL into ChatGPT, and you&#x27;re iterating on widgets with Hot Module Reload in the ChatGPT interface, just like building a regular web app. When you&#x27;re ready to ship, the production build pipeline deploys instantly to Alpic or any other PaaS.<p>What&#x27;s included:\n- Vite dev server with Hot Module Reload (HMR) piggy-backed on your MCP server Express server\n- Skybridge framework: an abstraction layer I built on top of OpenAI&#x27;s skybridge runtime that maps MCP tool invocations to React widgets, eliminating manual iframe communication and component wiring.\n- Production build pipeline: one-click deploy to Alpic.ai (with bundling, hosting, auth, MCP-specific analytics included) or elsewhere\n- No lock-in: uses the official MCP SDK, works with OpenAI&#x27;s examples<p>Quick start:<p>git clone <a href=\"https:&#x2F;&#x2F;github.com&#x2F;alpic-ai&#x2F;apps-sdk-template\" rel=\"nofollow\">https:&#x2F;&#x2F;github.com&#x2F;alpic-ai&#x2F;apps-sdk-template</a><p>cd apps-sdk-template<p>pnpm install &amp;&amp; pnpm run dev<p>ngrok http 3000<p># Add <a href=\"https:&#x2F;&#x2F;your-url.ngrok-free.app&#x2F;mcp\" rel=\"nofollow\">https:&#x2F;&#x2F;your-url.ngrok-free.app&#x2F;mcp</a> to <i>ChatGPT Settings</i> \u2192 <i>Connectors</i><p>Feedback welcome, especially if you hit rough edges or want specific features!<p>Starter Kit GitHub \u2192 <a href=\"https:&#x2F;&#x2F;github.com&#x2F;alpic-ai&#x2F;apps-sdk-template\" rel=\"nofollow\">https:&#x2F;&#x2F;github.com&#x2F;alpic-ai&#x2F;apps-sdk-template</a><p>Skybridge Github \u2192 <a href=\"https:&#x2F;&#x2F;github.com&#x2F;alpic-ai&#x2F;skybridge\" rel=\"nofollow\">https:&#x2F;&#x2F;github.com&#x2F;alpic-ai&#x2F;skybridge</a>", "title": "Show HN: OpenAI ChatGPT App starter DevXP feels like 2010, I built a better one", "updated_at": "2025-10-24T15:54:06Z", "url": "https://github.com/alpic-ai/apps-sdk-template"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "collegeburner"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["vite", "production"], "value": "More accurate to ask &quot;How do I evaluate web tools&quot;? Like frameworks aside, I want to build a webapp for <em>production</em> and write it all. Now I have to build it. Do I use webpack, esbuild, rollup, parcel, snowpack, <em>vite</em>? How tf am I supposed to compare these?!<p>Sorry this is kinda vent-y but any recommendation on how to evaluate different stuff like this? I'm kinda new to web and have been frustrated by too much different tools in a way I never was on backend stuff. Thanks."}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Ask HN: How the $ ^ do I learn web?"}}, "_tags": ["story", "author_collegeburner", "story_29834707", "ask_hn"], "author": "collegeburner", "children": [29834754, 29834870, 29834889, 29835157, 29835261, 29835754, 29835931, 29836534], "created_at": "2022-01-07T04:08:34Z", "created_at_i": 1641528514, "num_comments": 9, "objectID": "29834707", "points": 10, "story_id": 29834707, "story_text": "More accurate to ask &quot;How do I evaluate web tools&quot;? Like frameworks aside, I want to build a webapp for production and write it all. Now I have to build it. Do I use webpack, esbuild, rollup, parcel, snowpack, vite? How tf am I supposed to compare these?!<p>Sorry this is kinda vent-y but any recommendation on how to evaluate different stuff like this? I&#x27;m kinda new to web and have been frustrated by too much different tools in a way I never was on backend stuff. Thanks.", "title": "Ask HN: How the $ ^ do I learn web?", "updated_at": "2024-09-20T10:12:05Z"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "pranav9"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["vite", "production"], "value": "Hey HN,<p>I've been building Aether, a background agent that takes <em>production</em> errors from Sentry and attempts to turn them into verified pull requests.<p>When a new error hits your Sentry project:<p>1. Sentry webhook fires with the stack trace, breadcrumbs, and context\n2. Aether spins up an isolated Fly.io VM and clones the repo at the relevant commit\n3. Agent analyzes the stack trace, reproduces the issue, proposes a fix\n4. Starts the dev server, re-runs tests, and can verify the running app with Playwright (headless Chromium is pre-installed in every VM)\n5. A review pass evaluates the diff before a PR is opened\n6. Pushes to a feature branch and opens a GitHub PR, but only if verification succeeds\n7. If CI fails, it retries once with the failure logs. If it fails again, the task is marked failed. No infinite loops.<p>Why full VMs instead of worktrees? Each task runs in its own isolated machine with a real filesystem, real process model, real network stack. It can `npm install`, run a dev server on port 3000, and Playwright can hit `localhost:3000` because it's an actual environment, not a sandbox. Since each task is its own VM, preview URLs are exposed per task via a gateway proxy so you can inspect the running app while the agent works. VMs shut down shortly after the task completes.<p>There's a simple multi-agent setup: a solver proposes the fix, a review agent evaluates the diff, and the fix has to survive re-execution in a clean isolated environment before a PR gets opened. Not claiming formal guarantees here, just requiring the fix to actually execute successfully in a reproducible environment before it touches your repo.<p>Limitations:<p>- Works best on well-tested codebases where &quot;reproduce and verify&quot; is meaningful\n- If reproduction isn't deterministic, results degrade\n- CI retry is capped at one automatic attempt\n- Code review is model-driven, not an architectural enforcement layer\n- BYOK only, you bring your own API key via OpenRouter. No markup on model costs but it's not super cheap to run\n- Sentry integration is built but waiting on approval from Sentry, coming soon\n- CLI is also coming soon<p>Bug fixing is the main focus but it's built on top of a general-purpose background agents system that works today. The agent is still great at general coding tasks. You can give the agent tasks from a full web IDE with a code editor, terminal, file tree, and agent chat panel. CLI is coming soon too (`aether run &quot;add auth to the API&quot;`). Each task gets its own isolated VM with shareable preview URLs so you can hand someone a link to see exactly what the agent built. Similar to Cursor background agents but running in the cloud with full environment isolation instead of local worktrees.<p>Stack: Go API (Chi), Fly.io VMs, React 19 + <em>Vite</em> frontend, Bun workspace service inside each VM, Supabase for auth/db/realtime, Playwright + Chromium preinstalled on each VM.<p>Self-serve right now: GitHub OAuth, connect a repo, and go via the web IDE. Sentry and CLI coming soon.<p>Would value feedback from engineers who deal with <em>production</em> debugging regularly, or frequently use background agents. Where would this break, and what would make you trust it?<p>Landing page: <a href=\"https://www.runaether.dev\" rel=\"nofollow\">https://www.runaether.dev</a>\nTry it: <a href=\"https://app.runaether.dev\" rel=\"nofollow\">https://app.runaether.dev</a>"}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Show HN: Aether \u2013 Background agents that fix bugs in isolated VMs, opens PRs"}}, "_tags": ["story", "author_pranav9", "story_47081472", "show_hn"], "author": "pranav9", "children": [47081704, 47082242, 47082789, 47084861, 47094474], "created_at": "2026-02-19T23:43:54Z", "created_at_i": 1771544634, "num_comments": 6, "objectID": "47081472", "points": 8, "story_id": 47081472, "story_text": "Hey HN,<p>I&#x27;ve been building Aether, a background agent that takes production errors from Sentry and attempts to turn them into verified pull requests.<p>When a new error hits your Sentry project:<p>1. Sentry webhook fires with the stack trace, breadcrumbs, and context\n2. Aether spins up an isolated Fly.io VM and clones the repo at the relevant commit\n3. Agent analyzes the stack trace, reproduces the issue, proposes a fix\n4. Starts the dev server, re-runs tests, and can verify the running app with Playwright (headless Chromium is pre-installed in every VM)\n5. A review pass evaluates the diff before a PR is opened\n6. Pushes to a feature branch and opens a GitHub PR, but only if verification succeeds\n7. If CI fails, it retries once with the failure logs. If it fails again, the task is marked failed. No infinite loops.<p>Why full VMs instead of worktrees? Each task runs in its own isolated machine with a real filesystem, real process model, real network stack. It can `npm install`, run a dev server on port 3000, and Playwright can hit `localhost:3000` because it&#x27;s an actual environment, not a sandbox. Since each task is its own VM, preview URLs are exposed per task via a gateway proxy so you can inspect the running app while the agent works. VMs shut down shortly after the task completes.<p>There&#x27;s a simple multi-agent setup: a solver proposes the fix, a review agent evaluates the diff, and the fix has to survive re-execution in a clean isolated environment before a PR gets opened. Not claiming formal guarantees here, just requiring the fix to actually execute successfully in a reproducible environment before it touches your repo.<p>Limitations:<p>- Works best on well-tested codebases where &quot;reproduce and verify&quot; is meaningful\n- If reproduction isn&#x27;t deterministic, results degrade\n- CI retry is capped at one automatic attempt\n- Code review is model-driven, not an architectural enforcement layer\n- BYOK only, you bring your own API key via OpenRouter. No markup on model costs but it&#x27;s not super cheap to run\n- Sentry integration is built but waiting on approval from Sentry, coming soon\n- CLI is also coming soon<p>Bug fixing is the main focus but it&#x27;s built on top of a general-purpose background agents system that works today. The agent is still great at general coding tasks. You can give the agent tasks from a full web IDE with a code editor, terminal, file tree, and agent chat panel. CLI is coming soon too (`aether run &quot;add auth to the API&quot;`). Each task gets its own isolated VM with shareable preview URLs so you can hand someone a link to see exactly what the agent built. Similar to Cursor background agents but running in the cloud with full environment isolation instead of local worktrees.<p>Stack: Go API (Chi), Fly.io VMs, React 19 + Vite frontend, Bun workspace service inside each VM, Supabase for auth&#x2F;db&#x2F;realtime, Playwright + Chromium preinstalled on each VM.<p>Self-serve right now: GitHub OAuth, connect a repo, and go via the web IDE. Sentry and CLI coming soon.<p>Would value feedback from engineers who deal with production debugging regularly, or frequently use background agents. Where would this break, and what would make you trust it?<p>Landing page: <a href=\"https:&#x2F;&#x2F;www.runaether.dev\" rel=\"nofollow\">https:&#x2F;&#x2F;www.runaether.dev</a>\nTry it: <a href=\"https:&#x2F;&#x2F;app.runaether.dev\" rel=\"nofollow\">https:&#x2F;&#x2F;app.runaether.dev</a>", "title": "Show HN: Aether \u2013 Background agents that fix bugs in isolated VMs, opens PRs", "updated_at": "2026-02-21T21:50:06Z"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "marlusx"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["vite", "production"], "value": "After 20+ years in consulting you are entitled to build your own deployment platform, right. So that's what we did. We needed something powerful, supporting all stages from development to <em>production</em>, where new developers can be productive in minutes. Something fun to prototype with, with minimal DevOps but still flexible enough for a wide range of projects.<p>We identified three principles<p>1. Own your stack - Keep as much of your project inside the platform (also databases, S3) so development will match <em>production</em> and cloning and maintaining and testing, will be easy<p>2. Infrastructure as code - Keep all code in one place, use a monorepo where possible<p>3. Remote Development - Developers install nothing, but can still use their favourite IDEs (VSCode, Cursor etc.), vibe coders are welcome also (We can import and run lovable projects <a href=\"https://diploi.com/lovable\" rel=\"nofollow\">https://diploi.com/lovable</a>)<p>We're still just getting started but Diploi is already useful and has support for a lot of tech stacks. Since internally based on Kubernetes we will eventually be able to run anything that runs on kubernetes.<p>Please try out if interested: <a href=\"https://diploi.com/#StackBuilder\" rel=\"nofollow\">https://diploi.com/#StackBuilder</a><p>You can try it out in a few clicks even without registering, for example just select: Supabase for db, Redis for caching, Bun for backend and React + <em>Vite</em> for frontend and you will be ready to start developing on that setup."}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Show HN: Diploi \u2013 Full Software-Lifecycle development platform"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://diploi.com/"}}, "_tags": ["story", "author_marlusx", "story_45604690", "show_hn"], "author": "marlusx", "created_at": "2025-10-16T12:48:48Z", "created_at_i": 1760618928, "num_comments": 0, "objectID": "45604690", "points": 4, "story_id": 45604690, "story_text": "After 20+ years in consulting you are entitled to build your own deployment platform, right. So that&#x27;s what we did. We needed something powerful, supporting all stages from development to production, where new developers can be productive in minutes. Something fun to prototype with, with minimal DevOps but still flexible enough for a wide range of projects.<p>We identified three principles<p>1. Own your stack - Keep as much of your project inside the platform (also databases, S3) so development will match production and cloning and maintaining and testing, will be easy<p>2. Infrastructure as code - Keep all code in one place, use a monorepo where possible<p>3. Remote Development - Developers install nothing, but can still use their favourite IDEs (VSCode, Cursor etc.), vibe coders are welcome also (We can import and run lovable projects <a href=\"https:&#x2F;&#x2F;diploi.com&#x2F;lovable\" rel=\"nofollow\">https:&#x2F;&#x2F;diploi.com&#x2F;lovable</a>)<p>We&#x27;re still just getting started but Diploi is already useful and has support for a lot of tech stacks. Since internally based on Kubernetes we will eventually be able to run anything that runs on kubernetes.<p>Please try out if interested: <a href=\"https:&#x2F;&#x2F;diploi.com&#x2F;#StackBuilder\" rel=\"nofollow\">https:&#x2F;&#x2F;diploi.com&#x2F;#StackBuilder</a><p>You can try it out in a few clicks even without registering, for example just select: Supabase for db, Redis for caching, Bun for backend and React + Vite for frontend and you will be ready to start developing on that setup.", "title": "Show HN: Diploi \u2013 Full Software-Lifecycle development platform", "updated_at": "2025-10-16T13:02:21Z", "url": "https://diploi.com/"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "cyco130"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["vite", "production"], "value": "Pleased to announce version 0.2.1 of , \u201cthe dancing web framework\u201d which aims to unite a Next.js-inspired development experience with <em>Vite</em>'s blazing speed. Please check it out, all kinds of feedback are most welcome. It's not <em>production</em>-ready yet but many features have been implemented:<p>- Hassle-free server-side rendering\n- File system-based routing with dynamic routes, nested layouts, and thematic layout groups\n- SPA-style client-side router\n- Simple but effective data fetching system\n- API routes to build API endpoints and middleware<p>This new version brings:<p>- Project initializer (`npm init rakkas-app`)\n- Hot reloading for pages and layouts\n- More robust body parser which now supports `application/x-www-form-urlencoded` in addition to plain text and JSON\n- New website domain: rakkasjs.org\n- Bug fixes\n- Performance and package size improvements<p>And short term goals incude:<p>- Static site generation\n- Optional data caching\n- Support for serverless environments\n- Localizable and customizable router<p>Check the github page for more info: https://github.com/rakkasjs/rakkasjs"}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Rakkas: The Dancing Web Frameork"}}, "_tags": ["story", "author_cyco130", "story_27797669", "ask_hn"], "author": "cyco130", "children": [27797744], "created_at": "2021-07-11T00:58:32Z", "created_at_i": 1625965112, "num_comments": 1, "objectID": "27797669", "points": 3, "story_id": 27797669, "story_text": "Pleased to announce version 0.2.1 of , \u201cthe dancing web framework\u201d which aims to unite a Next.js-inspired development experience with Vite&#x27;s blazing speed. Please check it out, all kinds of feedback are most welcome. It&#x27;s not production-ready yet but many features have been implemented:<p>- Hassle-free server-side rendering\n- File system-based routing with dynamic routes, nested layouts, and thematic layout groups\n- SPA-style client-side router\n- Simple but effective data fetching system\n- API routes to build API endpoints and middleware<p>This new version brings:<p>- Project initializer (`npm init rakkas-app`)\n- Hot reloading for pages and layouts\n- More robust body parser which now supports `application&#x2F;x-www-form-urlencoded` in addition to plain text and JSON\n- New website domain: rakkasjs.org\n- Bug fixes\n- Performance and package size improvements<p>And short term goals incude:<p>- Static site generation\n- Optional data caching\n- Support for serverless environments\n- Localizable and customizable router<p>Check the github page for more info: https:&#x2F;&#x2F;github.com&#x2F;rakkasjs&#x2F;rakkasjs", "title": "Rakkas: The Dancing Web Frameork", "updated_at": "2024-09-20T08:59:31Z"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "oddurs"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["vite", "production"], "value": "A photorealistic Moon viewer running entirely in the browser. WebGPU primary renderer with WebGL 2 fallback.<p>- NASA CGI Moon Kit textures served via a quadtree LOD tile system\n- Oren-Nayar BRDF (lunar regolith is non-Lambertian with strong backscatter)\n- Sun position calculated from astronomy-engine (\u00b11 arcminute)\n- Scrub through the full lunation cycle or watch in real time\n- Earth and Tycho-2 starfield in the background<p>Tech: Three.js with TSL shaders (compile to both WGSL and GLSL), React Three Fiber, <em>Vite</em>. The shading model was the most interesting part \u2014 standard PBR looks completely wrong for the Moon because regolith doesn't have a specular lobe; it actually gets brighter at opposition (the &quot;opposition surge&quot;). Oren-Nayar gets close enough for a web visualization.<p>Tile system is a geodetic quadtree similar to CesiumJS's approach. Zoom level picks based on screen-space error. Currently 7 levels deep which gets you to ~4 km/pixel at max zoom.<p>Would love feedback, especially from anyone who's worked with lunar data or WebGPU in <em>production</em>."}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Show HN: Interactive 3D Moon with real NASA data and WebGPU"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://moon.oddurs.com"}}, "_tags": ["story", "author_oddurs", "story_47141789", "show_hn"], "author": "oddurs", "created_at": "2026-02-24T19:43:01Z", "created_at_i": 1771962181, "num_comments": 0, "objectID": "47141789", "points": 3, "story_id": 47141789, "story_text": "A photorealistic Moon viewer running entirely in the browser. WebGPU primary renderer with WebGL 2 fallback.<p>- NASA CGI Moon Kit textures served via a quadtree LOD tile system\n- Oren-Nayar BRDF (lunar regolith is non-Lambertian with strong backscatter)\n- Sun position calculated from astronomy-engine (\u00b11 arcminute)\n- Scrub through the full lunation cycle or watch in real time\n- Earth and Tycho-2 starfield in the background<p>Tech: Three.js with TSL shaders (compile to both WGSL and GLSL), React Three Fiber, Vite. The shading model was the most interesting part \u2014 standard PBR looks completely wrong for the Moon because regolith doesn&#x27;t have a specular lobe; it actually gets brighter at opposition (the &quot;opposition surge&quot;). Oren-Nayar gets close enough for a web visualization.<p>Tile system is a geodetic quadtree similar to CesiumJS&#x27;s approach. Zoom level picks based on screen-space error. Currently 7 levels deep which gets you to ~4 km&#x2F;pixel at max zoom.<p>Would love feedback, especially from anyone who&#x27;s worked with lunar data or WebGPU in production.", "title": "Show HN: Interactive 3D Moon with real NASA data and WebGPU", "updated_at": "2026-02-24T22:04:28Z", "url": "https://moon.oddurs.com"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "carrerajs"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["vite", "production"], "value": "I believe in the React Server Component development and excited about the server actions and Form Events implementation in the experimental react version.<p>While they are projecting the a future to React that many in the community doesn't believe in, but that is something we have to wait and watch until a stable version of React is released.<p>What about the present day? Those projects that are still Client Side Only and doesn't need those fancy SSR, RSC concepts or the framework that promotes them. I work on such projects in my organization and I primarily try to work on Tech Debt areas like Upgrading the packages and Migrating it from one tech to another.<p>In the last four years, I have migrated NextJS 9 project with Redux+Saga to React+Apollo with Webpack, Webpack project to Module Federation and even Webpack to <em>Vite</em>.<p>Those were not challenging at all, the only challenge was to leading a large team to execute the migration plan one after the other.<p>But in the past 3 months, I have faced with alot of challenge when i moved to a team that started working from last 6 months. The challenge is that, most of the dependencies used are either dead or not maintained for almost 1 year now.<p>The packages like `redux-first-history` has core dependencies on React Router exposing History API and therefore, they are not able to progress. But, what about other packages that don't have those challenges? they too are unmaintained.<p>Excluding the framework officially listed in the react.dev site, the only option that a React dev has to work on a complete Client side app is to use <em>Vite</em> bundler which is recognized in the react.dev site as well. <em>Vite</em> is supported by all major frameworks and is the best tool available for both Development &amp; <em>Production</em> Release and Migrating to it is very easy to achieve if you don't work with Redux.<p>When you try to migrate a Redux app, the first challenge you face is the `504 outdated dependency` and as per my understanding is caused by the packages that have dependency on older version of react or other major library that would result in multiple version of them available in node_modules. Maybe my understanding is wrong or there could be some other issue that i am aware of.<p>But, what i wanted to know from the community is? why not migrate those package to latest versions and may be <em>Vite</em> to make maintaining it simple for everyone.<p>I have migrated 2 repos to <em>Vite</em> and React 18\n1. https://github.com/founding-partner/redux-oidc\n2. https://github.com/founding-partner/redux-oidc-example<p>I don't have a clarity on the OIDC implementation, so I didn't touch the src folder but validated whether everything is working as-is like the previous architecture and they do.<p>If the Redux Community can migrate these dead &amp; unmaintained projects to <em>Vite</em> and React 18, it will benefit everyone for the long run. Especially, when <em>Vite</em> is the only option to work on for Client only application.<p>What do you think?<p>Regards,\nCJS<p>Note: my first post here, pls forgive if i am not following the guidelines."}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Is the React Redux Community Active?"}}, "_tags": ["story", "author_carrerajs", "story_37838834", "ask_hn"], "author": "carrerajs", "children": [37839896], "created_at": "2023-10-10T22:55:58Z", "created_at_i": 1696978558, "num_comments": 1, "objectID": "37838834", "points": 2, "story_id": 37838834, "story_text": "I believe in the React Server Component development and excited about the server actions and Form Events implementation in the experimental react version.<p>While they are projecting the a future to React that many in the community doesn&#x27;t believe in, but that is something we have to wait and watch until a stable version of React is released.<p>What about the present day? Those projects that are still Client Side Only and doesn&#x27;t need those fancy SSR, RSC concepts or the framework that promotes them. I work on such projects in my organization and I primarily try to work on Tech Debt areas like Upgrading the packages and Migrating it from one tech to another.<p>In the last four years, I have migrated NextJS 9 project with Redux+Saga to React+Apollo with Webpack, Webpack project to Module Federation and even Webpack to Vite.<p>Those were not challenging at all, the only challenge was to leading a large team to execute the migration plan one after the other.<p>But in the past 3 months, I have faced with alot of challenge when i moved to a team that started working from last 6 months. The challenge is that, most of the dependencies used are either dead or not maintained for almost 1 year now.<p>The packages like `redux-first-history` has core dependencies on React Router exposing History API and therefore, they are not able to progress. But, what about other packages that don&#x27;t have those challenges? they too are unmaintained.<p>Excluding the framework officially listed in the react.dev site, the only option that a React dev has to work on a complete Client side app is to use Vite bundler which is recognized in the react.dev site as well. Vite is supported by all major frameworks and is the best tool available for both Development &amp; Production Release and Migrating to it is very easy to achieve if you don&#x27;t work with Redux.<p>When you try to migrate a Redux app, the first challenge you face is the `504 outdated dependency` and as per my understanding is caused by the packages that have dependency on older version of react or other major library that would result in multiple version of them available in node_modules. Maybe my understanding is wrong or there could be some other issue that i am aware of.<p>But, what i wanted to know from the community is? why not migrate those package to latest versions and may be Vite to make maintaining it simple for everyone.<p>I have migrated 2 repos to Vite and React 18\n1. https:&#x2F;&#x2F;github.com&#x2F;founding-partner&#x2F;redux-oidc\n2. https:&#x2F;&#x2F;github.com&#x2F;founding-partner&#x2F;redux-oidc-example<p>I don&#x27;t have a clarity on the OIDC implementation, so I didn&#x27;t touch the src folder but validated whether everything is working as-is like the previous architecture and they do.<p>If the Redux Community can migrate these dead &amp; unmaintained projects to Vite and React 18, it will benefit everyone for the long run. Especially, when Vite is the only option to work on for Client only application.<p>What do you think?<p>Regards,\nCJS<p>Note: my first post here, pls forgive if i am not following the guidelines.", "title": "Is the React Redux Community Active?", "updated_at": "2024-09-20T15:23:25Z"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "ndeodhar"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["vite", "production"], "value": "Hi HN, I'm Neha. I spent years at Google building infrastructure that handled billions of events at 99.999% reliability. When I started building AI agents, I was surprised at how much <em>production</em> plumbing you're expected to own yourself.<p>The agent itself is the easy part. The hard part is everything around it: where does it execute safely? What happens when it fails midway through a workflow? How do you trigger it from your existing tools? How do you even know what it did?<p>I kept stitching together Docker, a workflow engine, a notification layer, and custom retry logic. Every team I talked to was doing the same thing. So I built Polos - an open-source runtime that handles the <em>production</em> layer so you just write the agent.<p>What it does:<p>- Sandboxed execution: agents run sensitive operations inside managed Docker containers with built-in tools for file I/O, bash, and web search. You don't manage the sandbox or its lifecycle, Polos does. Will support more sandboxes like E2B in the future.<p>- Slack integration: @mention an agent in Slack, get responses in thread. Trigger workflows from Slack, receive notifications, collect input. Agents become part of your team's existing workflow.<p>- Durable workflows: if an agent fails mid-run, it resumes from the exact step that failed. Built-in prompt caching with 60-80% cost savings on retries.<p>- Observability: OpenTelemetry tracing for every step, tool call, and decision.<p>- LLM agnostic: works with OpenAI, Anthropic, Google, or any provider via Vercel AI SDK and LiteLLM.<p>The stack is Rust orchestrator (Axum + Tokio + PostgreSQL), Python and TypeScript SDKs, and <em>Vite</em> UI. You can install and run a durable, sandboxed agent in under 5 minutes:<p>```<p>curl -fsSL <a href=\"https://install.polos.dev/install.sh\" rel=\"nofollow\">https://install.polos.dev/install.sh</a> | bash<p>npx create-polos<p>cd my-project &amp;&amp; polos dev<p>```<p>Here's a 3-min demo of a coding agent that picks up a GitHub issue, fixes the code in a sandbox, and submits a PR: <a href=\"https://www.youtube.com/watch?v=KYVBpdZ_5eM\" rel=\"nofollow\">https://www.youtube.com/watch?v=KYVBpdZ_5eM</a><p>Happy to discuss technical decisions and more: why Rust for the orchestrator, how durable execution works without a DAG, and the sandbox lifecycle model.<p>GitHub: <a href=\"https://github.com/polos-dev/polos\" rel=\"nofollow\">https://github.com/polos-dev/polos</a>"}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Show HN: Polos: Open-source runtime for AI agents with sandbox and durable exec"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://github.com/polos-dev/polos"}}, "_tags": ["story", "author_ndeodhar", "story_47153680", "show_hn"], "author": "ndeodhar", "created_at": "2026-02-25T16:24:03Z", "created_at_i": 1772036643, "num_comments": 0, "objectID": "47153680", "points": 2, "story_id": 47153680, "story_text": "Hi HN, I&#x27;m Neha. I spent years at Google building infrastructure that handled billions of events at 99.999% reliability. When I started building AI agents, I was surprised at how much production plumbing you&#x27;re expected to own yourself.<p>The agent itself is the easy part. The hard part is everything around it: where does it execute safely? What happens when it fails midway through a workflow? How do you trigger it from your existing tools? How do you even know what it did?<p>I kept stitching together Docker, a workflow engine, a notification layer, and custom retry logic. Every team I talked to was doing the same thing. So I built Polos - an open-source runtime that handles the production layer so you just write the agent.<p>What it does:<p>- Sandboxed execution: agents run sensitive operations inside managed Docker containers with built-in tools for file I&#x2F;O, bash, and web search. You don&#x27;t manage the sandbox or its lifecycle, Polos does. Will support more sandboxes like E2B in the future.<p>- Slack integration: @mention an agent in Slack, get responses in thread. Trigger workflows from Slack, receive notifications, collect input. Agents become part of your team&#x27;s existing workflow.<p>- Durable workflows: if an agent fails mid-run, it resumes from the exact step that failed. Built-in prompt caching with 60-80% cost savings on retries.<p>- Observability: OpenTelemetry tracing for every step, tool call, and decision.<p>- LLM agnostic: works with OpenAI, Anthropic, Google, or any provider via Vercel AI SDK and LiteLLM.<p>The stack is Rust orchestrator (Axum + Tokio + PostgreSQL), Python and TypeScript SDKs, and Vite UI. You can install and run a durable, sandboxed agent in under 5 minutes:<p>```<p>curl -fsSL <a href=\"https:&#x2F;&#x2F;install.polos.dev&#x2F;install.sh\" rel=\"nofollow\">https:&#x2F;&#x2F;install.polos.dev&#x2F;install.sh</a> | bash<p>npx create-polos<p>cd my-project &amp;&amp; polos dev<p>```<p>Here&#x27;s a 3-min demo of a coding agent that picks up a GitHub issue, fixes the code in a sandbox, and submits a PR: <a href=\"https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=KYVBpdZ_5eM\" rel=\"nofollow\">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=KYVBpdZ_5eM</a><p>Happy to discuss technical decisions and more: why Rust for the orchestrator, how durable execution works without a DAG, and the sandbox lifecycle model.<p>GitHub: <a href=\"https:&#x2F;&#x2F;github.com&#x2F;polos-dev&#x2F;polos\" rel=\"nofollow\">https:&#x2F;&#x2F;github.com&#x2F;polos-dev&#x2F;polos</a>", "title": "Show HN: Polos: Open-source runtime for AI agents with sandbox and durable exec", "updated_at": "2026-02-25T18:22:03Z", "url": "https://github.com/polos-dev/polos"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "init0"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["vite", "production"], "value": "<a href=\"https://agentlearn.dev\" rel=\"nofollow\">https://agentlearn.dev</a><p>I built agentlearn after noticing that most AI agent tutorials focus on frameworks (LangChain, CrewAI) rather than fundamentals. The result is developers who can copy-paste code but struggle when things break.<p>This is a free, interactive course covering:<p>The Agent Loop - Why loops matter (think vs. act vs. observe)\nContext Engineering - The real skill behind &quot;prompt engineering&quot;\nTools &amp; Function Calling - Bridging text generation to real actions\nMemory Systems - Short-term vs. long-term, vector DBs\nProtocols - MCP, A2A, and the emerging standards\n<em>Production</em> Patterns - Error handling, cost optimization, observability\nEach concept has runnable code sandboxes you can step through. The design is intentionally &quot;hand-drawn&quot; to feel less intimidating than typical technical docs.<p>Tech stack: Vanilla JS + <em>Vite</em>, no framework.<p>Why no framework? Because understanding fundamentals means understanding what frameworks abstract away. Once you get the core loop, you can use any framework\u2014or build your own.<p>Feedback welcome! Especially interested in what topics are missing."}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Show HN: Agentlearn \u2013 Interactive course for AI agent fundamentals"}}, "_tags": ["story", "author_init0", "story_46522985", "show_hn"], "author": "init0", "created_at": "2026-01-07T05:36:38Z", "created_at_i": 1767764198, "num_comments": 0, "objectID": "46522985", "points": 2, "story_id": 46522985, "story_text": "<a href=\"https:&#x2F;&#x2F;agentlearn.dev\" rel=\"nofollow\">https:&#x2F;&#x2F;agentlearn.dev</a><p>I built agentlearn after noticing that most AI agent tutorials focus on frameworks (LangChain, CrewAI) rather than fundamentals. The result is developers who can copy-paste code but struggle when things break.<p>This is a free, interactive course covering:<p>The Agent Loop - Why loops matter (think vs. act vs. observe)\nContext Engineering - The real skill behind &quot;prompt engineering&quot;\nTools &amp; Function Calling - Bridging text generation to real actions\nMemory Systems - Short-term vs. long-term, vector DBs\nProtocols - MCP, A2A, and the emerging standards\nProduction Patterns - Error handling, cost optimization, observability\nEach concept has runnable code sandboxes you can step through. The design is intentionally &quot;hand-drawn&quot; to feel less intimidating than typical technical docs.<p>Tech stack: Vanilla JS + Vite, no framework.<p>Why no framework? Because understanding fundamentals means understanding what frameworks abstract away. Once you get the core loop, you can use any framework\u2014or build your own.<p>Feedback welcome! Especially interested in what topics are missing.", "title": "Show HN: Agentlearn \u2013 Interactive course for AI agent fundamentals", "updated_at": "2026-01-10T05:11:22Z"}], "hitsPerPage": 15, "nbHits": 33, "nbPages": 3, "page": 0, "params": "query=vite+production&tags=story&hitsPerPage=15&advancedSyntax=true&analyticsTags=backend", "processingTimeMS": 7, "processingTimingsMS": {"_request": {"queue": 25, "roundTrip": 16}, "afterFetch": {"format": {"highlighting": 1, "total": 2}}, "fetch": {"query": 5, "total": 6}, "total": 7}, "query": "vite production", "serverTimeMS": 34}}