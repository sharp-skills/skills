{"d": {"exhaustive": {"nbHits": false, "typo": false}, "exhaustiveNbHits": false, "exhaustiveTypo": false, "hits": [{"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "ricardodevelop"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["vitest", "production"], "value": "Hello everyone,<p>I\u2019ve created this starter project for creating <em>production</em> ready web apps in Vite and React that I hope some might find useful.<p>This template came about as a necessity to provide some standardization across new projects at work. A few of the initial goals when creating this project were to:<p>- Reduce setup time<p>- Standardize codebase with ESLint and Prettier<p>- Improve commit messages with tools like husky, commitizen and commitlint<p>- Improve codebase maintainability and scalability by providing a reasonable folder structure<p>- Simplify React Component development through use of tools like Storybook<p>- Improving codebase stability with unit and E2E tests via <em>Vitest</em> + React Testing Library and Playwright respectively<p>- Ease the deployment process by providing a simple starter Dockerfile<p>In addition to all the aforementioned goals, I also wanted to use modern tools such as React Query + Zustand for state management, React Hook Form + Zod for creating and validating forms, Tailwind CSS for building out UI\u2019s, etc.<p>I tried to cover everything I, and others, might need but recognize that everyones requirements are different. Luckily, this isn\u2019t a framework so removing unneeded packages or adding new ones is as simple it would normally be. The project itself doesn\u2019t come with a demo as its purpose is to simply provide a foundation for any new projects you might have in mind.<p>Feedback is always welcome and I appreciate anyone willing to checkout this project.<p>Thank you and have a great day."}, "title": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["production"], "value": "Show HN: Vite React Boilerplate \u2013 A <em>Production</em> Ready, Scalable Starter Template"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://github.com/RicardoValdovinos/vite-react-boilerplate"}}, "_tags": ["story", "author_ricardodevelop", "story_36926095", "show_hn"], "author": "ricardodevelop", "children": [36927690, 36928003], "created_at": "2023-07-29T23:49:15Z", "created_at_i": 1690674555, "num_comments": 5, "objectID": "36926095", "points": 18, "story_id": 36926095, "story_text": "Hello everyone,<p>I\u2019ve created this starter project for creating production ready web apps in Vite and React that I hope some might find useful.<p>This template came about as a necessity to provide some standardization across new projects at work. A few of the initial goals when creating this project were to:<p>- Reduce setup time<p>- Standardize codebase with ESLint and Prettier<p>- Improve commit messages with tools like husky, commitizen and commitlint<p>- Improve codebase maintainability and scalability by providing a reasonable folder structure<p>- Simplify React Component development through use of tools like Storybook<p>- Improving codebase stability with unit and E2E tests via Vitest + React Testing Library and Playwright respectively<p>- Ease the deployment process by providing a simple starter Dockerfile<p>In addition to all the aforementioned goals, I also wanted to use modern tools such as React Query + Zustand for state management, React Hook Form + Zod for creating and validating forms, Tailwind CSS for building out UI\u2019s, etc.<p>I tried to cover everything I, and others, might need but recognize that everyones requirements are different. Luckily, this isn\u2019t a framework so removing unneeded packages or adding new ones is as simple it would normally be. The project itself doesn\u2019t come with a demo as its purpose is to simply provide a foundation for any new projects you might have in mind.<p>Feedback is always welcome and I appreciate anyone willing to checkout this project.<p>Thank you and have a great day.", "title": "Show HN: Vite React Boilerplate \u2013 A Production Ready, Scalable Starter Template", "updated_at": "2024-09-20T14:45:12Z", "url": "https://github.com/RicardoValdovinos/vite-react-boilerplate"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "thesssaism"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["vitest", "production"], "value": "I recently ran an audit on our latest full-stack repo to figure out why &quot;spinning up a new project&quot; felt like such a heavy lift. I counted every file required just to reach a &quot;<em>production</em>-ready&quot; baseline\u2014before writing a single line of unique feature code.<p>The count was roughly 600 files.<p>To be clear, I'm not talking about a `create-react-app` sandbox. I mean a compliant, scalable SaaS foundation: Next.js frontend, Node.js/NestJS backend, mobile wrapper, CI/CD pipelines, and enough security config to pass a SOC2 audit.<p>It sounds ridiculous (and honestly, it feels ridiculous), but when I broke it down, I couldn't find many files I was willing to delete.<p>Here is where the bloat comes from:<p>First, the &quot;Configuration Hell&quot; accounts for about 40-50 files alone. We aren't just dealing with `package.json` anymore. It's `tsconfig.json` (base), `tsconfig.build.json`, `tsconfig.spec.json`... multiplied across frontend, backend, and shared libraries. Then add `.eslintrc.js`, `.prettierrc`, `jest.config.js`, `<em>vitest</em>.config.ts`, `nodemon.json`, and the Docker-compose variants for dev, test, and prod.<p>Then there\u2019s the DevOps and Quality layer. We have roughly 20-30 files for GitHub Actions workflows (lint, test, build, deploy, semantic release), Husky hooks (pre-commit, commit-msg), and pull request templates.<p>But the real multiplier is the separation of concerns. In a modern monorepo, a &quot;Hello World&quot; isn't just `console.log`. It\u2019s:\n- A NestJS module (Controller, Service, Module, DTO, Entity, Unit Test, E2E Test).\n- A Next.js slice (Page, Component, Type definition, API client wrapper).\n- A shared library entry.<p>We found that adding a single &quot;minimal&quot; API endpoint usually touches 5-7 files just to maintain architectural standards.<p>The trade-off is painful. On one hand, this setup handles the things we used to forget: security headers, proper logging, consistent error handling, and type safety across boundaries. It prevents the &quot;spaghetti code&quot; distinct to startups that scale too fast.<p>On the other hand, the cognitive load of managing a 600-file &quot;empty&quot; project is massive. Updating dependencies becomes a chore because a major version bump in one tool (like ESLint) cascades through forty config files.<p>I\u2019m curious how others are handling this &quot;starting line&quot; complexity.<p>Are you accepting the boilerplate as the cost of doing business? Or have you found a way to strip this down without sacrificing the compliance/safety guardrails that enterprise clients demand?<p>It feels like we've over-engineered the entry point of software development, but I\u2019m not sure what the alternative is for a serious project. We tried going &quot;lean&quot; initially, but spent weeks retrofitting auth and testing harnesses later\u2014which was worse.<p>Is there a middle ground I'm missing, or is ~600 files just the new normal?"}, "title": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["production"], "value": "Tell HN: A <em>production</em>-ready \"Hello World\" is now ~600 files"}}, "_tags": ["story", "author_thesssaism", "story_47074571", "ask_hn"], "author": "thesssaism", "children": [47074794, 47075001, 47075012, 47076406], "created_at": "2026-02-19T15:07:03Z", "created_at_i": 1771513623, "num_comments": 4, "objectID": "47074571", "points": 4, "story_id": 47074571, "story_text": "I recently ran an audit on our latest full-stack repo to figure out why &quot;spinning up a new project&quot; felt like such a heavy lift. I counted every file required just to reach a &quot;production-ready&quot; baseline\u2014before writing a single line of unique feature code.<p>The count was roughly 600 files.<p>To be clear, I&#x27;m not talking about a `create-react-app` sandbox. I mean a compliant, scalable SaaS foundation: Next.js frontend, Node.js&#x2F;NestJS backend, mobile wrapper, CI&#x2F;CD pipelines, and enough security config to pass a SOC2 audit.<p>It sounds ridiculous (and honestly, it feels ridiculous), but when I broke it down, I couldn&#x27;t find many files I was willing to delete.<p>Here is where the bloat comes from:<p>First, the &quot;Configuration Hell&quot; accounts for about 40-50 files alone. We aren&#x27;t just dealing with `package.json` anymore. It&#x27;s `tsconfig.json` (base), `tsconfig.build.json`, `tsconfig.spec.json`... multiplied across frontend, backend, and shared libraries. Then add `.eslintrc.js`, `.prettierrc`, `jest.config.js`, `vitest.config.ts`, `nodemon.json`, and the Docker-compose variants for dev, test, and prod.<p>Then there\u2019s the DevOps and Quality layer. We have roughly 20-30 files for GitHub Actions workflows (lint, test, build, deploy, semantic release), Husky hooks (pre-commit, commit-msg), and pull request templates.<p>But the real multiplier is the separation of concerns. In a modern monorepo, a &quot;Hello World&quot; isn&#x27;t just `console.log`. It\u2019s:\n- A NestJS module (Controller, Service, Module, DTO, Entity, Unit Test, E2E Test).\n- A Next.js slice (Page, Component, Type definition, API client wrapper).\n- A shared library entry.<p>We found that adding a single &quot;minimal&quot; API endpoint usually touches 5-7 files just to maintain architectural standards.<p>The trade-off is painful. On one hand, this setup handles the things we used to forget: security headers, proper logging, consistent error handling, and type safety across boundaries. It prevents the &quot;spaghetti code&quot; distinct to startups that scale too fast.<p>On the other hand, the cognitive load of managing a 600-file &quot;empty&quot; project is massive. Updating dependencies becomes a chore because a major version bump in one tool (like ESLint) cascades through forty config files.<p>I\u2019m curious how others are handling this &quot;starting line&quot; complexity.<p>Are you accepting the boilerplate as the cost of doing business? Or have you found a way to strip this down without sacrificing the compliance&#x2F;safety guardrails that enterprise clients demand?<p>It feels like we&#x27;ve over-engineered the entry point of software development, but I\u2019m not sure what the alternative is for a serious project. We tried going &quot;lean&quot; initially, but spent weeks retrofitting auth and testing harnesses later\u2014which was worse.<p>Is there a middle ground I&#x27;m missing, or is ~600 files just the new normal?", "title": "Tell HN: A production-ready \"Hello World\" is now ~600 files", "updated_at": "2026-02-20T00:09:42Z"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "tdfirth"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["vitest", "production"], "value": "Hey HN - our team wants to open source a project called NASTY (NASTY Abstract Syntax Tree thingY) that we built for ourselves. NASTY was built to maintain testable/composable data pipelines. Our team was ripping our hair out trying to maintain dbt/SQL scripts across different data warehouses (Redshift, BigQuery, Postgres, Snowflake) on top of ever shifting data foundations maintained by our customer's internal data teams. NASTY is the result of our learnings from field experience.<p>We wanted to write abstractions so that we could reuse code. We wanted to bundle those abstractions into libraries. We wanted to statically analyze our models so that we caught more errors before <em>production</em>. We wanted a fast unit test suite that you could iterate on locally without connecting to a data warehouse.<p>In short, we wanted to use all the same practices we used for building our other software. Tools like dbt made a great start at importing these kinds of practices into analytics, but there are many great aspects of the software engineering workflow that still aren't easy to replicate in data.<p>We've found it to be a super productive way to work, and we thought others might want to use it too. It's very early days so we've put up a page for to explain it, and we've made some executable examples for people to have a go. Let us know what you think!<p>FAQ:<p>Is NASTY an ORM? A SQL builder?<p>Neither! NASTY is kinda it's own thing. NASTY is more like a minimal relational algebra programming language shipped as a Typescript library. It borrows a bunch of learnings from other programming languages and applies them to OLAP programming / data engineering. It's an important distinction, because it totally changes the way you can think about building transformations.<p>Why TypeScript? Why not Python?<p>The 100% honest answer is we had a ton of typescript experience and we had a node/react app with pulumi's TS apis. We like typescript and by being a library instead of a full programming language, we can leverage things like <em>vitest</em>, eslint, node, TS's language server, TSdoc, etc."}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Show HN: Nasty, a cross-warehouse, type-checked, unit-testable analytics library"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://getnasty.dev/"}}, "_tags": ["story", "author_tdfirth", "story_39641713", "show_hn"], "author": "tdfirth", "children": [39643214, 39643428, 39643572, 39645879], "created_at": "2024-03-08T15:10:28Z", "created_at_i": 1709910628, "num_comments": 6, "objectID": "39641713", "points": 47, "story_id": 39641713, "story_text": "Hey HN - our team wants to open source a project called NASTY (NASTY Abstract Syntax Tree thingY) that we built for ourselves. NASTY was built to maintain testable&#x2F;composable data pipelines. Our team was ripping our hair out trying to maintain dbt&#x2F;SQL scripts across different data warehouses (Redshift, BigQuery, Postgres, Snowflake) on top of ever shifting data foundations maintained by our customer&#x27;s internal data teams. NASTY is the result of our learnings from field experience.<p>We wanted to write abstractions so that we could reuse code. We wanted to bundle those abstractions into libraries. We wanted to statically analyze our models so that we caught more errors before production. We wanted a fast unit test suite that you could iterate on locally without connecting to a data warehouse.<p>In short, we wanted to use all the same practices we used for building our other software. Tools like dbt made a great start at importing these kinds of practices into analytics, but there are many great aspects of the software engineering workflow that still aren&#x27;t easy to replicate in data.<p>We&#x27;ve found it to be a super productive way to work, and we thought others might want to use it too. It&#x27;s very early days so we&#x27;ve put up a page for to explain it, and we&#x27;ve made some executable examples for people to have a go. Let us know what you think!<p>FAQ:<p>Is NASTY an ORM? A SQL builder?<p>Neither! NASTY is kinda it&#x27;s own thing. NASTY is more like a minimal relational algebra programming language shipped as a Typescript library. It borrows a bunch of learnings from other programming languages and applies them to OLAP programming &#x2F; data engineering. It&#x27;s an important distinction, because it totally changes the way you can think about building transformations.<p>Why TypeScript? Why not Python?<p>The 100% honest answer is we had a ton of typescript experience and we had a node&#x2F;react app with pulumi&#x27;s TS apis. We like typescript and by being a library instead of a full programming language, we can leverage things like vitest, eslint, node, TS&#x27;s language server, TSdoc, etc.", "title": "Show HN: Nasty, a cross-warehouse, type-checked, unit-testable analytics library", "updated_at": "2024-09-20T16:36:50Z", "url": "https://getnasty.dev/"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "creativedg"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["vitest", "production"], "value": "I started this boilerplate in July 2020 and I\u2019ve been maintaining it for 5 years. It began on Next.js 9 and kept upgrading to Next.js 15+ (App Router), while upgrading the stack over time (Tailwind 1 \u2192 4, ESLint 8, swapping Cypress \u2192 Playwright, etc.). The goal is simple: I kept rebuilding the same setup, so I packaged it and kept it updated.<p>What you get (preconfigured, keep only what you need):<p>- Next.js 15 (App Router) + TypeScript + Tailwind 4<p>- Auth with Clerk (magic links, MFA, social, passkeys)<p>- I18n via next-intl<p>- DB with Drizzle ORM (PGlite locally)<p>- Forms with React Hook Form + Zod validation<p>- Testing: <em>Vitest</em> (unit), Playwright (integration/E2E)<p>- CI with GitHub Actions; Storybook for UI work<p>- SEO (Open Graph, JSON-LD, sitemap, robots)<p>- Observability: Sentry, logging with LogTape, log management &amp; uptime/monitoring<p>- Security: Arcjet (bot detection, rate limiting, shield rules)<p>- DX details: ESLint/Prettier, Lefthook + lint-staged, Commitlint, absolute imports, bundle analyzer<p>- AI code review<p>It\u2019s free and open source (MIT). Today the project sits around 11.8k GitHub stars and 2.2k forks. I\u2019m still actively maintaining it and adding features.<p>Repo: <a href=\"https://github.com/ixartz/Next-js-Boilerplate\" rel=\"nofollow\">https://github.com/ixartz/Next-js-Boilerplate</a><p>Why I built it<p>Spinning up auth, a DB, i18n, tests, and lint/format/CI for each new app was repetitive. This gives me (and hopefully you) a <em>production</em>-ready base in minutes, with opinionated defaults you can start.<p>I\u2019m open to suggestions and feedback, what would you like to see next? I\u2019ll hang around in the comments to answer questions."}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Show HN: Open-source Next.js 15 boilerplate \u2013 auth, DB, intl, tests, monitoring"}}, "_tags": ["story", "author_creativedg", "story_45052744", "show_hn"], "author": "creativedg", "created_at": "2025-08-28T14:38:31Z", "created_at_i": 1756391911, "num_comments": 0, "objectID": "45052744", "points": 4, "story_id": 45052744, "story_text": "I started this boilerplate in July 2020 and I\u2019ve been maintaining it for 5 years. It began on Next.js 9 and kept upgrading to Next.js 15+ (App Router), while upgrading the stack over time (Tailwind 1 \u2192 4, ESLint 8, swapping Cypress \u2192 Playwright, etc.). The goal is simple: I kept rebuilding the same setup, so I packaged it and kept it updated.<p>What you get (preconfigured, keep only what you need):<p>- Next.js 15 (App Router) + TypeScript + Tailwind 4<p>- Auth with Clerk (magic links, MFA, social, passkeys)<p>- I18n via next-intl<p>- DB with Drizzle ORM (PGlite locally)<p>- Forms with React Hook Form + Zod validation<p>- Testing: Vitest (unit), Playwright (integration&#x2F;E2E)<p>- CI with GitHub Actions; Storybook for UI work<p>- SEO (Open Graph, JSON-LD, sitemap, robots)<p>- Observability: Sentry, logging with LogTape, log management &amp; uptime&#x2F;monitoring<p>- Security: Arcjet (bot detection, rate limiting, shield rules)<p>- DX details: ESLint&#x2F;Prettier, Lefthook + lint-staged, Commitlint, absolute imports, bundle analyzer<p>- AI code review<p>It\u2019s free and open source (MIT). Today the project sits around 11.8k GitHub stars and 2.2k forks. I\u2019m still actively maintaining it and adding features.<p>Repo: <a href=\"https:&#x2F;&#x2F;github.com&#x2F;ixartz&#x2F;Next-js-Boilerplate\" rel=\"nofollow\">https:&#x2F;&#x2F;github.com&#x2F;ixartz&#x2F;Next-js-Boilerplate</a><p>Why I built it<p>Spinning up auth, a DB, i18n, tests, and lint&#x2F;format&#x2F;CI for each new app was repetitive. This gives me (and hopefully you) a production-ready base in minutes, with opinionated defaults you can start.<p>I\u2019m open to suggestions and feedback, what would you like to see next? I\u2019ll hang around in the comments to answer questions.", "title": "Show HN: Open-source Next.js 15 boilerplate \u2013 auth, DB, intl, tests, monitoring", "updated_at": "2025-08-29T18:59:31Z"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "theahura"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["vitest", "production"], "value": "A few weeks ago, I was getting random OOMs on my linux box and I had no idea what was causing them. At one point when I realized that the memory was getting sucked up by some process, I kicked off a claude code job to see if it could figure out what was happening in real time. And it did!<p>In real time the coding agent ran through a suite of system commands, figured out which jobs were causing problems, and then even started to dig into the explicit function calls (python and node processes can both be inspected at the function call level by sideloaded processes) before the entire system finally crashed.<p>Besides being extremely cool, I realized that with a few tweaks I could make this a legitimately useful tool. The basic idea: any time certain system vitals cross a threshold, spin up a coding agent and have the agent debug what is going on as aggressively as possible, with all logs being streamed to a third party server (in addition to being stored on disk). This basic abstraction would solve two huge problems:<p>- Most of the time it is very hard to figure out why exactly a machine went down. This tool would effectively act as an airplane blackbox, a sort of last record of what was going on that specifically is focused on debugging the failure as it happened. Massive speed up on figuring out system-breaking issues.<p>- Most of the time there are available interventions that someone could take that would prevent the system from going down at all, if a human was around when the crash was happening. For example, if I see that I\u2019m about to OOM from <em>vitest</em>, I can just kill a bunch of the processes that are spiking memory and prevent the system from crashing that way.<p>We now have premortem running on all of our <em>production</em> machines.<p>Hope this is useful for other folks!"}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Show HN: Premortem, a coding-agent-powered airplane blackbox"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://github.com/tilework-tech/nori-premortem"}}, "_tags": ["story", "author_theahura", "story_45998728", "show_hn"], "author": "theahura", "children": [45999005], "created_at": "2025-11-20T22:27:55Z", "created_at_i": 1763677675, "num_comments": 5, "objectID": "45998728", "points": 3, "story_id": 45998728, "story_text": "A few weeks ago, I was getting random OOMs on my linux box and I had no idea what was causing them. At one point when I realized that the memory was getting sucked up by some process, I kicked off a claude code job to see if it could figure out what was happening in real time. And it did!<p>In real time the coding agent ran through a suite of system commands, figured out which jobs were causing problems, and then even started to dig into the explicit function calls (python and node processes can both be inspected at the function call level by sideloaded processes) before the entire system finally crashed.<p>Besides being extremely cool, I realized that with a few tweaks I could make this a legitimately useful tool. The basic idea: any time certain system vitals cross a threshold, spin up a coding agent and have the agent debug what is going on as aggressively as possible, with all logs being streamed to a third party server (in addition to being stored on disk). This basic abstraction would solve two huge problems:<p>- Most of the time it is very hard to figure out why exactly a machine went down. This tool would effectively act as an airplane blackbox, a sort of last record of what was going on that specifically is focused on debugging the failure as it happened. Massive speed up on figuring out system-breaking issues.<p>- Most of the time there are available interventions that someone could take that would prevent the system from going down at all, if a human was around when the crash was happening. For example, if I see that I\u2019m about to OOM from vitest, I can just kill a bunch of the processes that are spiking memory and prevent the system from crashing that way.<p>We now have premortem running on all of our production machines.<p>Hope this is useful for other folks!", "title": "Show HN: Premortem, a coding-agent-powered airplane blackbox", "updated_at": "2025-11-21T01:44:30Z", "url": "https://github.com/tilework-tech/nori-premortem"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "cyco130"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["vitest", "production"], "value": "Pleased to announce version 0.2.1 of , \u201cthe dancing web framework\u201d which aims to unite a Next.js-inspired development experience with <em>Vite's</em> blazing speed. Please check it out, all kinds of feedback are most welcome. It's not <em>production</em>-ready yet but many features have been implemented:<p>- Hassle-free server-side rendering\n- File system-based routing with dynamic routes, nested layouts, and thematic layout groups\n- SPA-style client-side router\n- Simple but effective data fetching system\n- API routes to build API endpoints and middleware<p>This new version brings:<p>- Project initializer (`npm init rakkas-app`)\n- Hot reloading for pages and layouts\n- More robust body parser which now supports `application/x-www-form-urlencoded` in addition to plain text and JSON\n- New website domain: rakkasjs.org\n- Bug fixes\n- Performance and package size improvements<p>And short term goals incude:<p>- Static site generation\n- Optional data caching\n- Support for serverless environments\n- Localizable and customizable router<p>Check the github page for more info: https://github.com/rakkasjs/rakkasjs"}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Rakkas: The Dancing Web Frameork"}}, "_tags": ["story", "author_cyco130", "story_27797669", "ask_hn"], "author": "cyco130", "children": [27797744], "created_at": "2021-07-11T00:58:32Z", "created_at_i": 1625965112, "num_comments": 1, "objectID": "27797669", "points": 3, "story_id": 27797669, "story_text": "Pleased to announce version 0.2.1 of , \u201cthe dancing web framework\u201d which aims to unite a Next.js-inspired development experience with Vite&#x27;s blazing speed. Please check it out, all kinds of feedback are most welcome. It&#x27;s not production-ready yet but many features have been implemented:<p>- Hassle-free server-side rendering\n- File system-based routing with dynamic routes, nested layouts, and thematic layout groups\n- SPA-style client-side router\n- Simple but effective data fetching system\n- API routes to build API endpoints and middleware<p>This new version brings:<p>- Project initializer (`npm init rakkas-app`)\n- Hot reloading for pages and layouts\n- More robust body parser which now supports `application&#x2F;x-www-form-urlencoded` in addition to plain text and JSON\n- New website domain: rakkasjs.org\n- Bug fixes\n- Performance and package size improvements<p>And short term goals incude:<p>- Static site generation\n- Optional data caching\n- Support for serverless environments\n- Localizable and customizable router<p>Check the github page for more info: https:&#x2F;&#x2F;github.com&#x2F;rakkasjs&#x2F;rakkasjs", "title": "Rakkas: The Dancing Web Frameork", "updated_at": "2024-09-20T08:59:31Z"}], "hitsPerPage": 15, "nbHits": 6, "nbPages": 1, "page": 0, "params": "query=vitest+production&tags=story&hitsPerPage=15&advancedSyntax=true&analyticsTags=backend", "processingTimeMS": 11, "processingTimingsMS": {"_request": {"roundTrip": 15}, "afterFetch": {"format": {"highlighting": 1, "total": 1}}, "fetch": {"query": 7, "scanning": 2, "total": 10}, "total": 11}, "query": "vitest production", "serverTimeMS": 13}}