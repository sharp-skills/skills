{"d": {"kind": "Listing", "data": {"modhash": "", "dist": 5, "facets": {}, "after": "t3_1k643mt", "geo_filter": "", "children": [{"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "programming", "selftext": "So I was reading about OAuth to learn it and have created this explanation. It's basically a few of the best I have found merged together and rewritten in big parts. I have also added a _super short summary_ and a _code example_. Maybe it helps one of you :-)\n\n# OAuth Explained\n\n## The Basic Idea\n\nLet\u2019s say LinkedIn wants to let users import their Google contacts.\n\nOne obvious (but terrible) option would be to just ask users to enter their Gmail email and password directly into LinkedIn. But giving away your actual login credentials to another app is a huge security risk.\n\nOAuth was designed to solve exactly this kind of problem.\n\nNote: So OAuth solves an authorization problem! Not an authentication problem. See [here][ref1] for the difference.\n\n## Super Short Summary\n\n- User clicks \u201cImport Google Contacts\u201d on LinkedIn\n- LinkedIn redirects user to Google\u2019s OAuth consent page\n- User logs in and approves access\n- Google redirects back to LinkedIn with a one-time code\n- LinkedIn uses that code to get an access token from Google\n- LinkedIn uses the access token to call Google\u2019s API and fetch contacts\n\n## More Detailed Summary\n\nSuppose LinkedIn wants to import a user\u2019s contacts from their Google account.\n\n1. LinkedIn sets up a Google API account and receives a client_id and a client_secret\n   - So Google knows this client id is LinkedIn\n2. A user visits LinkedIn and clicks \"Import Google Contacts\"\n3. LinkedIn redirects the user to Google\u2019s authorization endpoint:\n   https://accounts.google.com/o/oauth2/auth?client_id=12345&amp;redirect_uri=https://linkedin.com/oauth/callback&amp;scope=contacts\n\n- client_id is the before mentioned client id, so Google knows it's LinkedIn\n- redirect_uri is very important. It's used in step 6\n- in scope LinkedIn tells Google how much it wants to have access to, in this case the contacts of the user\n\n4. The user will have to log in at Google\n5. Google displays a consent screen: \"LinkedIn wants to access your Google contacts. Allow?\" The user clicks \"Allow\"\n6. Google generates a one-time authorization code and redirects to the URI we specified: redirect_uri. **It appends the one-time code as a URL parameter**.\n   - So the URL could be https://linkedin.com/oauth/callback?code=one_time_code_xyz\n7. Now, LinkedIn makes a server-to-server request (not a redirect) to Google\u2019s token endpoint and receive an access token (and ideally a refresh token)\n8. **Finished**. Now LinkedIn can use this access token to access the user\u2019s Google contacts via Google\u2019s API\n\n---\n\n**Question:**\n_Why not just send the access token in step 6?_\n\n**Answer:** To make sure that the requester is actually LinkedIn. So far, all requests to Google have come from the user\u2019s browser, with only the client_id identifying LinkedIn. Since the client_id isn\u2019t secret and could be guessed by an attacker, Google can\u2019t know for sure that it's actually LinkedIn behind this. In the next step, LinkedIn proves its identity by including the client_secret in a server-to-server request.\n\n## Security Note: Encryption\n\nOAuth 2.0 does **not** handle encryption itself. It relies on HTTPS (SSL/TLS) to secure sensitive data like the client_secret and access tokens during transmission.\n\n## Security Addendum: The state Parameter\n\nThe state parameter is critical to prevent cross-site request forgery (CSRF) attacks. It\u2019s a unique, random value generated by the third-party app (e.g., LinkedIn) and included in the authorization request. Google returns it unchanged in the callback. LinkedIn verifies the state matches the original to ensure the request came from the user, not an attacker.\n\n## OAuth 1.0 vs OAuth 2.0 Addendum:\n\nOAuth 1.0 required clients to cryptographically sign every request, which was more secure but also much more complicated. OAuth 2.0 made things simpler by relying on HTTPS to protect data in transit, and using bearer tokens instead of signed requests.\n\n## Code Example: OAuth 2.0 Login Implementation\n\nBelow is a standalone Node.js example using Express to handle OAuth 2.0 login with Google, storing user data in a SQLite database.\n\n```javascript\nconst express = require(\"express\");\nconst axios = require(\"axios\");\nconst sqlite3 = require(\"sqlite3\").verbose();\nconst crypto = require(\"crypto\");\nconst jwt = require(\"jsonwebtoken\");\nconst jwksClient = require(\"jwks-rsa\");\n\nconst app = express();\nconst db = new sqlite3.Database(\":memory:\");\n\n// Initialize database\ndb.serialize(() =&gt; {\n  db.run(\n    \"CREATE TABLE users (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT, email TEXT)\"\n  );\n  db.run(\n    \"CREATE TABLE federated_credentials (user_id INTEGER, provider TEXT, subject TEXT, PRIMARY KEY (provider, subject))\"\n  );\n});\n\n// Configuration\nconst CLIENT_ID = process.env.GOOGLE_CLIENT_ID;\nconst CLIENT_SECRET = process.env.GOOGLE_CLIENT_SECRET;\nconst REDIRECT_URI = \"https://example.com/oauth2/callback\";\nconst SCOPE = \"openid profile email\";\n\n// JWKS client to fetch Google's public keys\nconst jwks = jwksClient({\n  jwksUri: \"https://www.googleapis.com/oauth2/v3/certs\",\n});\n\n// Function to verify JWT\nasync function verifyIdToken(idToken) {\n  return new Promise((resolve, reject) =&gt; {\n    jwt.verify(\n      idToken,\n      (header, callback) =&gt; {\n        jwks.getSigningKey(header.kid, (err, key) =&gt; {\n          callback(null, key.getPublicKey());\n        });\n      },\n      {\n        audience: CLIENT_ID,\n        issuer: \"https://accounts.google.com\",\n      },\n      (err, decoded) =&gt; {\n        if (err) return reject(err);\n        resolve(decoded);\n      }\n    );\n  });\n}\n\n// Generate a random state for CSRF protection\napp.get(\"/login\", (req, res) =&gt; {\n  const state = crypto.randomBytes(16).toString(\"hex\");\n  req.session.state = state; // Store state in session\n  const authUrl = `https://accounts.google.com/o/oauth2/auth?client_id=${CLIENT_ID}&amp;redirect_uri=${REDIRECT_URI}&amp;scope=${SCOPE}&amp;response_type=code&amp;state=${state}`;\n  res.redirect(authUrl);\n});\n\n// OAuth callback\napp.get(\"/oauth2/callback\", async (req, res) =&gt; {\n  const { code, state } = req.query;\n\n  // Verify state to prevent CSRF\n  if (state !== req.session.state) {\n    return res.status(403).send(\"Invalid state parameter\");\n  }\n\n  try {\n    // Exchange code for tokens\n    const tokenResponse = await axios.post(\n      \"https://oauth2.googleapis.com/token\",\n      {\n        code,\n        client_id: CLIENT_ID,\n        client_secret: CLIENT_SECRET,\n        redirect_uri: REDIRECT_URI,\n        grant_type: \"authorization_code\",\n      }\n    );\n\n    const { id_token } = tokenResponse.data;\n\n    // Verify ID token (JWT)\n    const decoded = await verifyIdToken(id_token);\n    const { sub: subject, name, email } = decoded;\n\n    // Check if user exists in federated_credentials\n    db.get(\n      \"SELECT * FROM federated_credentials WHERE provider = ? AND subject = ?\",\n      [\"https://accounts.google.com\", subject],\n      (err, cred) =&gt; {\n        if (err) return res.status(500).send(\"Database error\");\n\n        if (!cred) {\n          // New user: create account\n          db.run(\n            \"INSERT INTO users (name, email) VALUES (?, ?)\",\n            [name, email],\n            function (err) {\n              if (err) return res.status(500).send(\"Database error\");\n\n              const userId = this.lastID;\n              db.run(\n                \"INSERT INTO federated_credentials (user_id, provider, subject) VALUES (?, ?, ?)\",\n                [userId, \"https://accounts.google.com\", subject],\n                (err) =&gt; {\n                  if (err) return res.status(500).send(\"Database error\");\n                  res.send(`Logged in as ${name} (${email})`);\n                }\n              );\n            }\n          );\n        } else {\n          // Existing user: fetch and log in\n          db.get(\n            \"SELECT * FROM users WHERE id = ?\",\n            [cred.user_id],\n            (err, user) =&gt; {\n              if (err || !user) return res.status(500).send(\"Database error\");\n              res.send(`Logged in as ${user.name} (${user.email})`);\n            }\n          );\n        }\n      }\n    );\n  } catch (error) {\n    res.status(500).send(\"OAuth or JWT verification error\");\n  }\n});\n\napp.listen(3000, () =&gt; console.log(\"Server running on port 3000\"));\n```", "author_fullname": "t2_7tlomxnm", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "How does OAuth work: ELI5?", "link_flair_richtext": [], "subreddit_name_prefixed": "r/programming", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "thumbnail_height": 70, "top_awarded_type": null, "hide_score": false, "name": "t3_1k4hg9j", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.89, "author_flair_background_color": null, "subreddit_type": "public", "ups": 179, "total_awards_received": 0, "media_embed": {}, "thumbnail_width": 140, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 179, "approved_by": null, "is_created_from_ads_ui": false, "author_premium": false, "thumbnail": "default", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "post_hint": "link", "content_categories": null, "is_self": false, "mod_note": null, "created": 1745252410.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "github.com", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;So I was reading about OAuth to learn it and have created this explanation. It&amp;#39;s basically a few of the best I have found merged together and rewritten in big parts. I have also added a &lt;em&gt;super short summary&lt;/em&gt; and a &lt;em&gt;code example&lt;/em&gt;. Maybe it helps one of you :-)&lt;/p&gt;\n\n&lt;h1&gt;OAuth Explained&lt;/h1&gt;\n\n&lt;h2&gt;The Basic Idea&lt;/h2&gt;\n\n&lt;p&gt;Let\u2019s say LinkedIn wants to let users import their Google contacts.&lt;/p&gt;\n\n&lt;p&gt;One obvious (but terrible) option would be to just ask users to enter their Gmail email and password directly into LinkedIn. But giving away your actual login credentials to another app is a huge security risk.&lt;/p&gt;\n\n&lt;p&gt;OAuth was designed to solve exactly this kind of problem.&lt;/p&gt;\n\n&lt;p&gt;Note: So OAuth solves an authorization problem! Not an authentication problem. See [here][ref1] for the difference.&lt;/p&gt;\n\n&lt;h2&gt;Super Short Summary&lt;/h2&gt;\n\n&lt;ul&gt;\n&lt;li&gt;User clicks \u201cImport Google Contacts\u201d on LinkedIn&lt;/li&gt;\n&lt;li&gt;LinkedIn redirects user to Google\u2019s OAuth consent page&lt;/li&gt;\n&lt;li&gt;User logs in and approves access&lt;/li&gt;\n&lt;li&gt;Google redirects back to LinkedIn with a one-time code&lt;/li&gt;\n&lt;li&gt;LinkedIn uses that code to get an access token from Google&lt;/li&gt;\n&lt;li&gt;LinkedIn uses the access token to call Google\u2019s API and fetch contacts&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;h2&gt;More Detailed Summary&lt;/h2&gt;\n\n&lt;p&gt;Suppose LinkedIn wants to import a user\u2019s contacts from their Google account.&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;LinkedIn sets up a Google API account and receives a client_id and a client_secret\n\n&lt;ul&gt;\n&lt;li&gt;So Google knows this client id is LinkedIn&lt;/li&gt;\n&lt;/ul&gt;&lt;/li&gt;\n&lt;li&gt;A user visits LinkedIn and clicks &amp;quot;Import Google Contacts&amp;quot;&lt;/li&gt;\n&lt;li&gt;LinkedIn redirects the user to Google\u2019s authorization endpoint:\n&lt;a href=\"https://accounts.google.com/o/oauth2/auth?client_id=12345&amp;amp;redirect_uri=https://linkedin.com/oauth/callback&amp;amp;scope=contacts\"&gt;https://accounts.google.com/o/oauth2/auth?client_id=12345&amp;amp;redirect_uri=https://linkedin.com/oauth/callback&amp;amp;scope=contacts&lt;/a&gt;&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;ul&gt;\n&lt;li&gt;client_id is the before mentioned client id, so Google knows it&amp;#39;s LinkedIn&lt;/li&gt;\n&lt;li&gt;redirect_uri is very important. It&amp;#39;s used in step 6&lt;/li&gt;\n&lt;li&gt;in scope LinkedIn tells Google how much it wants to have access to, in this case the contacts of the user&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;ol&gt;\n&lt;li&gt;The user will have to log in at Google&lt;/li&gt;\n&lt;li&gt;Google displays a consent screen: &amp;quot;LinkedIn wants to access your Google contacts. Allow?&amp;quot; The user clicks &amp;quot;Allow&amp;quot;&lt;/li&gt;\n&lt;li&gt;Google generates a one-time authorization code and redirects to the URI we specified: redirect_uri. &lt;strong&gt;It appends the one-time code as a URL parameter&lt;/strong&gt;.\n\n&lt;ul&gt;\n&lt;li&gt;So the URL could be &lt;a href=\"https://linkedin.com/oauth/callback?code=one_time_code_xyz\"&gt;https://linkedin.com/oauth/callback?code=one_time_code_xyz&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;&lt;/li&gt;\n&lt;li&gt;Now, LinkedIn makes a server-to-server request (not a redirect) to Google\u2019s token endpoint and receive an access token (and ideally a refresh token)&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;Finished&lt;/strong&gt;. Now LinkedIn can use this access token to access the user\u2019s Google contacts via Google\u2019s API&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;hr/&gt;\n\n&lt;p&gt;&lt;strong&gt;Question:&lt;/strong&gt;\n&lt;em&gt;Why not just send the access token in step 6?&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; To make sure that the requester is actually LinkedIn. So far, all requests to Google have come from the user\u2019s browser, with only the client_id identifying LinkedIn. Since the client_id isn\u2019t secret and could be guessed by an attacker, Google can\u2019t know for sure that it&amp;#39;s actually LinkedIn behind this. In the next step, LinkedIn proves its identity by including the client_secret in a server-to-server request.&lt;/p&gt;\n\n&lt;h2&gt;Security Note: Encryption&lt;/h2&gt;\n\n&lt;p&gt;OAuth 2.0 does &lt;strong&gt;not&lt;/strong&gt; handle encryption itself. It relies on HTTPS (SSL/TLS) to secure sensitive data like the client_secret and access tokens during transmission.&lt;/p&gt;\n\n&lt;h2&gt;Security Addendum: The state Parameter&lt;/h2&gt;\n\n&lt;p&gt;The state parameter is critical to prevent cross-site request forgery (CSRF) attacks. It\u2019s a unique, random value generated by the third-party app (e.g., LinkedIn) and included in the authorization request. Google returns it unchanged in the callback. LinkedIn verifies the state matches the original to ensure the request came from the user, not an attacker.&lt;/p&gt;\n\n&lt;h2&gt;OAuth 1.0 vs OAuth 2.0 Addendum:&lt;/h2&gt;\n\n&lt;p&gt;OAuth 1.0 required clients to cryptographically sign every request, which was more secure but also much more complicated. OAuth 2.0 made things simpler by relying on HTTPS to protect data in transit, and using bearer tokens instead of signed requests.&lt;/p&gt;\n\n&lt;h2&gt;Code Example: OAuth 2.0 Login Implementation&lt;/h2&gt;\n\n&lt;p&gt;Below is a standalone Node.js example using Express to handle OAuth 2.0 login with Google, storing user data in a SQLite database.&lt;/p&gt;\n\n&lt;p&gt;```javascript\nconst express = require(&amp;quot;express&amp;quot;);\nconst axios = require(&amp;quot;axios&amp;quot;);\nconst sqlite3 = require(&amp;quot;sqlite3&amp;quot;).verbose();\nconst crypto = require(&amp;quot;crypto&amp;quot;);\nconst jwt = require(&amp;quot;jsonwebtoken&amp;quot;);\nconst jwksClient = require(&amp;quot;jwks-rsa&amp;quot;);&lt;/p&gt;\n\n&lt;p&gt;const app = express();\nconst db = new sqlite3.Database(&amp;quot;:memory:&amp;quot;);&lt;/p&gt;\n\n&lt;p&gt;// Initialize database\ndb.serialize(() =&amp;gt; {\n  db.run(\n    &amp;quot;CREATE TABLE users (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT, email TEXT)&amp;quot;\n  );\n  db.run(\n    &amp;quot;CREATE TABLE federated_credentials (user_id INTEGER, provider TEXT, subject TEXT, PRIMARY KEY (provider, subject))&amp;quot;\n  );\n});&lt;/p&gt;\n\n&lt;p&gt;// Configuration\nconst CLIENT_ID = process.env.GOOGLE_CLIENT_ID;\nconst CLIENT_SECRET = process.env.GOOGLE_CLIENT_SECRET;\nconst REDIRECT_URI = &amp;quot;&lt;a href=\"https://example.com/oauth2/callback\"&gt;https://example.com/oauth2/callback&lt;/a&gt;&amp;quot;;\nconst SCOPE = &amp;quot;openid profile email&amp;quot;;&lt;/p&gt;\n\n&lt;p&gt;// JWKS client to fetch Google&amp;#39;s public keys\nconst jwks = jwksClient({\n  jwksUri: &amp;quot;&lt;a href=\"https://www.googleapis.com/oauth2/v3/certs\"&gt;https://www.googleapis.com/oauth2/v3/certs&lt;/a&gt;&amp;quot;,\n});&lt;/p&gt;\n\n&lt;p&gt;// Function to verify JWT\nasync function verifyIdToken(idToken) {\n  return new Promise((resolve, reject) =&amp;gt; {\n    jwt.verify(\n      idToken,\n      (header, callback) =&amp;gt; {\n        jwks.getSigningKey(header.kid, (err, key) =&amp;gt; {\n          callback(null, key.getPublicKey());\n        });\n      },\n      {\n        audience: CLIENT_ID,\n        issuer: &amp;quot;&lt;a href=\"https://accounts.google.com\"&gt;https://accounts.google.com&lt;/a&gt;&amp;quot;,\n      },\n      (err, decoded) =&amp;gt; {\n        if (err) return reject(err);\n        resolve(decoded);\n      }\n    );\n  });\n}&lt;/p&gt;\n\n&lt;p&gt;// Generate a random state for CSRF protection\napp.get(&amp;quot;/login&amp;quot;, (req, res) =&amp;gt; {\n  const state = crypto.randomBytes(16).toString(&amp;quot;hex&amp;quot;);\n  req.session.state = state; // Store state in session\n  const authUrl = &lt;code&gt;https://accounts.google.com/o/oauth2/auth?client_id=${CLIENT_ID}&amp;amp;redirect_uri=${REDIRECT_URI}&amp;amp;scope=${SCOPE}&amp;amp;response_type=code&amp;amp;state=${state}&lt;/code&gt;;\n  res.redirect(authUrl);\n});&lt;/p&gt;\n\n&lt;p&gt;// OAuth callback\napp.get(&amp;quot;/oauth2/callback&amp;quot;, async (req, res) =&amp;gt; {\n  const { code, state } = req.query;&lt;/p&gt;\n\n&lt;p&gt;// Verify state to prevent CSRF\n  if (state !== req.session.state) {\n    return res.status(403).send(&amp;quot;Invalid state parameter&amp;quot;);\n  }&lt;/p&gt;\n\n&lt;p&gt;try {\n    // Exchange code for tokens\n    const tokenResponse = await axios.post(\n      &amp;quot;&lt;a href=\"https://oauth2.googleapis.com/token\"&gt;https://oauth2.googleapis.com/token&lt;/a&gt;&amp;quot;,\n      {\n        code,\n        client_id: CLIENT_ID,\n        client_secret: CLIENT_SECRET,\n        redirect_uri: REDIRECT_URI,\n        grant_type: &amp;quot;authorization_code&amp;quot;,\n      }\n    );&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;const { id_token } = tokenResponse.data;\n\n// Verify ID token (JWT)\nconst decoded = await verifyIdToken(id_token);\nconst { sub: subject, name, email } = decoded;\n\n// Check if user exists in federated_credentials\ndb.get(\n  &amp;quot;SELECT * FROM federated_credentials WHERE provider = ? AND subject = ?&amp;quot;,\n  [&amp;quot;https://accounts.google.com&amp;quot;, subject],\n  (err, cred) =&amp;gt; {\n    if (err) return res.status(500).send(&amp;quot;Database error&amp;quot;);\n\n    if (!cred) {\n      // New user: create account\n      db.run(\n        &amp;quot;INSERT INTO users (name, email) VALUES (?, ?)&amp;quot;,\n        [name, email],\n        function (err) {\n          if (err) return res.status(500).send(&amp;quot;Database error&amp;quot;);\n\n          const userId = this.lastID;\n          db.run(\n            &amp;quot;INSERT INTO federated_credentials (user_id, provider, subject) VALUES (?, ?, ?)&amp;quot;,\n            [userId, &amp;quot;https://accounts.google.com&amp;quot;, subject],\n            (err) =&amp;gt; {\n              if (err) return res.status(500).send(&amp;quot;Database error&amp;quot;);\n              res.send(`Logged in as ${name} (${email})`);\n            }\n          );\n        }\n      );\n    } else {\n      // Existing user: fetch and log in\n      db.get(\n        &amp;quot;SELECT * FROM users WHERE id = ?&amp;quot;,\n        [cred.user_id],\n        (err, user) =&amp;gt; {\n          if (err || !user) return res.status(500).send(&amp;quot;Database error&amp;quot;);\n          res.send(`Logged in as ${user.name} (${user.email})`);\n        }\n      );\n    }\n  }\n);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;} catch (error) {\n    res.status(500).send(&amp;quot;OAuth or JWT verification error&amp;quot;);\n  }\n});&lt;/p&gt;\n\n&lt;p&gt;app.listen(3000, () =&amp;gt; console.log(&amp;quot;Server running on port 3000&amp;quot;));\n```&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "url_overridden_by_dest": "https://github.com/LukasNiessen/oauth-explained", "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "preview": {"images": [{"source": {"url": "https://external-preview.redd.it/md9_FfNjf0OkzfuBbJ1WxO-iz20HeHhwX9_oHqa07EY.jpg?auto=webp&amp;s=7a7bf2118564d4b6f628f75560a8f17a757a1d36", "width": 1200, "height": 600}, "resolutions": [{"url": "https://external-preview.redd.it/md9_FfNjf0OkzfuBbJ1WxO-iz20HeHhwX9_oHqa07EY.jpg?width=108&amp;crop=smart&amp;auto=webp&amp;s=307a36f9c3f5d95ce57639647d1a20793c50c410", "width": 108, "height": 54}, {"url": "https://external-preview.redd.it/md9_FfNjf0OkzfuBbJ1WxO-iz20HeHhwX9_oHqa07EY.jpg?width=216&amp;crop=smart&amp;auto=webp&amp;s=0fdd7855314973619a230551ecdc00aff1e0a1f9", "width": 216, "height": 108}, {"url": "https://external-preview.redd.it/md9_FfNjf0OkzfuBbJ1WxO-iz20HeHhwX9_oHqa07EY.jpg?width=320&amp;crop=smart&amp;auto=webp&amp;s=551cb789db429fe3eef22028fbb7962f372975ab", "width": 320, "height": 160}, {"url": "https://external-preview.redd.it/md9_FfNjf0OkzfuBbJ1WxO-iz20HeHhwX9_oHqa07EY.jpg?width=640&amp;crop=smart&amp;auto=webp&amp;s=a114ad01ee06c9a0020400afec8eb40d0db4765c", "width": 640, "height": 320}, {"url": "https://external-preview.redd.it/md9_FfNjf0OkzfuBbJ1WxO-iz20HeHhwX9_oHqa07EY.jpg?width=960&amp;crop=smart&amp;auto=webp&amp;s=64380c1307ab5c58cad75e8d3aa1c2e24c00d639", "width": 960, "height": 480}, {"url": "https://external-preview.redd.it/md9_FfNjf0OkzfuBbJ1WxO-iz20HeHhwX9_oHqa07EY.jpg?width=1080&amp;crop=smart&amp;auto=webp&amp;s=87c520b9141e6be3e0955b292e1f66f20e535a40", "width": 1080, "height": 540}], "variants": {}, "id": "ka8ZGcTzgjD7w4hfAoknAfxYuadtMlgJ9y8h1CiA5tg"}], "enabled": false}, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2fwo", "author_is_blocked": false, "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "1k4hg9j", "is_robot_indexable": true, "report_reasons": null, "author": "trolleid", "discussion_type": null, "num_comments": 36, "send_replies": true, "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/programming/comments/1k4hg9j/how_does_oauth_work_eli5/", "stickied": false, "url": "https://github.com/LukasNiessen/oauth-explained", "subreddit_subscribers": 6844509, "created_utc": 1745252410.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "LocalLLaMA", "selftext": "I saw the discussion about MiniMax M2 in the group chat a couple of days ago, and since their API and agent are free to use, I thought I\u2019d test it out. First, the conclusion: in my own use, M2 delivers better than expected efficiency and stability. You can feel the team has pushed the model\u2019s strengths close to top closed models. In some scenarios it reaches top results at clearly lower cost, so it fits as the default executor, with closed models kept for final polish when needed.\n\nMy comparison across models:\n\n1. A three service monorepo dependency and lock file mess (Node.js + Express). The three services used different versions of jsonwebtoken and had lock file conflicts. The goal was to unify versions, upgrade jwt.verify from callback to Promise, and add an npm run bootstrap script for one click dependency setup and alignment.\n\n* M2: breaks down todos, understands the task well, reads files first, lists a plan, then edits step by step. It detects three version drifts and proposes an alignment strategy, adds the bootstrap script, runs one round of install and startup checks. Small fixes are quick, friendly to regression runs, and it feels ready to drop into a pipeline for repeated runs. Claude: strong first pass, but cross service consistency sometimes needed repeated reminders, took more rounds, and usage cost was higher. GLM/Kimi: can get the main path working, but more likely to leave rough edges in lock files and scripts that I had to clean up.\n\n1. An online 3x3 Rubik\u2019s Cube (a small front end interaction project): rotate a layer to a target angle, buttons to choose a face, show the 3x3 color grid.\n\n* M2: To be honest, the first iteration wasn\u2019t great, major issues like text occlusion and non-functional rotation weren\u2019t addressed. The bright spot is that interaction bugs (e.g., rotation state desynchronization) could be fixed in a single pass once pointed out, without introducing new regressions. After subsequent rounds of refinement, the final result actually became the most usable and presentable, fully supporting 3D dragging. GLM/Kimi: The first round results were decent, but both ran into problems in the second round. GLM didn\u2019t resolve the Rubik\u2019s Cube floating/hover position issue, and Kimi, after the second round feedback, ended up not being three-dimensional. Claude performed excellently after the first round of prompts, with all features working normally, but even after multiple later rounds it still didn\u2019t demonstrate an understanding of a 3D cube (in the image, Claude\u2019s Rubik\u2019s Cube is flat and the view can\u2019t be rotated).\n\nMetrics echo this feel: SWE bench Verified 69.4, Terminal Bench 46.3, ArtifactsBench 66.8, BrowseComp 44.0, FinSearchComp global 65.5. It is not first in every category, but on the runnable and fixable engineering loop, the structure score looks better. From my use, the strengths are proposing a plan, checking its own work, and favoring short fast iterations that clear blockers one by one.\n\nReplace most closed model usage without sacrificing the reliability of the engineering loop. M2 is already enough and surprisingly handy. Set it as the default executor and run regressions for two days; the difference will be clear. After putting it into the pipeline, with the same budget you can run more in parallel, and you do save money.\n\n[https://huggingface.co/MiniMaxAI/MiniMax-M2](https://huggingface.co/MiniMaxAI/MiniMax-M2)\n\n[https://github.com/MiniMax-AI/MiniMax-M2](https://github.com/MiniMax-AI/MiniMax-M2)", "author_fullname": "t2_1tru10qdxk", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "is_gallery": true, "title": "Experience with the new model MiniMax M2 and some cost saving tips", "link_flair_richtext": [{"e": "text", "t": "Discussion"}], "subreddit_name_prefixed": "r/LocalLLaMA", "hidden": false, "pwls": 6, "link_flair_css_class": "", "downs": 0, "thumbnail_height": 140, "top_awarded_type": null, "hide_score": false, "media_metadata": {"ls7fq7qnxmxf1": {"status": "valid", "e": "Image", "m": "image/png", "p": [{"y": 111, "x": 108, "u": "https://preview.redd.it/ls7fq7qnxmxf1.png?width=108&amp;crop=smart&amp;auto=webp&amp;s=2c2aca655b4077d095822bf157e3e40d74285802"}, {"y": 223, "x": 216, "u": "https://preview.redd.it/ls7fq7qnxmxf1.png?width=216&amp;crop=smart&amp;auto=webp&amp;s=7a674e052bd016f0c505d0ccc71bfe2f608b8301"}, {"y": 330, "x": 320, "u": "https://preview.redd.it/ls7fq7qnxmxf1.png?width=320&amp;crop=smart&amp;auto=webp&amp;s=06f9d3a5c2edcd89b929bbaa5c07cb5b443d69d1"}, {"y": 661, "x": 640, "u": "https://preview.redd.it/ls7fq7qnxmxf1.png?width=640&amp;crop=smart&amp;auto=webp&amp;s=d0ca90e54bcd95b30ba385b684a75c86cf0a4a42"}, {"y": 992, "x": 960, "u": "https://preview.redd.it/ls7fq7qnxmxf1.png?width=960&amp;crop=smart&amp;auto=webp&amp;s=fa21a4ddf04288a04637ed361ede27cf966afdd1"}, {"y": 1116, "x": 1080, "u": "https://preview.redd.it/ls7fq7qnxmxf1.png?width=1080&amp;crop=smart&amp;auto=webp&amp;s=de1ff7757763d1e8ef4ab4833468e091c9edbe6a"}], "s": {"y": 4085, "x": 3951, "u": "https://preview.redd.it/ls7fq7qnxmxf1.png?width=3951&amp;format=png&amp;auto=webp&amp;s=91fb9e690c0e2a94a4a8cb199cc0839463f44c57"}, "id": "ls7fq7qnxmxf1"}, "i6bzz7qnxmxf1": {"status": "valid", "e": "Image", "m": "image/png", "p": [{"y": 39, "x": 108, "u": "https://preview.redd.it/i6bzz7qnxmxf1.png?width=108&amp;crop=smart&amp;auto=webp&amp;s=d843c3d8b79ea6480ae0ca9d468b12aa9142f8ba"}, {"y": 79, "x": 216, "u": "https://preview.redd.it/i6bzz7qnxmxf1.png?width=216&amp;crop=smart&amp;auto=webp&amp;s=9e66f3123555f087bf1767d54aff8ad3d2fd099e"}, {"y": 117, "x": 320, "u": "https://preview.redd.it/i6bzz7qnxmxf1.png?width=320&amp;crop=smart&amp;auto=webp&amp;s=37e8aa3af75698ffdc2e7df3ebd134505137b719"}, {"y": 234, "x": 640, "u": "https://preview.redd.it/i6bzz7qnxmxf1.png?width=640&amp;crop=smart&amp;auto=webp&amp;s=3cd1887721c0da6fbeea83a3f2a700ddac5be20e"}, {"y": 351, "x": 960, "u": "https://preview.redd.it/i6bzz7qnxmxf1.png?width=960&amp;crop=smart&amp;auto=webp&amp;s=603ca202a571e8ce618b6c47c8a9882e78aa071a"}, {"y": 395, "x": 1080, "u": "https://preview.redd.it/i6bzz7qnxmxf1.png?width=1080&amp;crop=smart&amp;auto=webp&amp;s=7575cd00e471555794ff20dbcf68793372e1d175"}], "s": {"y": 970, "x": 2646, "u": "https://preview.redd.it/i6bzz7qnxmxf1.png?width=2646&amp;format=png&amp;auto=webp&amp;s=183d501ebb36f078e928484d24a716b7a54ef0b6"}, "id": "i6bzz7qnxmxf1"}}, "name": "t3_1ohbcu1", "quarantine": false, "link_flair_text_color": "light", "upvote_ratio": 0.97, "author_flair_background_color": null, "ups": 131, "domain": "reddit.com", "media_embed": {}, "thumbnail_width": 140, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "gallery_data": {"items": [{"media_id": "ls7fq7qnxmxf1", "id": 780855369}, {"media_id": "i6bzz7qnxmxf1", "id": 780855370}]}, "link_flair_text": "Discussion", "can_mod_post": false, "score": 131, "approved_by": null, "is_created_from_ads_ui": false, "author_premium": false, "thumbnail": "https://b.thumbs.redditmedia.com/UVUhaaqNSDCk6qFXVB2lhPVQVQLnJtZQw5XfM0IrY1I.jpg", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "subreddit_type": "public", "created": 1761562841.0, "link_flair_type": "richtext", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "total_awards_received": 0, "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;I saw the discussion about MiniMax M2 in the group chat a couple of days ago, and since their API and agent are free to use, I thought I\u2019d test it out. First, the conclusion: in my own use, M2 delivers better than expected efficiency and stability. You can feel the team has pushed the model\u2019s strengths close to top closed models. In some scenarios it reaches top results at clearly lower cost, so it fits as the default executor, with closed models kept for final polish when needed.&lt;/p&gt;\n\n&lt;p&gt;My comparison across models:&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;A three service monorepo dependency and lock file mess (Node.js + Express). The three services used different versions of jsonwebtoken and had lock file conflicts. The goal was to unify versions, upgrade jwt.verify from callback to Promise, and add an npm run bootstrap script for one click dependency setup and alignment.&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;ul&gt;\n&lt;li&gt;M2: breaks down todos, understands the task well, reads files first, lists a plan, then edits step by step. It detects three version drifts and proposes an alignment strategy, adds the bootstrap script, runs one round of install and startup checks. Small fixes are quick, friendly to regression runs, and it feels ready to drop into a pipeline for repeated runs. Claude: strong first pass, but cross service consistency sometimes needed repeated reminders, took more rounds, and usage cost was higher. GLM/Kimi: can get the main path working, but more likely to leave rough edges in lock files and scripts that I had to clean up.&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;ol&gt;\n&lt;li&gt;An online 3x3 Rubik\u2019s Cube (a small front end interaction project): rotate a layer to a target angle, buttons to choose a face, show the 3x3 color grid.&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;ul&gt;\n&lt;li&gt;M2: To be honest, the first iteration wasn\u2019t great, major issues like text occlusion and non-functional rotation weren\u2019t addressed. The bright spot is that interaction bugs (e.g., rotation state desynchronization) could be fixed in a single pass once pointed out, without introducing new regressions. After subsequent rounds of refinement, the final result actually became the most usable and presentable, fully supporting 3D dragging. GLM/Kimi: The first round results were decent, but both ran into problems in the second round. GLM didn\u2019t resolve the Rubik\u2019s Cube floating/hover position issue, and Kimi, after the second round feedback, ended up not being three-dimensional. Claude performed excellently after the first round of prompts, with all features working normally, but even after multiple later rounds it still didn\u2019t demonstrate an understanding of a 3D cube (in the image, Claude\u2019s Rubik\u2019s Cube is flat and the view can\u2019t be rotated).&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;Metrics echo this feel: SWE bench Verified 69.4, Terminal Bench 46.3, ArtifactsBench 66.8, BrowseComp 44.0, FinSearchComp global 65.5. It is not first in every category, but on the runnable and fixable engineering loop, the structure score looks better. From my use, the strengths are proposing a plan, checking its own work, and favoring short fast iterations that clear blockers one by one.&lt;/p&gt;\n\n&lt;p&gt;Replace most closed model usage without sacrificing the reliability of the engineering loop. M2 is already enough and surprisingly handy. Set it as the default executor and run regressions for two days; the difference will be clear. After putting it into the pipeline, with the same budget you can run more in parallel, and you do save money.&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"https://huggingface.co/MiniMaxAI/MiniMax-M2\"&gt;https://huggingface.co/MiniMaxAI/MiniMax-M2&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"https://github.com/MiniMax-AI/MiniMax-M2\"&gt;https://github.com/MiniMax-AI/MiniMax-M2&lt;/a&gt;&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "url_overridden_by_dest": "https://www.reddit.com/gallery/1ohbcu1", "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "link_flair_template_id": "5f921ea4-c7bc-11ed-9c23-3a00622979b4", "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "mod_note": null, "distinguished": null, "subreddit_id": "t5_81eyvm", "author_is_blocked": false, "mod_reason_by": null, "num_reports": null, "removal_reason": null, "link_flair_background_color": "#646d73", "id": "1ohbcu1", "is_robot_indexable": true, "report_reasons": null, "author": "thalacque", "discussion_type": null, "num_comments": 56, "send_replies": true, "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/LocalLLaMA/comments/1ohbcu1/experience_with_the_new_model_minimax_m2_and_some/", "stickied": false, "url": "https://www.reddit.com/gallery/1ohbcu1", "subreddit_subscribers": 636710, "created_utc": 1761562841.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "ExperiencedDevs", "selftext": "Is it dead in the sense of _profitable-but-braindead_? It feels like there's zero trace of product or customer focus. Curious what the culture is like.\n\nBeen using their product for the last year and frankly pretty underwhelmed. Tons of obvious little UI improvements that haven't been made; several weird outages/bugs in the management console; the deploy CLI was totally broken when I first tried to use it (by a recent Auth0 platform update that hadn't been coordinated); found an out-of-spec OIDC bug (months ago and still not fixed); overall it seems less feature-rich than some of the open source options like Keycloak; docs are often very out of date, in particular having been written _before_ the Okta merger; the embarrassing [jwt.io flub](https://github.com/jsonwebtoken/jsonwebtoken.github.io/issues/723); etc.", "author_fullname": "t2_6gxx428z", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "Is Auth0 dead/coasting? What's the work environment?", "link_flair_richtext": [], "subreddit_name_prefixed": "r/ExperiencedDevs", "hidden": false, "pwls": 6, "link_flair_css_class": null, "downs": 0, "thumbnail_height": null, "top_awarded_type": null, "hide_score": false, "name": "t3_1j89fe5", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.87, "author_flair_background_color": null, "subreddit_type": "public", "ups": 78, "total_awards_received": 0, "media_embed": {}, "thumbnail_width": null, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": null, "can_mod_post": false, "score": 78, "approved_by": null, "is_created_from_ads_ui": false, "author_premium": false, "thumbnail": "self", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "post_hint": "self", "content_categories": null, "is_self": true, "mod_note": null, "created": 1741640773.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.ExperiencedDevs", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Is it dead in the sense of &lt;em&gt;profitable-but-braindead&lt;/em&gt;? It feels like there&amp;#39;s zero trace of product or customer focus. Curious what the culture is like.&lt;/p&gt;\n\n&lt;p&gt;Been using their product for the last year and frankly pretty underwhelmed. Tons of obvious little UI improvements that haven&amp;#39;t been made; several weird outages/bugs in the management console; the deploy CLI was totally broken when I first tried to use it (by a recent Auth0 platform update that hadn&amp;#39;t been coordinated); found an out-of-spec OIDC bug (months ago and still not fixed); overall it seems less feature-rich than some of the open source options like Keycloak; docs are often very out of date, in particular having been written &lt;em&gt;before&lt;/em&gt; the Okta merger; the embarrassing &lt;a href=\"https://github.com/jsonwebtoken/jsonwebtoken.github.io/issues/723\"&gt;jwt.io flub&lt;/a&gt;; etc.&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "preview": {"images": [{"source": {"url": "https://external-preview.redd.it/3-3u98-Q5GcZ4KExnL_6syxhfyx9gDQkcAUdv0M_68E.jpg?auto=webp&amp;s=2e5f4d5203a6f16121951fec93637eaae60e92bd", "width": 1200, "height": 600}, "resolutions": [{"url": "https://external-preview.redd.it/3-3u98-Q5GcZ4KExnL_6syxhfyx9gDQkcAUdv0M_68E.jpg?width=108&amp;crop=smart&amp;auto=webp&amp;s=9e97593af94b3d9b296550ecc9959606d94c7e2e", "width": 108, "height": 54}, {"url": "https://external-preview.redd.it/3-3u98-Q5GcZ4KExnL_6syxhfyx9gDQkcAUdv0M_68E.jpg?width=216&amp;crop=smart&amp;auto=webp&amp;s=8c9ac9148617aeaab713c04f4757043d70220a9e", "width": 216, "height": 108}, {"url": "https://external-preview.redd.it/3-3u98-Q5GcZ4KExnL_6syxhfyx9gDQkcAUdv0M_68E.jpg?width=320&amp;crop=smart&amp;auto=webp&amp;s=68619c223f1e31fb4d61d7a58f929be154f05d63", "width": 320, "height": 160}, {"url": "https://external-preview.redd.it/3-3u98-Q5GcZ4KExnL_6syxhfyx9gDQkcAUdv0M_68E.jpg?width=640&amp;crop=smart&amp;auto=webp&amp;s=e509ebc997c8ecac7f74a4da4c923bf4e4996dba", "width": 640, "height": 320}, {"url": "https://external-preview.redd.it/3-3u98-Q5GcZ4KExnL_6syxhfyx9gDQkcAUdv0M_68E.jpg?width=960&amp;crop=smart&amp;auto=webp&amp;s=4c08ae592b520e2497bfae19488088d8514d8b48", "width": 960, "height": 480}, {"url": "https://external-preview.redd.it/3-3u98-Q5GcZ4KExnL_6syxhfyx9gDQkcAUdv0M_68E.jpg?width=1080&amp;crop=smart&amp;auto=webp&amp;s=b5eaa0a12d1fb3c88fc968aa0d5a08595b79d27a", "width": 1080, "height": 540}], "variants": {}, "id": "k81ZRWduFuvLtB0-LYmNqPRhick1sVwcljkQ2oRcj6Q"}], "enabled": false}, "all_awardings": [], "awarders": [], "media_only": false, "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_e0gez", "author_is_blocked": false, "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "", "id": "1j89fe5", "is_robot_indexable": true, "report_reasons": null, "author": "rwusana", "discussion_type": null, "num_comments": 50, "send_replies": true, "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/ExperiencedDevs/comments/1j89fe5/is_auth0_deadcoasting_whats_the_work_environment/", "stickied": false, "url": "https://www.reddit.com/r/ExperiencedDevs/comments/1j89fe5/is_auth0_deadcoasting_whats_the_work_environment/", "subreddit_subscribers": 367304, "created_utc": 1741640773.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "ErgoMechKeyboards", "selftext": "New keycaps for my Corne and Otemu Silent Peaches. Also printing another case because I'm going 3x5 using the Miryoku layout.", "author_fullname": "t2_1jvs7mr8ms", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "is_gallery": true, "title": "Fluorescent Key Caps for my Corne!", "link_flair_richtext": [], "subreddit_name_prefixed": "r/ErgoMechKeyboards", "hidden": false, "pwls": 6, "link_flair_css_class": "", "downs": 0, "thumbnail_height": 140, "top_awarded_type": null, "hide_score": false, "media_metadata": {"j5rah7mgdmlf1": {"status": "valid", "e": "Image", "m": "image/jpg", "p": [{"y": 81, "x": 108, "u": "https://preview.redd.it/j5rah7mgdmlf1.jpg?width=108&amp;crop=smart&amp;auto=webp&amp;s=03d7549125c5d7839ba0a4151a979031adc7be04"}, {"y": 162, "x": 216, "u": "https://preview.redd.it/j5rah7mgdmlf1.jpg?width=216&amp;crop=smart&amp;auto=webp&amp;s=7077b505d9298074ae6d8eb5139a02a36c618ab6"}, {"y": 240, "x": 320, "u": "https://preview.redd.it/j5rah7mgdmlf1.jpg?width=320&amp;crop=smart&amp;auto=webp&amp;s=22a386ccf8162314d061f90739c5a45bb3b725b8"}, {"y": 480, "x": 640, "u": "https://preview.redd.it/j5rah7mgdmlf1.jpg?width=640&amp;crop=smart&amp;auto=webp&amp;s=16d308ff9ad96843f4080f5692890b37204480f6"}, {"y": 720, "x": 960, "u": "https://preview.redd.it/j5rah7mgdmlf1.jpg?width=960&amp;crop=smart&amp;auto=webp&amp;s=d92db3f7c884dbbd79a36c0b168c332429b4be53"}, {"y": 810, "x": 1080, "u": "https://preview.redd.it/j5rah7mgdmlf1.jpg?width=1080&amp;crop=smart&amp;auto=webp&amp;s=49422bf3ba1c00309ff07af5728a076394411031"}], "s": {"y": 3000, "x": 4000, "u": "https://preview.redd.it/j5rah7mgdmlf1.jpg?width=4000&amp;format=pjpg&amp;auto=webp&amp;s=15dfc561f9dfba7f5b63f18771cade487801710f"}, "id": "j5rah7mgdmlf1"}, "ubndvohgdmlf1": {"status": "valid", "e": "Image", "m": "image/jpg", "p": [{"y": 144, "x": 108, "u": "https://preview.redd.it/ubndvohgdmlf1.jpg?width=108&amp;crop=smart&amp;auto=webp&amp;s=9e40820669acd7d053fe036dc9fe2dc6f4dea8f3"}, {"y": 288, "x": 216, "u": "https://preview.redd.it/ubndvohgdmlf1.jpg?width=216&amp;crop=smart&amp;auto=webp&amp;s=e6f10782775b5e379acd0548309dab27a620baea"}, {"y": 426, "x": 320, "u": "https://preview.redd.it/ubndvohgdmlf1.jpg?width=320&amp;crop=smart&amp;auto=webp&amp;s=e5a9809be007246d94eddb61a5bab67cba092fc4"}, {"y": 853, "x": 640, "u": "https://preview.redd.it/ubndvohgdmlf1.jpg?width=640&amp;crop=smart&amp;auto=webp&amp;s=0b8e92f0087c0edc1a5a962870a2732ea8d57783"}, {"y": 1280, "x": 960, "u": "https://preview.redd.it/ubndvohgdmlf1.jpg?width=960&amp;crop=smart&amp;auto=webp&amp;s=9172a768d0a4f050c2ffe04d49313a238e9bed63"}, {"y": 1440, "x": 1080, "u": "https://preview.redd.it/ubndvohgdmlf1.jpg?width=1080&amp;crop=smart&amp;auto=webp&amp;s=a558d7135065666bbb05c4cddc176bdf8925147d"}], "s": {"y": 4000, "x": 3000, "u": "https://preview.redd.it/ubndvohgdmlf1.jpg?width=3000&amp;format=pjpg&amp;auto=webp&amp;s=7f2d2d65116dfaa3b695d5739e9dd8d50380eb80"}, "id": "ubndvohgdmlf1"}, "pllqz8ugdmlf1": {"status": "valid", "e": "Image", "m": "image/jpg", "p": [{"y": 81, "x": 108, "u": "https://preview.redd.it/pllqz8ugdmlf1.jpg?width=108&amp;crop=smart&amp;auto=webp&amp;s=af3bfd6c77dc0a49008978aeb3c7d48cd2c25c06"}, {"y": 162, "x": 216, "u": "https://preview.redd.it/pllqz8ugdmlf1.jpg?width=216&amp;crop=smart&amp;auto=webp&amp;s=4c8d222e3d89dcaf59042f81a08c2a382574de70"}, {"y": 240, "x": 320, "u": "https://preview.redd.it/pllqz8ugdmlf1.jpg?width=320&amp;crop=smart&amp;auto=webp&amp;s=2108eb39b8d0a6c6a599e6e1abaf37e7f43e89c1"}, {"y": 480, "x": 640, "u": "https://preview.redd.it/pllqz8ugdmlf1.jpg?width=640&amp;crop=smart&amp;auto=webp&amp;s=6604b26551148cc66b5148db1d2a32dae8d74c8a"}, {"y": 720, "x": 960, "u": "https://preview.redd.it/pllqz8ugdmlf1.jpg?width=960&amp;crop=smart&amp;auto=webp&amp;s=40ccedc1b57b1885090f8b281048b096314875c4"}, {"y": 810, "x": 1080, "u": "https://preview.redd.it/pllqz8ugdmlf1.jpg?width=1080&amp;crop=smart&amp;auto=webp&amp;s=ed79b5192d87308af059e39f5b2330666b38af04"}], "s": {"y": 3000, "x": 4000, "u": "https://preview.redd.it/pllqz8ugdmlf1.jpg?width=4000&amp;format=pjpg&amp;auto=webp&amp;s=98f87ad893869ac30b723a8b83ff2b3e130ae87e"}, "id": "pllqz8ugdmlf1"}, "1v4xpwogdmlf1": {"status": "valid", "e": "Image", "m": "image/jpg", "p": [{"y": 81, "x": 108, "u": "https://preview.redd.it/1v4xpwogdmlf1.jpg?width=108&amp;crop=smart&amp;auto=webp&amp;s=e6334a10169d60a851dfaf154d32d37e0f08399c"}, {"y": 162, "x": 216, "u": "https://preview.redd.it/1v4xpwogdmlf1.jpg?width=216&amp;crop=smart&amp;auto=webp&amp;s=f568dfab5c3ec2923e23a737579fd3bbb80181fb"}, {"y": 240, "x": 320, "u": "https://preview.redd.it/1v4xpwogdmlf1.jpg?width=320&amp;crop=smart&amp;auto=webp&amp;s=31709a73ac09238cf12016beb80faceb25c322c2"}, {"y": 480, "x": 640, "u": "https://preview.redd.it/1v4xpwogdmlf1.jpg?width=640&amp;crop=smart&amp;auto=webp&amp;s=563e49f4e636adc17db2bef914a58756a4fa1a96"}, {"y": 720, "x": 960, "u": "https://preview.redd.it/1v4xpwogdmlf1.jpg?width=960&amp;crop=smart&amp;auto=webp&amp;s=cac7e22f48cbce98ab544058e4199bdf6ecd352a"}, {"y": 810, "x": 1080, "u": "https://preview.redd.it/1v4xpwogdmlf1.jpg?width=1080&amp;crop=smart&amp;auto=webp&amp;s=2d543240d24b3ac635bead62f8ba79b333fa8959"}], "s": {"y": 3000, "x": 4000, "u": "https://preview.redd.it/1v4xpwogdmlf1.jpg?width=4000&amp;format=pjpg&amp;auto=webp&amp;s=0b19aca973ddb54338f8669425fda7cf52294c52"}, "id": "1v4xpwogdmlf1"}, "1wa00hrgdmlf1": {"status": "valid", "e": "Image", "m": "image/jpg", "p": [{"y": 81, "x": 108, "u": "https://preview.redd.it/1wa00hrgdmlf1.jpg?width=108&amp;crop=smart&amp;auto=webp&amp;s=66dccdb0630af2d7a11a5afc1cd9d2c87fb8d6ee"}, {"y": 162, "x": 216, "u": "https://preview.redd.it/1wa00hrgdmlf1.jpg?width=216&amp;crop=smart&amp;auto=webp&amp;s=2638762ceba29a21c7d2a4de30036f4a32d57180"}, {"y": 240, "x": 320, "u": "https://preview.redd.it/1wa00hrgdmlf1.jpg?width=320&amp;crop=smart&amp;auto=webp&amp;s=6f18134be4ac63659766e3d47cdf1641998a1291"}, {"y": 480, "x": 640, "u": "https://preview.redd.it/1wa00hrgdmlf1.jpg?width=640&amp;crop=smart&amp;auto=webp&amp;s=9d2291a3e94c3dd9d8b9a68030eec86fc1e3cc3d"}, {"y": 720, "x": 960, "u": "https://preview.redd.it/1wa00hrgdmlf1.jpg?width=960&amp;crop=smart&amp;auto=webp&amp;s=bfc7fea95d5153c9eab8347a2c1b5d647d600197"}, {"y": 810, "x": 1080, "u": "https://preview.redd.it/1wa00hrgdmlf1.jpg?width=1080&amp;crop=smart&amp;auto=webp&amp;s=bf2684dcb1c2ca369932de54d9279fe40ba54865"}], "s": {"y": 3000, "x": 4000, "u": "https://preview.redd.it/1wa00hrgdmlf1.jpg?width=4000&amp;format=pjpg&amp;auto=webp&amp;s=be5b38c8f3e969f58ad0b9231f9709f96b25a7e2"}, "id": "1wa00hrgdmlf1"}}, "name": "t3_1n1rr9e", "quarantine": false, "link_flair_text_color": "dark", "upvote_ratio": 0.9, "author_flair_background_color": null, "ups": 44, "domain": "reddit.com", "media_embed": {}, "thumbnail_width": 140, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "gallery_data": {"items": [{"caption": "", "media_id": "ubndvohgdmlf1", "id": 737807223}, {"caption": "", "media_id": "j5rah7mgdmlf1", "id": 737807224}, {"caption": "", "media_id": "1v4xpwogdmlf1", "id": 737807225}, {"caption": "", "media_id": "1wa00hrgdmlf1", "id": 737807226}, {"caption": "", "media_id": "pllqz8ugdmlf1", "id": 737807227}]}, "link_flair_text": "[photo]", "can_mod_post": false, "score": 44, "approved_by": null, "is_created_from_ads_ui": false, "author_premium": false, "thumbnail": "https://b.thumbs.redditmedia.com/RTJ2ELseuTgeC3lOH316FDRbwgXK9NCFgQMDtFPMwJg.jpg", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "content_categories": null, "is_self": false, "subreddit_type": "public", "created": 1756325510.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "total_awards_received": 0, "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;New keycaps for my Corne and Otemu Silent Peaches. Also printing another case because I&amp;#39;m going 3x5 using the Miryoku layout.&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": null, "banned_at_utc": null, "url_overridden_by_dest": "https://www.reddit.com/gallery/1n1rr9e", "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "all_awardings": [], "awarders": [], "media_only": false, "link_flair_template_id": "6527f31e-a9cd-11ed-b1a3-b6f4266ae117", "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "mod_note": null, "distinguished": null, "subreddit_id": "t5_245wvw", "author_is_blocked": false, "mod_reason_by": null, "num_reports": null, "removal_reason": null, "link_flair_background_color": "#0dd3bb", "id": "1n1rr9e", "is_robot_indexable": true, "report_reasons": null, "author": "Brief-Ad-9044", "discussion_type": null, "num_comments": 8, "send_replies": true, "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/ErgoMechKeyboards/comments/1n1rr9e/fluorescent_key_caps_for_my_corne/", "stickied": false, "url": "https://www.reddit.com/gallery/1n1rr9e", "subreddit_subscribers": 92037, "created_utc": 1756325510.0, "num_crossposts": 0, "media": null, "is_video": false}}, {"kind": "t3", "data": {"approved_at_utc": null, "subreddit": "reactjs", "selftext": "Similar to my last post, I was reading a lot about OIDC and created this explanation. It's a mix of the best resources I have found with some additions and a lot of rewriting. I have added a super short summary and a code example at the end. Maybe it helps one of you :-) This is the [repo][repo-ref].\n\n# OIDC Explained\n\nLet's say John is on LinkedIn and clicks _'Login with Google_'. He is now logged in without that LinkedIn knows his password or any other sensitive data. Great! But how did that work?\n\nVia OpenID Connect (OIDC). This protocol builds on OAuth 2.0 and is the answer to above question.\n\nI will provide a super short and simple summary, a more detailed one and even a code snippet. You should know what OAuth and JWTs are because OIDC builds on them. If you're not familiar with OAuth, see my other guide [here][ref_oauth_repo].\n\n## Super Short Summary\n\n- John clicks _'Login with Google_'\n- Now the usual OAuth process takes place\n  - John authorizes us to get data about his Google profile\n    - E.g. his email, profile picture, name and user id\n- **Important**: Now Google not only sends LinkedIn the access token as specified in OAuth, **but also a JWT.**\n- LinkedIn uses the JWT for authentication in the usual way\n  - E.g. John's browser saves the JWT in the cookies and sends it along every request he makes\n  - LinkedIn receives the token, verifies it, and sees \"_ah, this is indeed John_\"\n\n## More Detailed Summary\n\nSuppose LinkedIn wants users to log in with their Google account to authenticate and retrieve profile info (e.g., name, email).\n\n1. LinkedIn sets up a Google API account and receives a client_id and a client_secret\n   - So Google knows this client id is LinkedIn\n2. John clicks '_Log in with Google_' on LinkedIn.\n3. LinkedIn redirects to Google\u2019s OIDC authorization endpoint:\n   https://accounts.google.com/o/oauth2/auth?client_id=...&amp;redirect_uri=...&amp;scope=openid%20profile%20email&amp;response_type=code\n   - As you see, LinkedIn passes client_id, redirect_id, scope and response_type as URL params\n     - **Important:** scope must include openid\n     - profile and email are optional but commonly used\n   - redirect_uri is where Google sends the response.\n4. John logs into Google\n5. Google asks: '_LinkedIn wants to access your Google Account_', John clicks '_Allow_'\n6. Google redirects to the specified redirect_uri with a one-time authorization code. For example:\n   https://linkedin.com/oidc/callback?code=one_time_code_xyz\n7. LinkedIn makes a server-to-server request to Google\n   - It passes the one-time code, client_id, and client_secret in the request body\n   - Google responds with an **access token and a JWT**\n8. **Finished.** LinkedIn now uses the JWT for authentication and can use the access token to get more info about John's Google account\n\n---\n\n**Question:**\n_Why not already send the JWT and access token in step 6?_\n\n**Answer:** To make sure that the requester is actually LinkedIn. So far, all requests to Google have come from the user's browser, with only the client_id identifying LinkedIn. Since the client_id isn't secret and could be guessed by an attacker, Google can't know for sure that it's actually LinkedIn behind this.\n\nAuthorization servers (Google in this example) use predefined URIs. So LinkedIn needs to specify predefined URIs when setting up their Google API. And if the given redirect_uri is not among the predefined ones, then Google rejects the request. See here: https://datatracker.ietf.org/doc/html/rfc6749#section-3.1.2.2\n\nAdditionally, LinkedIn includes the client_secret in the server-to-server request. This, however, is mainly intended to protect against the case that somehow intercepted the one time code, so he can't use it.\n\n## Addendum\n\nIn step 8 LinkedIn also verifies the JWT's signature and claims. Usually in OIDC we use asymmetric encryption (Google does for example) to sign the JWT. The advantage of asymmetric encryption is that the JWT can be verified by anyone by using the public key, including LinkedIn.\n\nIdeally, Google also returns a refresh token. The JWT will work as long as it's valid, for example hasn't expired. After that, the user will need to redo the above process.\n\nThe public keys are usually specified at the JSON Web Key Sets (JWKS) endpoint.\n\n## Key Additions to OAuth 2.0\n\nAs we saw, OIDC extends OAuth 2.0. This guide is incomplete, so here are just a few of the additions that I consider key additions.\n\n### ID Token\n\nThe ID token is the JWT. It contains user identity data (e.g., sub for user ID, name, email). It's signed by the IdP (Identity provider, in our case Google) and verified by the client (in our case LinkedIn). The JWT is used for authentication. Hence, while OAuth is for authorization, OIDC is authentication.\n\nDon't confuse Access Token and ID Token:\n\n- Access Token: Used to call Google APIs (e.g. to get more info about the user)\n- ID Token: Used purely for authentication (so we know the user actually is John)\n\n### Discovery Document\n\nOIDC providers like Google publish a JSON configuration at a standard URL:\n\n`https://accounts.google.com/.well-known/openid-configuration`\n\nThis lists endpoints (e.g., authorization, token, UserInfo, JWKS) and supported features (e.g., scopes). LinkedIn can fetch this dynamically to set up OIDC without hardcoding URLs.\n\n### UserInfo Endpoint\n\nOIDC standardizes a UserInfo endpoint (e.g., https://openidconnect.googleapis.com/v1/userinfo). LinkedIn can use the access token to fetch additional user data (e.g., name, picture), ensuring consistency across providers.\n\n### Nonce\n\nTo prevent replay attacks, LinkedIn includes a random nonce in the authorization request. Google embeds it in the ID token, and LinkedIn checks it matches during verification.\n\n### Security Notes\n\n- HTTPS: OIDC requires HTTPS for secure token transmission.\n\n- State Parameter: Inherited from OAuth 2.0, it prevents CSRF attacks.\n\n- JWT Verification: LinkedIn must validate JWT claims (e.g., iss, aud, exp, nonce) to ensure security.\n\n## Code Example\n\nBelow is a standalone Node.js example using Express to handle OIDC login with Google, storing user data in a SQLite database.\n\nPlease note that this is just example code and some things are missing or can be improved.\n\nI also on purpose did not use the library openid-client so less things happen \"behind the scenes\" and the entire process is more visible. In production you would want to use openid-client or a similar library.\n\nLast note, I also don't enforce HTTPS here, which in production you really really should.\n\n```javascript\nconst express = require(\"express\");\nconst axios = require(\"axios\");\nconst sqlite3 = require(\"sqlite3\").verbose();\nconst crypto = require(\"crypto\");\nconst jwt = require(\"jsonwebtoken\");\nconst session = require(\"express-session\");\nconst jwkToPem = require(\"jwk-to-pem\");\n\nconst app = express();\nconst db = new sqlite3.Database(\":memory:\");\n\n// Configure session middleware\napp.use(\n  session({\n    secret: process.env.SESSION_SECRET || \"oidc-example-secret\",\n    resave: false,\n    saveUninitialized: true,\n  })\n);\n\n// Initialize database\ndb.serialize(() =&gt; {\n  db.run(\n    \"CREATE TABLE users (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT, email TEXT)\"\n  );\n  db.run(\n    \"CREATE TABLE federated_credentials (user_id INTEGER, provider TEXT, subject TEXT, PRIMARY KEY (provider, subject))\"\n  );\n});\n\n// Configuration\nconst CLIENT_ID = process.env.OIDC_CLIENT_ID;\nconst CLIENT_SECRET = process.env.OIDC_CLIENT_SECRET;\nconst REDIRECT_URI = \"https://example.com/oidc/callback\";\nconst ISSUER_URL = \"https://accounts.google.com\";\n\n// OIDC discovery endpoints cache\nlet oidcConfig = null;\n\n// Function to fetch OIDC configuration from the discovery endpoint\nasync function fetchOIDCConfiguration() {\n  if (oidcConfig) return oidcConfig;\n\n  try {\n    const response = await axios.get(\n      `${ISSUER_URL}/.well-known/openid-configuration`\n    );\n    oidcConfig = response.data;\n    return oidcConfig;\n  } catch (error) {\n    console.error(\"Failed to fetch OIDC configuration:\", error);\n    throw error;\n  }\n}\n\n// Function to generate and verify PKCE challenge\nfunction generatePKCE() {\n  // Generate code verifier\n  const codeVerifier = crypto.randomBytes(32).toString(\"base64url\");\n\n  // Generate code challenge (SHA256 hash of verifier, base64url encoded)\n  const codeChallenge = crypto\n    .createHash(\"sha256\")\n    .update(codeVerifier)\n    .digest(\"base64\")\n    .replace(/\\+/g, \"-\")\n    .replace(/\\//g, \"_\")\n    .replace(/=/g, \"\");\n\n  return { codeVerifier, codeChallenge };\n}\n\n// Function to fetch JWKS\nasync function fetchJWKS() {\n  const config = await fetchOIDCConfiguration();\n  const response = await axios.get(config.jwks_uri);\n  return response.data.keys;\n}\n\n// Function to verify ID token\nasync function verifyIdToken(idToken) {\n  // First, decode the header without verification to get the key ID (kid)\n  const header = JSON.parse(\n    Buffer.from(idToken.split(\".\")[0], \"base64url\").toString()\n  );\n\n  // Fetch JWKS and find the correct key\n  const jwks = await fetchJWKS();\n  const signingKey = jwks.find((key) =&gt; key.kid === header.kid);\n\n  if (!signingKey) {\n    throw new Error(\"Unable to find signing key\");\n  }\n\n  // Format key for JWT verification\n  const publicKey = jwkToPem(signingKey);\n\n  return new Promise((resolve, reject) =&gt; {\n    jwt.verify(\n      idToken,\n      publicKey,\n      {\n        algorithms: [signingKey.alg],\n        audience: CLIENT_ID,\n        issuer: ISSUER_URL,\n      },\n      (err, decoded) =&gt; {\n        if (err) return reject(err);\n        resolve(decoded);\n      }\n    );\n  });\n}\n\n// OIDC login route\napp.get(\"/login\", async (req, res) =&gt; {\n  try {\n    // Fetch OIDC configuration\n    const config = await fetchOIDCConfiguration();\n\n    // Generate state for CSRF protection\n    const state = crypto.randomBytes(16).toString(\"hex\");\n    req.session.state = state;\n\n    // Generate nonce for replay protection\n    const nonce = crypto.randomBytes(16).toString(\"hex\");\n    req.session.nonce = nonce;\n\n    // Generate PKCE code verifier and challenge\n    const { codeVerifier, codeChallenge } = generatePKCE();\n    req.session.codeVerifier = codeVerifier;\n\n    // Build authorization URL\n    const authUrl = new URL(config.authorization_endpoint);\n    authUrl.searchParams.append(\"client_id\", CLIENT_ID);\n    authUrl.searchParams.append(\"redirect_uri\", REDIRECT_URI);\n    authUrl.searchParams.append(\"response_type\", \"code\");\n    authUrl.searchParams.append(\"scope\", \"openid profile email\");\n    authUrl.searchParams.append(\"state\", state);\n    authUrl.searchParams.append(\"nonce\", nonce);\n    authUrl.searchParams.append(\"code_challenge\", codeChallenge);\n    authUrl.searchParams.append(\"code_challenge_method\", \"S256\");\n\n    res.redirect(authUrl.toString());\n  } catch (error) {\n    console.error(\"Login initialization error:\", error);\n    res.status(500).send(\"Failed to initialize login\");\n  }\n});\n\n// OIDC callback route\napp.get(\"/oidc/callback\", async (req, res) =&gt; {\n  const { code, state } = req.query;\n  const { codeVerifier, state: storedState, nonce: storedNonce } = req.session;\n\n  // Verify state\n  if (state !== storedState) {\n    return res.status(403).send(\"Invalid state parameter\");\n  }\n\n  try {\n    // Fetch OIDC configuration\n    const config = await fetchOIDCConfiguration();\n\n    // Exchange code for tokens\n    const tokenResponse = await axios.post(\n      config.token_endpoint,\n      new URLSearchParams({\n        grant_type: \"authorization_code\",\n        client_id: CLIENT_ID,\n        client_secret: CLIENT_SECRET,\n        code,\n        redirect_uri: REDIRECT_URI,\n        code_verifier: codeVerifier,\n      }),\n      {\n        headers: {\n          \"Content-Type\": \"application/x-www-form-urlencoded\",\n        },\n      }\n    );\n\n    const { id_token, access_token } = tokenResponse.data;\n\n    // Verify ID token\n    const claims = await verifyIdToken(id_token);\n\n    // Verify nonce\n    if (claims.nonce !== storedNonce) {\n      return res.status(403).send(\"Invalid nonce\");\n    }\n\n    // Extract user info from ID token\n    const { sub: subject, name, email } = claims;\n\n    // If we need more user info, we can fetch it from the userinfo endpoint\n    // const userInfoResponse = await axios.get(config.userinfo_endpoint, {\n    //   headers: { Authorization: `Bearer ${access_token}` }\n    // });\n    // const userInfo = userInfoResponse.data;\n\n    // Check if user exists in federated_credentials\n    db.get(\n      \"SELECT * FROM federated_credentials WHERE provider = ? AND subject = ?\",\n      [ISSUER_URL, subject],\n      (err, cred) =&gt; {\n        if (err) return res.status(500).send(\"Database error\");\n\n        if (!cred) {\n          // New user: create account\n          db.run(\n            \"INSERT INTO users (name, email) VALUES (?, ?)\",\n            [name, email],\n            function (err) {\n              if (err) return res.status(500).send(\"Database error\");\n\n              const userId = this.lastID;\n              db.run(\n                \"INSERT INTO federated_credentials (user_id, provider, subject) VALUES (?, ?, ?)\",\n                [userId, ISSUER_URL, subject],\n                (err) =&gt; {\n                  if (err) return res.status(500).send(\"Database error\");\n\n                  // Store user info in session\n                  req.session.user = { id: userId, name, email };\n                  res.send(`Logged in as ${name} (${email})`);\n                }\n              );\n            }\n          );\n        } else {\n          // Existing user: fetch and log in\n          db.get(\n            \"SELECT * FROM users WHERE id = ?\",\n            [cred.user_id],\n            (err, user) =&gt; {\n              if (err || !user) return res.status(500).send(\"Database error\");\n\n              // Store user info in session\n              req.session.user = {\n                id: user.id,\n                name: user.name,\n                email: user.email,\n              };\n              res.send(`Logged in as ${user.name} (${user.email})`);\n            }\n          );\n        }\n      }\n    );\n  } catch (error) {\n    console.error(\"OIDC callback error:\", error);\n    res.status(500).send(\"OIDC authentication error\");\n  }\n});\n\n// User info endpoint (requires authentication)\napp.get(\"/userinfo\", (req, res) =&gt; {\n  if (!req.session.user) {\n    return res.status(401).send(\"Not authenticated\");\n  }\n  res.json(req.session.user);\n});\n\n// Logout endpoint\napp.get(\"/logout\", async (req, res) =&gt; {\n  try {\n    // Fetch OIDC configuration to get end session endpoint\n    const config = await fetchOIDCConfiguration();\n    let logoutUrl;\n\n    if (config.end_session_endpoint) {\n      logoutUrl = new URL(config.end_session_endpoint);\n      logoutUrl.searchParams.append(\"client_id\", CLIENT_ID);\n      logoutUrl.searchParams.append(\n        \"post_logout_redirect_uri\",\n        \"https://example.com\"\n      );\n    }\n\n    // Clear the session\n    req.session.destroy(() =&gt; {\n      if (logoutUrl) {\n        res.redirect(logoutUrl.toString());\n      } else {\n        res.redirect(\"/\");\n      }\n    });\n  } catch (error) {\n    console.error(\"Logout error:\", error);\n\n    // Even if there's an error fetching the config,\n    // still clear the session and redirect\n    req.session.destroy(() =&gt; {\n      res.redirect(\"/\");\n    });\n  }\n});\n\napp.listen(3000, () =&gt; console.log(\"Server running on port 3000\"));\n```\n\n### License\n\nMIT\n\n[repo-ref]: https://github.com/LukasNiessen/oidc-explained\n[ref_oauth_repo]: https://github.com/LukasNiessen/oauth-explained\n", "author_fullname": "t2_7tlomxnm", "saved": false, "mod_reason_title": null, "gilded": 0, "clicked": false, "title": "How does OIDC work: ELI5", "link_flair_richtext": [], "subreddit_name_prefixed": "r/reactjs", "hidden": false, "pwls": 6, "link_flair_css_class": "link-flair-resource", "downs": 0, "thumbnail_height": null, "top_awarded_type": null, "hide_score": false, "name": "t3_1k643mt", "quarantine": false, "link_flair_text_color": null, "upvote_ratio": 0.88, "author_flair_background_color": null, "subreddit_type": "public", "ups": 44, "total_awards_received": 0, "media_embed": {}, "thumbnail_width": null, "author_flair_template_id": null, "is_original_content": false, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "is_meta": false, "category": null, "secure_media_embed": {}, "link_flair_text": "Resource", "can_mod_post": false, "score": 44, "approved_by": null, "is_created_from_ads_ui": false, "author_premium": false, "thumbnail": "self", "edited": false, "author_flair_css_class": null, "author_flair_richtext": [], "gildings": {}, "post_hint": "self", "content_categories": null, "is_self": true, "mod_note": null, "created": 1745427126.0, "link_flair_type": "text", "wls": 6, "removed_by_category": null, "banned_by": null, "author_flair_type": "text", "domain": "self.reactjs", "allow_live_comments": false, "selftext_html": "&lt;!-- SC_OFF --&gt;&lt;div class=\"md\"&gt;&lt;p&gt;Similar to my last post, I was reading a lot about OIDC and created this explanation. It&amp;#39;s a mix of the best resources I have found with some additions and a lot of rewriting. I have added a super short summary and a code example at the end. Maybe it helps one of you :-) This is the &lt;a href=\"https://github.com/LukasNiessen/oidc-explained\"&gt;repo&lt;/a&gt;.&lt;/p&gt;\n\n&lt;h1&gt;OIDC Explained&lt;/h1&gt;\n\n&lt;p&gt;Let&amp;#39;s say John is on LinkedIn and clicks &lt;em&gt;&amp;#39;Login with Google&lt;/em&gt;&amp;#39;. He is now logged in without that LinkedIn knows his password or any other sensitive data. Great! But how did that work?&lt;/p&gt;\n\n&lt;p&gt;Via OpenID Connect (OIDC). This protocol builds on OAuth 2.0 and is the answer to above question.&lt;/p&gt;\n\n&lt;p&gt;I will provide a super short and simple summary, a more detailed one and even a code snippet. You should know what OAuth and JWTs are because OIDC builds on them. If you&amp;#39;re not familiar with OAuth, see my other guide &lt;a href=\"https://github.com/LukasNiessen/oauth-explained\"&gt;here&lt;/a&gt;.&lt;/p&gt;\n\n&lt;h2&gt;Super Short Summary&lt;/h2&gt;\n\n&lt;ul&gt;\n&lt;li&gt;John clicks &lt;em&gt;&amp;#39;Login with Google&lt;/em&gt;&amp;#39;&lt;/li&gt;\n&lt;li&gt;Now the usual OAuth process takes place\n\n&lt;ul&gt;\n&lt;li&gt;John authorizes us to get data about his Google profile&lt;/li&gt;\n&lt;li&gt;E.g. his email, profile picture, name and user id&lt;/li&gt;\n&lt;/ul&gt;&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;Important&lt;/strong&gt;: Now Google not only sends LinkedIn the access token as specified in OAuth, &lt;strong&gt;but also a JWT.&lt;/strong&gt;&lt;/li&gt;\n&lt;li&gt;LinkedIn uses the JWT for authentication in the usual way\n\n&lt;ul&gt;\n&lt;li&gt;E.g. John&amp;#39;s browser saves the JWT in the cookies and sends it along every request he makes&lt;/li&gt;\n&lt;li&gt;LinkedIn receives the token, verifies it, and sees &amp;quot;&lt;em&gt;ah, this is indeed John&lt;/em&gt;&amp;quot;&lt;/li&gt;\n&lt;/ul&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;h2&gt;More Detailed Summary&lt;/h2&gt;\n\n&lt;p&gt;Suppose LinkedIn wants users to log in with their Google account to authenticate and retrieve profile info (e.g., name, email).&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;LinkedIn sets up a Google API account and receives a client_id and a client_secret\n\n&lt;ul&gt;\n&lt;li&gt;So Google knows this client id is LinkedIn&lt;/li&gt;\n&lt;/ul&gt;&lt;/li&gt;\n&lt;li&gt;John clicks &amp;#39;&lt;em&gt;Log in with Google&lt;/em&gt;&amp;#39; on LinkedIn.&lt;/li&gt;\n&lt;li&gt;LinkedIn redirects to Google\u2019s OIDC authorization endpoint:\n&lt;a href=\"https://accounts.google.com/o/oauth2/auth?client_id=...&amp;amp;redirect_uri=...&amp;amp;scope=openid%20profile%20email&amp;amp;response_type=code\"&gt;https://accounts.google.com/o/oauth2/auth?client_id=...&amp;amp;redirect_uri=...&amp;amp;scope=openid%20profile%20email&amp;amp;response_type=code&lt;/a&gt;\n\n&lt;ul&gt;\n&lt;li&gt;As you see, LinkedIn passes client_id, redirect_id, scope and response_type as URL params\n\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;Important:&lt;/strong&gt; scope must include openid&lt;/li&gt;\n&lt;li&gt;profile and email are optional but commonly used&lt;/li&gt;\n&lt;/ul&gt;&lt;/li&gt;\n&lt;li&gt;redirect_uri is where Google sends the response.&lt;/li&gt;\n&lt;/ul&gt;&lt;/li&gt;\n&lt;li&gt;John logs into Google&lt;/li&gt;\n&lt;li&gt;Google asks: &amp;#39;&lt;em&gt;LinkedIn wants to access your Google Account&lt;/em&gt;&amp;#39;, John clicks &amp;#39;&lt;em&gt;Allow&lt;/em&gt;&amp;#39;&lt;/li&gt;\n&lt;li&gt;Google redirects to the specified redirect_uri with a one-time authorization code. For example:\n&lt;a href=\"https://linkedin.com/oidc/callback?code=one_time_code_xyz\"&gt;https://linkedin.com/oidc/callback?code=one_time_code_xyz&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;LinkedIn makes a server-to-server request to Google\n\n&lt;ul&gt;\n&lt;li&gt;It passes the one-time code, client_id, and client_secret in the request body&lt;/li&gt;\n&lt;li&gt;Google responds with an &lt;strong&gt;access token and a JWT&lt;/strong&gt;&lt;/li&gt;\n&lt;/ul&gt;&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;Finished.&lt;/strong&gt; LinkedIn now uses the JWT for authentication and can use the access token to get more info about John&amp;#39;s Google account&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;hr/&gt;\n\n&lt;p&gt;&lt;strong&gt;Question:&lt;/strong&gt;\n&lt;em&gt;Why not already send the JWT and access token in step 6?&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;Answer:&lt;/strong&gt; To make sure that the requester is actually LinkedIn. So far, all requests to Google have come from the user&amp;#39;s browser, with only the client_id identifying LinkedIn. Since the client_id isn&amp;#39;t secret and could be guessed by an attacker, Google can&amp;#39;t know for sure that it&amp;#39;s actually LinkedIn behind this.&lt;/p&gt;\n\n&lt;p&gt;Authorization servers (Google in this example) use predefined URIs. So LinkedIn needs to specify predefined URIs when setting up their Google API. And if the given redirect_uri is not among the predefined ones, then Google rejects the request. See here: &lt;a href=\"https://datatracker.ietf.org/doc/html/rfc6749#section-3.1.2.2\"&gt;https://datatracker.ietf.org/doc/html/rfc6749#section-3.1.2.2&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;Additionally, LinkedIn includes the client_secret in the server-to-server request. This, however, is mainly intended to protect against the case that somehow intercepted the one time code, so he can&amp;#39;t use it.&lt;/p&gt;\n\n&lt;h2&gt;Addendum&lt;/h2&gt;\n\n&lt;p&gt;In step 8 LinkedIn also verifies the JWT&amp;#39;s signature and claims. Usually in OIDC we use asymmetric encryption (Google does for example) to sign the JWT. The advantage of asymmetric encryption is that the JWT can be verified by anyone by using the public key, including LinkedIn.&lt;/p&gt;\n\n&lt;p&gt;Ideally, Google also returns a refresh token. The JWT will work as long as it&amp;#39;s valid, for example hasn&amp;#39;t expired. After that, the user will need to redo the above process.&lt;/p&gt;\n\n&lt;p&gt;The public keys are usually specified at the JSON Web Key Sets (JWKS) endpoint.&lt;/p&gt;\n\n&lt;h2&gt;Key Additions to OAuth 2.0&lt;/h2&gt;\n\n&lt;p&gt;As we saw, OIDC extends OAuth 2.0. This guide is incomplete, so here are just a few of the additions that I consider key additions.&lt;/p&gt;\n\n&lt;h3&gt;ID Token&lt;/h3&gt;\n\n&lt;p&gt;The ID token is the JWT. It contains user identity data (e.g., sub for user ID, name, email). It&amp;#39;s signed by the IdP (Identity provider, in our case Google) and verified by the client (in our case LinkedIn). The JWT is used for authentication. Hence, while OAuth is for authorization, OIDC is authentication.&lt;/p&gt;\n\n&lt;p&gt;Don&amp;#39;t confuse Access Token and ID Token:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;Access Token: Used to call Google APIs (e.g. to get more info about the user)&lt;/li&gt;\n&lt;li&gt;ID Token: Used purely for authentication (so we know the user actually is John)&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;h3&gt;Discovery Document&lt;/h3&gt;\n\n&lt;p&gt;OIDC providers like Google publish a JSON configuration at a standard URL:&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;https://accounts.google.com/.well-known/openid-configuration&lt;/code&gt;&lt;/p&gt;\n\n&lt;p&gt;This lists endpoints (e.g., authorization, token, UserInfo, JWKS) and supported features (e.g., scopes). LinkedIn can fetch this dynamically to set up OIDC without hardcoding URLs.&lt;/p&gt;\n\n&lt;h3&gt;UserInfo Endpoint&lt;/h3&gt;\n\n&lt;p&gt;OIDC standardizes a UserInfo endpoint (e.g., &lt;a href=\"https://openidconnect.googleapis.com/v1/userinfo\"&gt;https://openidconnect.googleapis.com/v1/userinfo&lt;/a&gt;). LinkedIn can use the access token to fetch additional user data (e.g., name, picture), ensuring consistency across providers.&lt;/p&gt;\n\n&lt;h3&gt;Nonce&lt;/h3&gt;\n\n&lt;p&gt;To prevent replay attacks, LinkedIn includes a random nonce in the authorization request. Google embeds it in the ID token, and LinkedIn checks it matches during verification.&lt;/p&gt;\n\n&lt;h3&gt;Security Notes&lt;/h3&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;HTTPS: OIDC requires HTTPS for secure token transmission.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;State Parameter: Inherited from OAuth 2.0, it prevents CSRF attacks.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;JWT Verification: LinkedIn must validate JWT claims (e.g., iss, aud, exp, nonce) to ensure security.&lt;/p&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;h2&gt;Code Example&lt;/h2&gt;\n\n&lt;p&gt;Below is a standalone Node.js example using Express to handle OIDC login with Google, storing user data in a SQLite database.&lt;/p&gt;\n\n&lt;p&gt;Please note that this is just example code and some things are missing or can be improved.&lt;/p&gt;\n\n&lt;p&gt;I also on purpose did not use the library openid-client so less things happen &amp;quot;behind the scenes&amp;quot; and the entire process is more visible. In production you would want to use openid-client or a similar library.&lt;/p&gt;\n\n&lt;p&gt;Last note, I also don&amp;#39;t enforce HTTPS here, which in production you really really should.&lt;/p&gt;\n\n&lt;p&gt;```javascript\nconst express = require(&amp;quot;express&amp;quot;);\nconst axios = require(&amp;quot;axios&amp;quot;);\nconst sqlite3 = require(&amp;quot;sqlite3&amp;quot;).verbose();\nconst crypto = require(&amp;quot;crypto&amp;quot;);\nconst jwt = require(&amp;quot;jsonwebtoken&amp;quot;);\nconst session = require(&amp;quot;express-session&amp;quot;);\nconst jwkToPem = require(&amp;quot;jwk-to-pem&amp;quot;);&lt;/p&gt;\n\n&lt;p&gt;const app = express();\nconst db = new sqlite3.Database(&amp;quot;:memory:&amp;quot;);&lt;/p&gt;\n\n&lt;p&gt;// Configure session middleware\napp.use(\n  session({\n    secret: process.env.SESSION_SECRET || &amp;quot;oidc-example-secret&amp;quot;,\n    resave: false,\n    saveUninitialized: true,\n  })\n);&lt;/p&gt;\n\n&lt;p&gt;// Initialize database\ndb.serialize(() =&amp;gt; {\n  db.run(\n    &amp;quot;CREATE TABLE users (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT, email TEXT)&amp;quot;\n  );\n  db.run(\n    &amp;quot;CREATE TABLE federated_credentials (user_id INTEGER, provider TEXT, subject TEXT, PRIMARY KEY (provider, subject))&amp;quot;\n  );\n});&lt;/p&gt;\n\n&lt;p&gt;// Configuration\nconst CLIENT_ID = process.env.OIDC_CLIENT_ID;\nconst CLIENT_SECRET = process.env.OIDC_CLIENT_SECRET;\nconst REDIRECT_URI = &amp;quot;&lt;a href=\"https://example.com/oidc/callback\"&gt;https://example.com/oidc/callback&lt;/a&gt;&amp;quot;;\nconst ISSUER_URL = &amp;quot;&lt;a href=\"https://accounts.google.com\"&gt;https://accounts.google.com&lt;/a&gt;&amp;quot;;&lt;/p&gt;\n\n&lt;p&gt;// OIDC discovery endpoints cache\nlet oidcConfig = null;&lt;/p&gt;\n\n&lt;p&gt;// Function to fetch OIDC configuration from the discovery endpoint\nasync function fetchOIDCConfiguration() {\n  if (oidcConfig) return oidcConfig;&lt;/p&gt;\n\n&lt;p&gt;try {\n    const response = await axios.get(\n      &lt;code&gt;${ISSUER_URL}/.well-known/openid-configuration&lt;/code&gt;\n    );\n    oidcConfig = response.data;\n    return oidcConfig;\n  } catch (error) {\n    console.error(&amp;quot;Failed to fetch OIDC configuration:&amp;quot;, error);\n    throw error;\n  }\n}&lt;/p&gt;\n\n&lt;p&gt;// Function to generate and verify PKCE challenge\nfunction generatePKCE() {\n  // Generate code verifier\n  const codeVerifier = crypto.randomBytes(32).toString(&amp;quot;base64url&amp;quot;);&lt;/p&gt;\n\n&lt;p&gt;// Generate code challenge (SHA256 hash of verifier, base64url encoded)\n  const codeChallenge = crypto\n    .createHash(&amp;quot;sha256&amp;quot;)\n    .update(codeVerifier)\n    .digest(&amp;quot;base64&amp;quot;)\n    .replace(/+/g, &amp;quot;-&amp;quot;)\n    .replace(///g, &amp;quot;_&amp;quot;)\n    .replace(/=/g, &amp;quot;&amp;quot;);&lt;/p&gt;\n\n&lt;p&gt;return { codeVerifier, codeChallenge };\n}&lt;/p&gt;\n\n&lt;p&gt;// Function to fetch JWKS\nasync function fetchJWKS() {\n  const config = await fetchOIDCConfiguration();\n  const response = await axios.get(config.jwks_uri);\n  return response.data.keys;\n}&lt;/p&gt;\n\n&lt;p&gt;// Function to verify ID token\nasync function verifyIdToken(idToken) {\n  // First, decode the header without verification to get the key ID (kid)\n  const header = JSON.parse(\n    Buffer.from(idToken.split(&amp;quot;.&amp;quot;)[0], &amp;quot;base64url&amp;quot;).toString()\n  );&lt;/p&gt;\n\n&lt;p&gt;// Fetch JWKS and find the correct key\n  const jwks = await fetchJWKS();\n  const signingKey = jwks.find((key) =&amp;gt; key.kid === header.kid);&lt;/p&gt;\n\n&lt;p&gt;if (!signingKey) {\n    throw new Error(&amp;quot;Unable to find signing key&amp;quot;);\n  }&lt;/p&gt;\n\n&lt;p&gt;// Format key for JWT verification\n  const publicKey = jwkToPem(signingKey);&lt;/p&gt;\n\n&lt;p&gt;return new Promise((resolve, reject) =&amp;gt; {\n    jwt.verify(\n      idToken,\n      publicKey,\n      {\n        algorithms: [signingKey.alg],\n        audience: CLIENT_ID,\n        issuer: ISSUER_URL,\n      },\n      (err, decoded) =&amp;gt; {\n        if (err) return reject(err);\n        resolve(decoded);\n      }\n    );\n  });\n}&lt;/p&gt;\n\n&lt;p&gt;// OIDC login route\napp.get(&amp;quot;/login&amp;quot;, async (req, res) =&amp;gt; {\n  try {\n    // Fetch OIDC configuration\n    const config = await fetchOIDCConfiguration();&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;// Generate state for CSRF protection\nconst state = crypto.randomBytes(16).toString(&amp;quot;hex&amp;quot;);\nreq.session.state = state;\n\n// Generate nonce for replay protection\nconst nonce = crypto.randomBytes(16).toString(&amp;quot;hex&amp;quot;);\nreq.session.nonce = nonce;\n\n// Generate PKCE code verifier and challenge\nconst { codeVerifier, codeChallenge } = generatePKCE();\nreq.session.codeVerifier = codeVerifier;\n\n// Build authorization URL\nconst authUrl = new URL(config.authorization_endpoint);\nauthUrl.searchParams.append(&amp;quot;client_id&amp;quot;, CLIENT_ID);\nauthUrl.searchParams.append(&amp;quot;redirect_uri&amp;quot;, REDIRECT_URI);\nauthUrl.searchParams.append(&amp;quot;response_type&amp;quot;, &amp;quot;code&amp;quot;);\nauthUrl.searchParams.append(&amp;quot;scope&amp;quot;, &amp;quot;openid profile email&amp;quot;);\nauthUrl.searchParams.append(&amp;quot;state&amp;quot;, state);\nauthUrl.searchParams.append(&amp;quot;nonce&amp;quot;, nonce);\nauthUrl.searchParams.append(&amp;quot;code_challenge&amp;quot;, codeChallenge);\nauthUrl.searchParams.append(&amp;quot;code_challenge_method&amp;quot;, &amp;quot;S256&amp;quot;);\n\nres.redirect(authUrl.toString());\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;} catch (error) {\n    console.error(&amp;quot;Login initialization error:&amp;quot;, error);\n    res.status(500).send(&amp;quot;Failed to initialize login&amp;quot;);\n  }\n});&lt;/p&gt;\n\n&lt;p&gt;// OIDC callback route\napp.get(&amp;quot;/oidc/callback&amp;quot;, async (req, res) =&amp;gt; {\n  const { code, state } = req.query;\n  const { codeVerifier, state: storedState, nonce: storedNonce } = req.session;&lt;/p&gt;\n\n&lt;p&gt;// Verify state\n  if (state !== storedState) {\n    return res.status(403).send(&amp;quot;Invalid state parameter&amp;quot;);\n  }&lt;/p&gt;\n\n&lt;p&gt;try {\n    // Fetch OIDC configuration\n    const config = await fetchOIDCConfiguration();&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;// Exchange code for tokens\nconst tokenResponse = await axios.post(\n  config.token_endpoint,\n  new URLSearchParams({\n    grant_type: &amp;quot;authorization_code&amp;quot;,\n    client_id: CLIENT_ID,\n    client_secret: CLIENT_SECRET,\n    code,\n    redirect_uri: REDIRECT_URI,\n    code_verifier: codeVerifier,\n  }),\n  {\n    headers: {\n      &amp;quot;Content-Type&amp;quot;: &amp;quot;application/x-www-form-urlencoded&amp;quot;,\n    },\n  }\n);\n\nconst { id_token, access_token } = tokenResponse.data;\n\n// Verify ID token\nconst claims = await verifyIdToken(id_token);\n\n// Verify nonce\nif (claims.nonce !== storedNonce) {\n  return res.status(403).send(&amp;quot;Invalid nonce&amp;quot;);\n}\n\n// Extract user info from ID token\nconst { sub: subject, name, email } = claims;\n\n// If we need more user info, we can fetch it from the userinfo endpoint\n// const userInfoResponse = await axios.get(config.userinfo_endpoint, {\n//   headers: { Authorization: `Bearer ${access_token}` }\n// });\n// const userInfo = userInfoResponse.data;\n\n// Check if user exists in federated_credentials\ndb.get(\n  &amp;quot;SELECT * FROM federated_credentials WHERE provider = ? AND subject = ?&amp;quot;,\n  [ISSUER_URL, subject],\n  (err, cred) =&amp;gt; {\n    if (err) return res.status(500).send(&amp;quot;Database error&amp;quot;);\n\n    if (!cred) {\n      // New user: create account\n      db.run(\n        &amp;quot;INSERT INTO users (name, email) VALUES (?, ?)&amp;quot;,\n        [name, email],\n        function (err) {\n          if (err) return res.status(500).send(&amp;quot;Database error&amp;quot;);\n\n          const userId = this.lastID;\n          db.run(\n            &amp;quot;INSERT INTO federated_credentials (user_id, provider, subject) VALUES (?, ?, ?)&amp;quot;,\n            [userId, ISSUER_URL, subject],\n            (err) =&amp;gt; {\n              if (err) return res.status(500).send(&amp;quot;Database error&amp;quot;);\n\n              // Store user info in session\n              req.session.user = { id: userId, name, email };\n              res.send(`Logged in as ${name} (${email})`);\n            }\n          );\n        }\n      );\n    } else {\n      // Existing user: fetch and log in\n      db.get(\n        &amp;quot;SELECT * FROM users WHERE id = ?&amp;quot;,\n        [cred.user_id],\n        (err, user) =&amp;gt; {\n          if (err || !user) return res.status(500).send(&amp;quot;Database error&amp;quot;);\n\n          // Store user info in session\n          req.session.user = {\n            id: user.id,\n            name: user.name,\n            email: user.email,\n          };\n          res.send(`Logged in as ${user.name} (${user.email})`);\n        }\n      );\n    }\n  }\n);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;} catch (error) {\n    console.error(&amp;quot;OIDC callback error:&amp;quot;, error);\n    res.status(500).send(&amp;quot;OIDC authentication error&amp;quot;);\n  }\n});&lt;/p&gt;\n\n&lt;p&gt;// User info endpoint (requires authentication)\napp.get(&amp;quot;/userinfo&amp;quot;, (req, res) =&amp;gt; {\n  if (!req.session.user) {\n    return res.status(401).send(&amp;quot;Not authenticated&amp;quot;);\n  }\n  res.json(req.session.user);\n});&lt;/p&gt;\n\n&lt;p&gt;// Logout endpoint\napp.get(&amp;quot;/logout&amp;quot;, async (req, res) =&amp;gt; {\n  try {\n    // Fetch OIDC configuration to get end session endpoint\n    const config = await fetchOIDCConfiguration();\n    let logoutUrl;&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;if (config.end_session_endpoint) {\n  logoutUrl = new URL(config.end_session_endpoint);\n  logoutUrl.searchParams.append(&amp;quot;client_id&amp;quot;, CLIENT_ID);\n  logoutUrl.searchParams.append(\n    &amp;quot;post_logout_redirect_uri&amp;quot;,\n    &amp;quot;https://example.com&amp;quot;\n  );\n}\n\n// Clear the session\nreq.session.destroy(() =&amp;gt; {\n  if (logoutUrl) {\n    res.redirect(logoutUrl.toString());\n  } else {\n    res.redirect(&amp;quot;/&amp;quot;);\n  }\n});\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;} catch (error) {\n    console.error(&amp;quot;Logout error:&amp;quot;, error);&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;// Even if there&amp;#39;s an error fetching the config,\n// still clear the session and redirect\nreq.session.destroy(() =&amp;gt; {\n  res.redirect(&amp;quot;/&amp;quot;);\n});\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;}\n});&lt;/p&gt;\n\n&lt;p&gt;app.listen(3000, () =&amp;gt; console.log(&amp;quot;Server running on port 3000&amp;quot;));\n```&lt;/p&gt;\n\n&lt;h3&gt;License&lt;/h3&gt;\n\n&lt;p&gt;MIT&lt;/p&gt;\n&lt;/div&gt;&lt;!-- SC_ON --&gt;", "likes": null, "suggested_sort": "confidence", "banned_at_utc": null, "view_count": null, "archived": false, "no_follow": false, "is_crosspostable": false, "pinned": false, "over_18": false, "preview": {"images": [{"source": {"url": "https://external-preview.redd.it/mEY-neN7cFRfGfS2Rx5smNCEQkvzE8ViOPxeANYrxyU.jpg?auto=webp&amp;s=429a1d8e4cd34c37868c7f0795e039f8b5824e18", "width": 1200, "height": 600}, "resolutions": [{"url": "https://external-preview.redd.it/mEY-neN7cFRfGfS2Rx5smNCEQkvzE8ViOPxeANYrxyU.jpg?width=108&amp;crop=smart&amp;auto=webp&amp;s=a4dd06f2f6f1b17aee1d322bd93a60a1ee016d1a", "width": 108, "height": 54}, {"url": "https://external-preview.redd.it/mEY-neN7cFRfGfS2Rx5smNCEQkvzE8ViOPxeANYrxyU.jpg?width=216&amp;crop=smart&amp;auto=webp&amp;s=814a2ea369a1fbe107aa02b8aa3f3839470bf270", "width": 216, "height": 108}, {"url": "https://external-preview.redd.it/mEY-neN7cFRfGfS2Rx5smNCEQkvzE8ViOPxeANYrxyU.jpg?width=320&amp;crop=smart&amp;auto=webp&amp;s=4b79fff7e2cb327ffaaa98bebbafe65ffd1c472f", "width": 320, "height": 160}, {"url": "https://external-preview.redd.it/mEY-neN7cFRfGfS2Rx5smNCEQkvzE8ViOPxeANYrxyU.jpg?width=640&amp;crop=smart&amp;auto=webp&amp;s=ea0281d37368bb1c8b1ffccfca03d97eb7feb969", "width": 640, "height": 320}, {"url": "https://external-preview.redd.it/mEY-neN7cFRfGfS2Rx5smNCEQkvzE8ViOPxeANYrxyU.jpg?width=960&amp;crop=smart&amp;auto=webp&amp;s=168e40e6f1b5a9d213a2fad3b96b411f1abbd40c", "width": 960, "height": 480}, {"url": "https://external-preview.redd.it/mEY-neN7cFRfGfS2Rx5smNCEQkvzE8ViOPxeANYrxyU.jpg?width=1080&amp;crop=smart&amp;auto=webp&amp;s=ab1b7c0876dd5a6f7c69199ef385ae102f9caa46", "width": 1080, "height": 540}], "variants": {}, "id": "XgDnPSq0lnzLL9b37CZppHK5ZoirCZbiQfzze82huTs"}], "enabled": false}, "all_awardings": [], "awarders": [], "media_only": false, "link_flair_template_id": "16439f02-8522-11e8-8849-0e66852ea1ba", "can_gild": false, "spoiler": false, "locked": false, "author_flair_text": null, "treatment_tags": [], "visited": false, "removed_by": null, "num_reports": null, "distinguished": null, "subreddit_id": "t5_2zldd", "author_is_blocked": false, "mod_reason_by": null, "removal_reason": null, "link_flair_background_color": "#ffd635", "id": "1k643mt", "is_robot_indexable": true, "report_reasons": null, "author": "trolleid", "discussion_type": null, "num_comments": 5, "send_replies": true, "contest_mode": false, "mod_reports": [], "author_patreon_flair": false, "author_flair_text_color": null, "permalink": "/r/reactjs/comments/1k643mt/how_does_oidc_work_eli5/", "stickied": false, "url": "https://www.reddit.com/r/reactjs/comments/1k643mt/how_does_oidc_work_eli5/", "subreddit_subscribers": 493651, "created_utc": 1745427126.0, "num_crossposts": 0, "media": null, "is_video": false}}], "before": null}}}