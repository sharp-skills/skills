{"d": {"exhaustive": {"nbHits": false, "typo": false}, "exhaustiveNbHits": false, "exhaustiveTypo": false, "hits": [{"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "PkLavc"}, "story_text": {"matchLevel": "none", "matchedWords": [], "value": "I\u2019m a Computer Engineering student from Brazil. I built this to showcase backend patterns that go beyond simple CRUDs: row-level multi-tenancy (Prisma), async processing (BullMQ/Redis), and observability (OpenTelemetry). Looking for feedback on the architecture!"}, "title": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["nestjs", "production"], "value": "Show HN: <em>Production</em>-Ready <em>NestJS</em> Back End (Multi-Tenancy, Event-Driven)"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://github.com/PkLavc/portfolio"}}, "_tags": ["story", "author_PkLavc", "story_46983399", "show_hn"], "author": "PkLavc", "created_at": "2026-02-12T00:41:09Z", "created_at_i": 1770856869, "num_comments": 0, "objectID": "46983399", "points": 1, "story_id": 46983399, "story_text": "I\u2019m a Computer Engineering student from Brazil. I built this to showcase backend patterns that go beyond simple CRUDs: row-level multi-tenancy (Prisma), async processing (BullMQ&#x2F;Redis), and observability (OpenTelemetry). Looking for feedback on the architecture!", "title": "Show HN: Production-Ready NestJS Back End (Multi-Tenancy, Event-Driven)", "updated_at": "2026-02-12T00:44:01Z", "url": "https://github.com/PkLavc/portfolio"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "thesssaism"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["nestjs", "production"], "value": "I recently ran an audit on our latest full-stack repo to figure out why &quot;spinning up a new project&quot; felt like such a heavy lift. I counted every file required just to reach a &quot;<em>production</em>-ready&quot; baseline\u2014before writing a single line of unique feature code.<p>The count was roughly 600 files.<p>To be clear, I'm not talking about a `create-react-app` sandbox. I mean a compliant, scalable SaaS foundation: Next.js frontend, Node.js/<em>NestJS</em> backend, mobile wrapper, CI/CD pipelines, and enough security config to pass a SOC2 audit.<p>It sounds ridiculous (and honestly, it feels ridiculous), but when I broke it down, I couldn't find many files I was willing to delete.<p>Here is where the bloat comes from:<p>First, the &quot;Configuration Hell&quot; accounts for about 40-50 files alone. We aren't just dealing with `package.json` anymore. It's `tsconfig.json` (base), `tsconfig.build.json`, `tsconfig.spec.json`... multiplied across frontend, backend, and shared libraries. Then add `.eslintrc.js`, `.prettierrc`, `jest.config.js`, `vitest.config.ts`, `nodemon.json`, and the Docker-compose variants for dev, test, and prod.<p>Then there\u2019s the DevOps and Quality layer. We have roughly 20-30 files for GitHub Actions workflows (lint, test, build, deploy, semantic release), Husky hooks (pre-commit, commit-msg), and pull request templates.<p>But the real multiplier is the separation of concerns. In a modern monorepo, a &quot;Hello World&quot; isn't just `console.log`. It\u2019s:\n- A <em>NestJS</em> module (Controller, Service, Module, DTO, Entity, Unit Test, E2E Test).\n- A Next.js slice (Page, Component, Type definition, API client wrapper).\n- A shared library entry.<p>We found that adding a single &quot;minimal&quot; API endpoint usually touches 5-7 files just to maintain architectural standards.<p>The trade-off is painful. On one hand, this setup handles the things we used to forget: security headers, proper logging, consistent error handling, and type safety across boundaries. It prevents the &quot;spaghetti code&quot; distinct to startups that scale too fast.<p>On the other hand, the cognitive load of managing a 600-file &quot;empty&quot; project is massive. Updating dependencies becomes a chore because a major version bump in one tool (like ESLint) cascades through forty config files.<p>I\u2019m curious how others are handling this &quot;starting line&quot; complexity.<p>Are you accepting the boilerplate as the cost of doing business? Or have you found a way to strip this down without sacrificing the compliance/safety guardrails that enterprise clients demand?<p>It feels like we've over-engineered the entry point of software development, but I\u2019m not sure what the alternative is for a serious project. We tried going &quot;lean&quot; initially, but spent weeks retrofitting auth and testing harnesses later\u2014which was worse.<p>Is there a middle ground I'm missing, or is ~600 files just the new normal?"}, "title": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["production"], "value": "Tell HN: A <em>production</em>-ready \"Hello World\" is now ~600 files"}}, "_tags": ["story", "author_thesssaism", "story_47074571", "ask_hn"], "author": "thesssaism", "children": [47074794, 47075001, 47075012, 47076406], "created_at": "2026-02-19T15:07:03Z", "created_at_i": 1771513623, "num_comments": 4, "objectID": "47074571", "points": 4, "story_id": 47074571, "story_text": "I recently ran an audit on our latest full-stack repo to figure out why &quot;spinning up a new project&quot; felt like such a heavy lift. I counted every file required just to reach a &quot;production-ready&quot; baseline\u2014before writing a single line of unique feature code.<p>The count was roughly 600 files.<p>To be clear, I&#x27;m not talking about a `create-react-app` sandbox. I mean a compliant, scalable SaaS foundation: Next.js frontend, Node.js&#x2F;NestJS backend, mobile wrapper, CI&#x2F;CD pipelines, and enough security config to pass a SOC2 audit.<p>It sounds ridiculous (and honestly, it feels ridiculous), but when I broke it down, I couldn&#x27;t find many files I was willing to delete.<p>Here is where the bloat comes from:<p>First, the &quot;Configuration Hell&quot; accounts for about 40-50 files alone. We aren&#x27;t just dealing with `package.json` anymore. It&#x27;s `tsconfig.json` (base), `tsconfig.build.json`, `tsconfig.spec.json`... multiplied across frontend, backend, and shared libraries. Then add `.eslintrc.js`, `.prettierrc`, `jest.config.js`, `vitest.config.ts`, `nodemon.json`, and the Docker-compose variants for dev, test, and prod.<p>Then there\u2019s the DevOps and Quality layer. We have roughly 20-30 files for GitHub Actions workflows (lint, test, build, deploy, semantic release), Husky hooks (pre-commit, commit-msg), and pull request templates.<p>But the real multiplier is the separation of concerns. In a modern monorepo, a &quot;Hello World&quot; isn&#x27;t just `console.log`. It\u2019s:\n- A NestJS module (Controller, Service, Module, DTO, Entity, Unit Test, E2E Test).\n- A Next.js slice (Page, Component, Type definition, API client wrapper).\n- A shared library entry.<p>We found that adding a single &quot;minimal&quot; API endpoint usually touches 5-7 files just to maintain architectural standards.<p>The trade-off is painful. On one hand, this setup handles the things we used to forget: security headers, proper logging, consistent error handling, and type safety across boundaries. It prevents the &quot;spaghetti code&quot; distinct to startups that scale too fast.<p>On the other hand, the cognitive load of managing a 600-file &quot;empty&quot; project is massive. Updating dependencies becomes a chore because a major version bump in one tool (like ESLint) cascades through forty config files.<p>I\u2019m curious how others are handling this &quot;starting line&quot; complexity.<p>Are you accepting the boilerplate as the cost of doing business? Or have you found a way to strip this down without sacrificing the compliance&#x2F;safety guardrails that enterprise clients demand?<p>It feels like we&#x27;ve over-engineered the entry point of software development, but I\u2019m not sure what the alternative is for a serious project. We tried going &quot;lean&quot; initially, but spent weeks retrofitting auth and testing harnesses later\u2014which was worse.<p>Is there a middle ground I&#x27;m missing, or is ~600 files just the new normal?", "title": "Tell HN: A production-ready \"Hello World\" is now ~600 files", "updated_at": "2026-02-20T00:09:42Z"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "amitverma_dev01"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["nestjs", "production"], "value": "Location: Lucknow, India\nRemote: Yes\nWilling to relocate: Yes\nTechnologies: Node.js, <em>NestJS</em>, Express.js, Go (Golang), REST APIs, PostgreSQL, MySQL, MongoDB, Prisma, Redis, Docker, AWS basics, CI/CD, React.js/Next.js, TailwindCSS, Git/GitHub\nR\u00e9sum\u00e9 / Portfolio: https://www.amitverma.me/<p>Email: amitverma.dev01@gmail.com<p>Backend-focused Full Stack Developer with experience building scalable REST APIs, authentication systems, payment flows, queue-based workers, and cloud-ready microservices. Have shipped <em>production</em> software in SaaS, AI, and EdTech, handling API design, DB architecture, performance optimization, and integrations (payments, storage, auth, analytics, etc.).<p>Looking for full-time or contract backend roles (Node/<em>NestJS</em> or Go preferred). Open to remote-first teams globally."}, "title": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["nestjs"], "value": "Ask HN: Looking for Back End Developer Roles (Node.js/<em>NestJS</em>/Go)"}}, "_tags": ["story", "author_amitverma_dev01", "story_46109088", "ask_hn"], "author": "amitverma_dev01", "children": [46109337, 46109643], "created_at": "2025-12-01T16:11:55Z", "created_at_i": 1764605515, "num_comments": 2, "objectID": "46109088", "points": 2, "story_id": 46109088, "story_text": "Location: Lucknow, India\nRemote: Yes\nWilling to relocate: Yes\nTechnologies: Node.js, NestJS, Express.js, Go (Golang), REST APIs, PostgreSQL, MySQL, MongoDB, Prisma, Redis, Docker, AWS basics, CI&#x2F;CD, React.js&#x2F;Next.js, TailwindCSS, Git&#x2F;GitHub\nR\u00e9sum\u00e9 &#x2F; Portfolio: https:&#x2F;&#x2F;www.amitverma.me&#x2F;<p>Email: amitverma.dev01@gmail.com<p>Backend-focused Full Stack Developer with experience building scalable REST APIs, authentication systems, payment flows, queue-based workers, and cloud-ready microservices. Have shipped production software in SaaS, AI, and EdTech, handling API design, DB architecture, performance optimization, and integrations (payments, storage, auth, analytics, etc.).<p>Looking for full-time or contract backend roles (Node&#x2F;NestJS or Go preferred). Open to remote-first teams globally.", "title": "Ask HN: Looking for Back End Developer Roles (Node.js/NestJS/Go)", "updated_at": "2025-12-01T22:45:54Z"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "vaultsandbox"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["nestjs", "production"], "value": "I've spent the last few months working on something I wish I'd had years ago.\nI kept running into the same issue: CI green, <em>production</em> mail broken. TLS handshake failures, DKIM alignment mismatches, SPF soft-fails ... the stuff that only surfaces when real mail servers are involved.\nMost test tools (Mailpit, MailHog) are catch-alls. They confirm &quot;an email was sent&quot; but don't validate the protocol. They also aren't designed for network-exposed environments: no auth, unprotected Web UI, easy to enumerate messages.<p>VaultSandbox is my attempt at fixing that.\nIt's a self-hosted SMTP gateway (AGPLv3) that validates SPF, DKIM, DMARC, and rDNS on every incoming message. You keep your <em>production</em> email provider (Postmark, SendGrid, SES) in tests and you just change the recipient domain. No mocking, no config changes.\nThere are client SDKs (Node, Python, Go, Java, .NET), plus a Web UI and a CLI for manual testing.<p>Some technical details:<p>Deterministic Tests\nInstead of polling or sleep loops, the SDKs use Server-Sent Events (SSE) so test assertions trigger the moment the mail hits the gateway.<p>Minimal infrastructure footprint\nBuilt with <em>NestJS</em> and Angular, with no external database dependency to keep the container footprint small and easier to reason about.<p>Post-Quantum Encryption\nI use ML-KEM-768 for the encryption layer. Incoming mail is encrypted immediately using a client-generated public key and the plaintext is discarded. The server only ever stores encrypted message data and cannot decrypt it. I chose PQ because I wanted to build something I wouldn't have to revisit in five years. If it handles large PQ keys reliably, everything else is easy.<p>Quick start:\n<a href=\"https://vaultsandbox.dev/getting-started/quickstart/\" rel=\"nofollow\">https://vaultsandbox.dev/getting-started/quickstart/</a><p>Site:\n<a href=\"https://vaultsandbox.com\" rel=\"nofollow\">https://vaultsandbox.com</a><p>I'd love feedback, especially on whether AGPLv3 would be a blocker for something you'd self-host in dev."}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Show HN: VaultSandbox \u2013 Test your real MailGun/SES/etc. integration"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://vaultsandbox.com/"}}, "_tags": ["story", "author_vaultsandbox", "story_46512203", "show_hn"], "author": "vaultsandbox", "children": [46524225, 46524784, 46526446, 46528688, 46599167], "created_at": "2026-01-06T13:50:48Z", "created_at_i": 1767707448, "num_comments": 14, "objectID": "46512203", "points": 58, "story_id": 46512203, "story_text": "I&#x27;ve spent the last few months working on something I wish I&#x27;d had years ago.\nI kept running into the same issue: CI green, production mail broken. TLS handshake failures, DKIM alignment mismatches, SPF soft-fails ... the stuff that only surfaces when real mail servers are involved.\nMost test tools (Mailpit, MailHog) are catch-alls. They confirm &quot;an email was sent&quot; but don&#x27;t validate the protocol. They also aren&#x27;t designed for network-exposed environments: no auth, unprotected Web UI, easy to enumerate messages.<p>VaultSandbox is my attempt at fixing that.\nIt&#x27;s a self-hosted SMTP gateway (AGPLv3) that validates SPF, DKIM, DMARC, and rDNS on every incoming message. You keep your production email provider (Postmark, SendGrid, SES) in tests and you just change the recipient domain. No mocking, no config changes.\nThere are client SDKs (Node, Python, Go, Java, .NET), plus a Web UI and a CLI for manual testing.<p>Some technical details:<p>Deterministic Tests\nInstead of polling or sleep loops, the SDKs use Server-Sent Events (SSE) so test assertions trigger the moment the mail hits the gateway.<p>Minimal infrastructure footprint\nBuilt with NestJS and Angular, with no external database dependency to keep the container footprint small and easier to reason about.<p>Post-Quantum Encryption\nI use ML-KEM-768 for the encryption layer. Incoming mail is encrypted immediately using a client-generated public key and the plaintext is discarded. The server only ever stores encrypted message data and cannot decrypt it. I chose PQ because I wanted to build something I wouldn&#x27;t have to revisit in five years. If it handles large PQ keys reliably, everything else is easy.<p>Quick start:\n<a href=\"https:&#x2F;&#x2F;vaultsandbox.dev&#x2F;getting-started&#x2F;quickstart&#x2F;\" rel=\"nofollow\">https:&#x2F;&#x2F;vaultsandbox.dev&#x2F;getting-started&#x2F;quickstart&#x2F;</a><p>Site:\n<a href=\"https:&#x2F;&#x2F;vaultsandbox.com\" rel=\"nofollow\">https:&#x2F;&#x2F;vaultsandbox.com</a><p>I&#x27;d love feedback, especially on whether AGPLv3 would be a blocker for something you&#x27;d self-host in dev.", "title": "Show HN: VaultSandbox \u2013 Test your real MailGun/SES/etc. integration", "updated_at": "2026-01-18T07:47:53Z", "url": "https://vaultsandbox.com/"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "itssimon"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["nestjs", "production"], "value": "G\u2019day Hacker News, I\u2019m Simon Gurcke, the sole founder of Apitally (<a href=\"https://apitally.io\" rel=\"nofollow\">https://apitally.io</a>).<p>I\u2019m building a simple API monitoring and analytics tool for Python / Node.js apps. It helps users understand API usage and performance, spot issues early and troubleshoot effectively when something goes wrong.<p>Features include:<p>- <i>Dashboards:</i> Provide insights into API traffic, errors, performance and consumers.<p>- <i>Request logging:</i> Opt-in and highly configurable in terms of what data is logged. Users can drill down from aggregated metrics to individual requests (proven to be super helpful when troubleshooting issues).<p>- <i>Custom alerts:</i> Based on 14 different API metrics with notifications delivered via email, Slack or Microsoft Teams.<p>- <i>Validation error tracking:</i> Captures metrics about which fields failed validation and why. Works for web frameworks with built-in validation (e.g. FastAPI with pydantic), or that integrate with popular third-party validation libraries (e.g. Zod for Hono).<p>- <i>Server error tracking:</i> Captures exception details and stack traces for 500 error responses. An integration with the Sentry SDK also captures event IDs, allowing users to click through to the relevant Sentry issue for more context.<p>I first started developing Apitally to scratch my own itch. While working at a health tech company where I was responsible for API-based software products, I became frustrated with the monitoring tools we had in place - Datadog and the ELK stack. They were too complex for my API-centric use cases, and often a pain to use.<p>As a result, I focused on making Apitally as simple as possible. This involved not just refining the UX of the dashboard, but also optimizing the developer experience with the open-source SDKs:<p>- <a href=\"https://github.com/apitally/apitally-py\">https://github.com/apitally/apitally-py</a> - Python SDK (supports FastAPI, Flask, Django, Litestar, Starlette)<p>- <a href=\"https://github.com/apitally/apitally-js\">https://github.com/apitally/apitally-js</a> - Node.js SDK (supports Express, <em>NestJS</em>, Fastify, Koa, Hono)<p>My other focus was on data privacy, as that is a strict requirement in the healthcare industry. By default, Apitally doesn\u2019t capture any sensitive data - metrics are aggregated on the client side (similar to Prometheus) and sent in the background in regular intervals.<p>The hardest part has been implementing integrations for various web frameworks and supporting a wide range of versions. I learned a lot about the inner workings of web frameworks in the process. Good test coverage and an extensive test matrix were really important to not break people\u2019s <em>production</em> APIs with buggy middleware.<p>Apitally\u2019s backend is built in Python and runs on a small Kubernetes cluster on DigitalOcean. It uses PostgreSQL and ClickHouse to store data and NATS JetStream as a message queue. I chose NATS for being lightweight and its exactly-once processing capabilities. I\u2019m also impressed by ClickHouse\u2019s performance given the low hardware specs of my server (4 vCPUs, 8 GB RAM).<p>Apitally is free to use for small hobby projects (with limitations), and I offer two paid tiers for $39 and $119 (USD) per month. The dashboard has a demo mode, allowing people to explore the product without having to set up their own app first.<p>Thank you for reading about my bootstrapped indie product. Please let me know your thoughts and questions in the comments."}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Show HN: Apitally \u2013 A simple, privacy-focused API monitoring and analytics tool"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://apitally.io"}}, "_tags": ["story", "author_itssimon", "story_42915435", "show_hn"], "author": "itssimon", "children": [42915477, 42915683, 42929740, 42949349, 42949483, 42959486, 42960715], "created_at": "2025-02-03T06:07:00Z", "created_at_i": 1738562820, "num_comments": 21, "objectID": "42915435", "points": 46, "story_id": 42915435, "story_text": "G\u2019day Hacker News, I\u2019m Simon Gurcke, the sole founder of Apitally (<a href=\"https:&#x2F;&#x2F;apitally.io\" rel=\"nofollow\">https:&#x2F;&#x2F;apitally.io</a>).<p>I\u2019m building a simple API monitoring and analytics tool for Python &#x2F; Node.js apps. It helps users understand API usage and performance, spot issues early and troubleshoot effectively when something goes wrong.<p>Features include:<p>- <i>Dashboards:</i> Provide insights into API traffic, errors, performance and consumers.<p>- <i>Request logging:</i> Opt-in and highly configurable in terms of what data is logged. Users can drill down from aggregated metrics to individual requests (proven to be super helpful when troubleshooting issues).<p>- <i>Custom alerts:</i> Based on 14 different API metrics with notifications delivered via email, Slack or Microsoft Teams.<p>- <i>Validation error tracking:</i> Captures metrics about which fields failed validation and why. Works for web frameworks with built-in validation (e.g. FastAPI with pydantic), or that integrate with popular third-party validation libraries (e.g. Zod for Hono).<p>- <i>Server error tracking:</i> Captures exception details and stack traces for 500 error responses. An integration with the Sentry SDK also captures event IDs, allowing users to click through to the relevant Sentry issue for more context.<p>I first started developing Apitally to scratch my own itch. While working at a health tech company where I was responsible for API-based software products, I became frustrated with the monitoring tools we had in place - Datadog and the ELK stack. They were too complex for my API-centric use cases, and often a pain to use.<p>As a result, I focused on making Apitally as simple as possible. This involved not just refining the UX of the dashboard, but also optimizing the developer experience with the open-source SDKs:<p>- <a href=\"https:&#x2F;&#x2F;github.com&#x2F;apitally&#x2F;apitally-py\">https:&#x2F;&#x2F;github.com&#x2F;apitally&#x2F;apitally-py</a> - Python SDK (supports FastAPI, Flask, Django, Litestar, Starlette)<p>- <a href=\"https:&#x2F;&#x2F;github.com&#x2F;apitally&#x2F;apitally-js\">https:&#x2F;&#x2F;github.com&#x2F;apitally&#x2F;apitally-js</a> - Node.js SDK (supports Express, NestJS, Fastify, Koa, Hono)<p>My other focus was on data privacy, as that is a strict requirement in the healthcare industry. By default, Apitally doesn\u2019t capture any sensitive data - metrics are aggregated on the client side (similar to Prometheus) and sent in the background in regular intervals.<p>The hardest part has been implementing integrations for various web frameworks and supporting a wide range of versions. I learned a lot about the inner workings of web frameworks in the process. Good test coverage and an extensive test matrix were really important to not break people\u2019s production APIs with buggy middleware.<p>Apitally\u2019s backend is built in Python and runs on a small Kubernetes cluster on DigitalOcean. It uses PostgreSQL and ClickHouse to store data and NATS JetStream as a message queue. I chose NATS for being lightweight and its exactly-once processing capabilities. I\u2019m also impressed by ClickHouse\u2019s performance given the low hardware specs of my server (4 vCPUs, 8 GB RAM).<p>Apitally is free to use for small hobby projects (with limitations), and I offer two paid tiers for $39 and $119 (USD) per month. The dashboard has a demo mode, allowing people to explore the product without having to set up their own app first.<p>Thank you for reading about my bootstrapped indie product. Please let me know your thoughts and questions in the comments.", "title": "Show HN: Apitally \u2013 A simple, privacy-focused API monitoring and analytics tool", "updated_at": "2025-11-19T05:50:23Z", "url": "https://apitally.io"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "dhrey112"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["nestjs", "production"], "value": "Hi HN,<p>I built VeriMed while working on an AI-powered telemedicine platform. I quickly realised that verifying whether a healthcare provider is legitimately licensed is surprisingly hard.<p>Every country has a different registry, a different API format (REST, SOAP, FHIR), and different access requirements. I couldn't find a unified solution, so I built one.<p>VeriMed:\n- Connects to 5 national medical registries:\n  - USA (NPI)\n  - France (RPPS)\n  - UAE (DHA)\n  - Netherlands (BIG)\n  - Israel (MOH)\n- Falls back to AI document verification when registries aren't available\n- Uses fuzzy name matching to handle variations (e.g., &quot;Greg&quot; vs &quot;Gregory&quot;)\n- <em>Production</em>-ready with Docker, Kubernetes manifests, and health checks\n- MIT licensed, free to self-host\n- Enterprise extension available:\n  - SSO (SAML 2.0 &amp; OIDC)\n  - RBAC (Admin, Reviewer, Viewer)\n  - Audit Dashboard &amp; CSV Export\n  - Bulk CSV Import Wrapper<p>Tech stack: <em>NestJS</em>, TypeORM, OpenAI (optional), Fuse.js<p>GitHub: <a href=\"https://github.com/daretechie/verimed\" rel=\"nofollow\">https://github.com/daretechie/verimed</a><p>I'd love feedback on the architecture or suggestions for additional country adapters to prioritise."}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Show HN: VeriMed \u2013 open-source medical license verification"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://github.com/daretechie/verimed"}}, "_tags": ["story", "author_dhrey112", "story_46366409", "show_hn"], "author": "dhrey112", "created_at": "2025-12-23T16:05:04Z", "created_at_i": 1766505904, "num_comments": 0, "objectID": "46366409", "points": 4, "story_id": 46366409, "story_text": "Hi HN,<p>I built VeriMed while working on an AI-powered telemedicine platform. I quickly realised that verifying whether a healthcare provider is legitimately licensed is surprisingly hard.<p>Every country has a different registry, a different API format (REST, SOAP, FHIR), and different access requirements. I couldn&#x27;t find a unified solution, so I built one.<p>VeriMed:\n- Connects to 5 national medical registries:\n  - USA (NPI)\n  - France (RPPS)\n  - UAE (DHA)\n  - Netherlands (BIG)\n  - Israel (MOH)\n- Falls back to AI document verification when registries aren&#x27;t available\n- Uses fuzzy name matching to handle variations (e.g., &quot;Greg&quot; vs &quot;Gregory&quot;)\n- Production-ready with Docker, Kubernetes manifests, and health checks\n- MIT licensed, free to self-host\n- Enterprise extension available:\n  - SSO (SAML 2.0 &amp; OIDC)\n  - RBAC (Admin, Reviewer, Viewer)\n  - Audit Dashboard &amp; CSV Export\n  - Bulk CSV Import Wrapper<p>Tech stack: NestJS, TypeORM, OpenAI (optional), Fuse.js<p>GitHub: <a href=\"https:&#x2F;&#x2F;github.com&#x2F;daretechie&#x2F;verimed\" rel=\"nofollow\">https:&#x2F;&#x2F;github.com&#x2F;daretechie&#x2F;verimed</a><p>I&#x27;d love feedback on the architecture or suggestions for additional country adapters to prioritise.", "title": "Show HN: VeriMed \u2013 open-source medical license verification", "updated_at": "2025-12-23T17:34:36Z", "url": "https://github.com/daretechie/verimed"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "albator39"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["nestjs", "production"], "value": "I spent 4 years trying to build this OAuth server but never finished it.<p>Then I discovered agentic coding and shipped it in 3 weeks.<p>What makes it different:<p>\u2022 Dual AI agents analyze every login in &lt;300ms\n  - Security Signals Agent: risk scoring (device, IP, geo, velocity)\n  - Policy Compliance Agent: business rules (MFA policies, role enforcement)\n  - Combined decision: allow/log/step-up/lock/deny<p>\u2022 <em>Production</em>-ready security\n  - PKCE (RFC 7636), DPoP (RFC 9449)\n  - MFA (TOTP + WebAuthn/Passkeys)\n  - IP restrictions, rate limiting, audit trail<p>\u2022 EU digital sovereignty\n  - GDPR native (data export, legal holds, retention policies)\n  - EU hosting, no US Cloud Act exposure\n  - Full audit trail (PostgreSQL + Redis Streams)<p>\u2022 Zero AI dependency\n  - Deterministic fallback if AI timeouts\n  - Conservative MEDIUM risk returned (safe default)\n  - System keeps running without external LLM calls<p>\u2022 Modern stack\n  - Backend: <em>NestJS</em> + TypeScript, LangChain/LangGraph\n  - Frontend: React 19, hexagonal architecture, 91% test coverage\n  - Deterministic fallback if AI timeouts (zero dependency)<p>Built as an alternative to Firebase Auth / AWS Cognito / Auth0 for companies that want control over their authentication infrastructure.<p>Architecture diagrams and screenshots in the repo.<p>Open to feedback and questions."}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Show HN: OAuth 2.0 server with AI security agents (EU sovereign alternative)"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://github.com/devon39/server-oauth-security"}}, "_tags": ["story", "author_albator39", "story_46867821", "show_hn"], "author": "albator39", "created_at": "2026-02-03T07:44:41Z", "created_at_i": 1770104681, "num_comments": 0, "objectID": "46867821", "points": 2, "story_id": 46867821, "story_text": "I spent 4 years trying to build this OAuth server but never finished it.<p>Then I discovered agentic coding and shipped it in 3 weeks.<p>What makes it different:<p>\u2022 Dual AI agents analyze every login in &lt;300ms\n  - Security Signals Agent: risk scoring (device, IP, geo, velocity)\n  - Policy Compliance Agent: business rules (MFA policies, role enforcement)\n  - Combined decision: allow&#x2F;log&#x2F;step-up&#x2F;lock&#x2F;deny<p>\u2022 Production-ready security\n  - PKCE (RFC 7636), DPoP (RFC 9449)\n  - MFA (TOTP + WebAuthn&#x2F;Passkeys)\n  - IP restrictions, rate limiting, audit trail<p>\u2022 EU digital sovereignty\n  - GDPR native (data export, legal holds, retention policies)\n  - EU hosting, no US Cloud Act exposure\n  - Full audit trail (PostgreSQL + Redis Streams)<p>\u2022 Zero AI dependency\n  - Deterministic fallback if AI timeouts\n  - Conservative MEDIUM risk returned (safe default)\n  - System keeps running without external LLM calls<p>\u2022 Modern stack\n  - Backend: NestJS + TypeScript, LangChain&#x2F;LangGraph\n  - Frontend: React 19, hexagonal architecture, 91% test coverage\n  - Deterministic fallback if AI timeouts (zero dependency)<p>Built as an alternative to Firebase Auth &#x2F; AWS Cognito &#x2F; Auth0 for companies that want control over their authentication infrastructure.<p>Architecture diagrams and screenshots in the repo.<p>Open to feedback and questions.", "title": "Show HN: OAuth 2.0 server with AI security agents (EU sovereign alternative)", "updated_at": "2026-02-04T08:54:40Z", "url": "https://github.com/devon39/server-oauth-security"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "narubrown"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["nestjs", "production"], "value": "Hello Hacker News \u2014 greetings from South Korea \nI\u2019m a backend engineer working primarily with Go, and I\u2019d like to share a framework I\u2019ve been building to solve a problem I\u2019ve repeatedly encountered in <em>production</em> systems.<p>In my day-to-day work, our backend is built on top of Echo. Echo is fast and reliable as an HTTP transport, but its high level of freedom leaves architectural decisions almost entirely to individual developers. Over time, this led to a system where execution flow and responsibility boundaries varied depending on who last touched a feature. Maintenance became difficult not because the code was incorrect, but because how requests actually executed was no longer obvious.<p>I looked for a Go framework that could provide a clear execution model and structural constraints, similar to what Spring or <em>NestJS</em> offer. I couldn\u2019t find one that fit. Moving to Spring or <em>NestJS</em> would also mean giving up some of Go\u2019s strengths\u2014simplicity, performance, and explicit control\u2014so I decided to build one instead.<p>Spine is an execution-centric backend framework for Go.\nIt aims to provide enterprise-grade structure while deliberately avoiding hidden magic.<p>What Spine provides\n \u2022 An IoC container with explicit, constructor-based dependency injection\n \u2022 Interceptors with well-defined execution phases (before, after, completion)\n \u2022 First-class support for both HTTP requests and event-driven execution\n \u2022 No annotations, no implicit behavior, no convention-driven wiring<p>The core idea: execution first<p>The key difference is Spine\u2019s execution model.<p>Every request\u2014HTTP or event\u2014flows through a single, explicit Pipeline.\nThe Pipeline is the only component that determines execution order.\nActual method calls are handled by a separate Invoker, keeping execution control and invocation strictly separated.<p>Because of this structure:\n \u2022 Execution order is explainable by reading the code\n \u2022 Cross-cutting concerns live in the execution flow, not inside controllers\n \u2022 Controllers express use cases only, not orchestration logic\n \u2022 You can understand request handling by looking at main.go<p>This design trades some convenience for clarity. In return, it offers stronger control as the system grows in size and complexity.<p>My goal with Spine isn\u2019t just to add another framework to the Go ecosystem, but to start a conversation:\nHow much execution flow do modern web frameworks hide, and when does that become a maintenance cost?<p>The framework itself is currently written in Korean.\nIf English support or internationalization is important to you, feel free to open an issue\u2014I plan to prioritize it based on community interest.<p>You can find more details, a basic HTTP example, and a simple Kafka-based MSA demo here:\nRepository: <a href=\"https://github.com/NARUBROWN/spine\" rel=\"nofollow\">https://github.com/NARUBROWN/spine</a><p>Thanks for reading. I\u2019d really appreciate your feedback."}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Show HN: Spine \u2013 an execution-centric backend framework for Go"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://spine.na2ru2.me/en/"}}, "_tags": ["story", "author_narubrown", "story_46759959", "show_hn"], "author": "narubrown", "created_at": "2026-01-25T23:51:33Z", "created_at_i": 1769385093, "num_comments": 0, "objectID": "46759959", "points": 2, "story_id": 46759959, "story_text": "Hello Hacker News \u2014 greetings from South Korea \nI\u2019m a backend engineer working primarily with Go, and I\u2019d like to share a framework I\u2019ve been building to solve a problem I\u2019ve repeatedly encountered in production systems.<p>In my day-to-day work, our backend is built on top of Echo. Echo is fast and reliable as an HTTP transport, but its high level of freedom leaves architectural decisions almost entirely to individual developers. Over time, this led to a system where execution flow and responsibility boundaries varied depending on who last touched a feature. Maintenance became difficult not because the code was incorrect, but because how requests actually executed was no longer obvious.<p>I looked for a Go framework that could provide a clear execution model and structural constraints, similar to what Spring or NestJS offer. I couldn\u2019t find one that fit. Moving to Spring or NestJS would also mean giving up some of Go\u2019s strengths\u2014simplicity, performance, and explicit control\u2014so I decided to build one instead.<p>Spine is an execution-centric backend framework for Go.\nIt aims to provide enterprise-grade structure while deliberately avoiding hidden magic.<p>What Spine provides\n \u2022 An IoC container with explicit, constructor-based dependency injection\n \u2022 Interceptors with well-defined execution phases (before, after, completion)\n \u2022 First-class support for both HTTP requests and event-driven execution\n \u2022 No annotations, no implicit behavior, no convention-driven wiring<p>The core idea: execution first<p>The key difference is Spine\u2019s execution model.<p>Every request\u2014HTTP or event\u2014flows through a single, explicit Pipeline.\nThe Pipeline is the only component that determines execution order.\nActual method calls are handled by a separate Invoker, keeping execution control and invocation strictly separated.<p>Because of this structure:\n \u2022 Execution order is explainable by reading the code\n \u2022 Cross-cutting concerns live in the execution flow, not inside controllers\n \u2022 Controllers express use cases only, not orchestration logic\n \u2022 You can understand request handling by looking at main.go<p>This design trades some convenience for clarity. In return, it offers stronger control as the system grows in size and complexity.<p>My goal with Spine isn\u2019t just to add another framework to the Go ecosystem, but to start a conversation:\nHow much execution flow do modern web frameworks hide, and when does that become a maintenance cost?<p>The framework itself is currently written in Korean.\nIf English support or internationalization is important to you, feel free to open an issue\u2014I plan to prioritize it based on community interest.<p>You can find more details, a basic HTTP example, and a simple Kafka-based MSA demo here:\nRepository: <a href=\"https:&#x2F;&#x2F;github.com&#x2F;NARUBROWN&#x2F;spine\" rel=\"nofollow\">https:&#x2F;&#x2F;github.com&#x2F;NARUBROWN&#x2F;spine</a><p>Thanks for reading. I\u2019d really appreciate your feedback.", "title": "Show HN: Spine \u2013 an execution-centric backend framework for Go", "updated_at": "2026-01-26T00:24:37Z", "url": "https://spine.na2ru2.me/en/"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "krish_kant"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["nestjs", "production"], "value": "Hi HN,<p>We built Supercheck \u2013 an open source platform that combines test automation and uptime monitoring in one self-hosted solution.<p>*The Problem:*\nMost monitoring tools are expensive SaaS products that charge per check. Test automation and monitoring are often separate concerns, using different tools and workflows. We wanted a unified platform where you can write a Playwright test once and use it for both CI/CD testing and <em>production</em> monitoring and use same tool for k6 performance tests too.<p>*What Supercheck Does:*<p>Testing:\n- Playwright browser tests (UI/E2E) with screenshots, traces, videos\n- API tests (HTTP/GraphQL)\n- Database tests (PostgreSQL, MySQL)\n- k6 performance tests\n- Schedule tests via cron or trigger from CI/CD<p>Monitoring:\n- HTTP, Website, Ping, Port monitors\n- Synthetic monitors (run full Playwright tests on a schedule)\n- Multi-region: US East, EU Central, Asia Pacific\n- Threshold-based alerting (consecutive failures before alerting)<p>Extras:\n- AI Create: Generate tests from plain English\n- AI Fix: Automatically analyze failures and suggest fixes\n- Public status pages with incident management\n- Alerts: Slack, Discord, Telegram, Email, Teams, webhooks\n- RBAC with 6 permission levels\n- Browser extensions: Chrome + Edge<p>*Architecture:*\nNext.js frontend, <em>NestJS</em> workers, PostgreSQL, Redis + BullMQ for job queuing, MinIO for artifacts. Each browser test runs in an isolated Playwright context. Workers are stateless \u2013 scale horizontally by adding more containers.<p>*Deploy:*\n```bash\ngit clone <a href=\"https://github.com/supercheck-io/supercheck\" rel=\"nofollow\">https://github.com/supercheck-io/supercheck</a>\ncd supercheck/deploy/docker\n./init-secrets.sh\ndocker compose -f docker-compose.yml up -d\n```<p>One-click deployment with Coolify.<p>*Links:*\n- GitHub: <a href=\"https://github.com/supercheck-io/supercheck\" rel=\"nofollow\">https://github.com/supercheck-io/supercheck</a>\n- Docs: <a href=\"https://supercheck.io/docs\" rel=\"nofollow\">https://supercheck.io/docs</a><p>Happy to answer any questions about the architecture, design decisions, or roadmap."}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Show HN: Supercheck.io \u2013 Open-Source AI-Powered Test Automation and Monitoring"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://supercheck.io/"}}, "_tags": ["story", "author_krish_kant", "story_46801564", "show_hn"], "author": "krish_kant", "children": [46808857], "created_at": "2026-01-28T21:10:46Z", "created_at_i": 1769634646, "num_comments": 1, "objectID": "46801564", "points": 1, "story_id": 46801564, "story_text": "Hi HN,<p>We built Supercheck \u2013 an open source platform that combines test automation and uptime monitoring in one self-hosted solution.<p>*The Problem:*\nMost monitoring tools are expensive SaaS products that charge per check. Test automation and monitoring are often separate concerns, using different tools and workflows. We wanted a unified platform where you can write a Playwright test once and use it for both CI&#x2F;CD testing and production monitoring and use same tool for k6 performance tests too.<p>*What Supercheck Does:*<p>Testing:\n- Playwright browser tests (UI&#x2F;E2E) with screenshots, traces, videos\n- API tests (HTTP&#x2F;GraphQL)\n- Database tests (PostgreSQL, MySQL)\n- k6 performance tests\n- Schedule tests via cron or trigger from CI&#x2F;CD<p>Monitoring:\n- HTTP, Website, Ping, Port monitors\n- Synthetic monitors (run full Playwright tests on a schedule)\n- Multi-region: US East, EU Central, Asia Pacific\n- Threshold-based alerting (consecutive failures before alerting)<p>Extras:\n- AI Create: Generate tests from plain English\n- AI Fix: Automatically analyze failures and suggest fixes\n- Public status pages with incident management\n- Alerts: Slack, Discord, Telegram, Email, Teams, webhooks\n- RBAC with 6 permission levels\n- Browser extensions: Chrome + Edge<p>*Architecture:*\nNext.js frontend, NestJS workers, PostgreSQL, Redis + BullMQ for job queuing, MinIO for artifacts. Each browser test runs in an isolated Playwright context. Workers are stateless \u2013 scale horizontally by adding more containers.<p>*Deploy:*\n```bash\ngit clone <a href=\"https:&#x2F;&#x2F;github.com&#x2F;supercheck-io&#x2F;supercheck\" rel=\"nofollow\">https:&#x2F;&#x2F;github.com&#x2F;supercheck-io&#x2F;supercheck</a>\ncd supercheck&#x2F;deploy&#x2F;docker\n.&#x2F;init-secrets.sh\ndocker compose -f docker-compose.yml up -d\n```<p>One-click deployment with Coolify.<p>*Links:*\n- GitHub: <a href=\"https:&#x2F;&#x2F;github.com&#x2F;supercheck-io&#x2F;supercheck\" rel=\"nofollow\">https:&#x2F;&#x2F;github.com&#x2F;supercheck-io&#x2F;supercheck</a>\n- Docs: <a href=\"https:&#x2F;&#x2F;supercheck.io&#x2F;docs\" rel=\"nofollow\">https:&#x2F;&#x2F;supercheck.io&#x2F;docs</a><p>Happy to answer any questions about the architecture, design decisions, or roadmap.", "title": "Show HN: Supercheck.io \u2013 Open-Source AI-Powered Test Automation and Monitoring", "updated_at": "2026-01-29T11:38:35Z", "url": "https://supercheck.io/"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "bamazizi"}, "title": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["nestjs", "production"], "value": "Observing <em>NextJS</em> in <em>Production</em>"}, "url": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["nestjs"], "value": "https://jake.tl/notes/2021-04-04-<em>nextjs</em>-preload-hack"}}, "_tags": ["story", "author_bamazizi", "story_30120776"], "author": "bamazizi", "children": [30121066], "created_at": "2022-01-28T21:44:43Z", "created_at_i": 1643406283, "num_comments": 1, "objectID": "30120776", "points": 2, "story_id": 30120776, "title": "Observing NextJS in Production", "updated_at": "2024-09-20T10:21:57Z", "url": "https://jake.tl/notes/2021-04-04-nextjs-preload-hack"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "arunoda"}, "title": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["production"], "value": "Live Reloading for a <em>Production</em> Next.js App"}, "url": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["nestjs", "production"], "value": "https://getstarted.sh/with/live-reloading-for-<em>production</em>-<em>nextjs</em>-app"}}, "_tags": ["story", "author_arunoda", "story_23771682"], "author": "arunoda", "children": [23772048], "created_at": "2020-07-08T16:51:37Z", "created_at_i": 1594227097, "num_comments": 2, "objectID": "23771682", "points": 24, "story_id": 23771682, "title": "Live Reloading for a Production Next.js App", "updated_at": "2024-09-20T06:36:18Z", "url": "https://getstarted.sh/with/live-reloading-for-production-nextjs-app"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "Liriel"}, "title": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["production"], "value": "How to Protect Your API Key in <em>Production</em> with Next.js API Route"}, "url": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["nestjs", "production"], "value": "https://www.smashingmagazine.com/2021/12/protect-api-key-<em>production</em>-<em>nextjs</em>-api-route/"}}, "_tags": ["story", "author_Liriel", "story_29414454"], "author": "Liriel", "children": [29414512], "created_at": "2021-12-02T10:22:27Z", "created_at_i": 1638440547, "num_comments": 1, "objectID": "29414454", "points": 2, "story_id": 29414454, "title": "How to Protect Your API Key in Production with Next.js API Route", "updated_at": "2024-09-20T09:55:05Z", "url": "https://www.smashingmagazine.com/2021/12/protect-api-key-production-nextjs-api-route/"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "mvsingh"}, "title": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["nestjs", "production"], "value": "Free visual UI builder for <em>production</em> ready <em>NextJS</em> websites(Shadcn,Framer)"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://next.appsbunny.com"}}, "_tags": ["story", "author_mvsingh", "story_43943072"], "author": "mvsingh", "created_at": "2025-05-10T03:46:39Z", "created_at_i": 1746848799, "num_comments": 0, "objectID": "43943072", "points": 1, "story_id": 43943072, "title": "Free visual UI builder for production ready NextJS websites(Shadcn,Framer)", "updated_at": "2025-05-10T03:49:34Z", "url": "https://next.appsbunny.com"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "severin"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["nestjs", "production"], "value": "Hey guys,<p>As designers and developers, we find the cost of tooling is extremely high and prevent us to iterate: Figma-to-code wall of China, impossible tech stacks, JS dependency hell, project setups more complex than a SpaceX launch.<p>We've been playing with AI since the GPT3 beta, and found out over the years the biggest obstacle between us and autonomous AI developers is not LLM science, it's this suite of software-based hurdles.<p>So we're launching Layouts, a notebook-like editor for building interfaces. \nJust open, describe your interface in a simple syntax, get a <em>production</em>-grade <em>NextJS</em> project repository. Zero setup, zero config, zero headaches.<p>It's on ProductHunt today: \nhttps://www.producthunt.com/posts/layouts-dev<p>We'd love to get your feedback!"}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Creating a notebook interface for Tailwind / shadcnUI"}}, "_tags": ["story", "author_severin", "story_41785751", "ask_hn"], "author": "severin", "children": [41786489, 41787176], "created_at": "2024-10-09T08:38:09Z", "created_at_i": 1728463089, "num_comments": 4, "objectID": "41785751", "points": 3, "story_id": 41785751, "story_text": "Hey guys,<p>As designers and developers, we find the cost of tooling is extremely high and prevent us to iterate: Figma-to-code wall of China, impossible tech stacks, JS dependency hell, project setups more complex than a SpaceX launch.<p>We&#x27;ve been playing with AI since the GPT3 beta, and found out over the years the biggest obstacle between us and autonomous AI developers is not LLM science, it&#x27;s this suite of software-based hurdles.<p>So we&#x27;re launching Layouts, a notebook-like editor for building interfaces. \nJust open, describe your interface in a simple syntax, get a production-grade NextJS project repository. Zero setup, zero config, zero headaches.<p>It&#x27;s on ProductHunt today: \nhttps:&#x2F;&#x2F;www.producthunt.com&#x2F;posts&#x2F;layouts-dev<p>We&#x27;d love to get your feedback!", "title": "Creating a notebook interface for Tailwind / shadcnUI", "updated_at": "2024-10-12T15:04:23Z"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "oeken"}, "title": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["nestjs", "production"], "value": "<em>NextJS</em> 16 broke our <em>production</em>"}, "url": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["nestjs"], "value": "https://iamoeken.com/blog/chasing-ghost-bug-<em>nextjs</em>-16"}}, "_tags": ["story", "author_oeken", "story_45891261"], "author": "oeken", "children": [45891262], "created_at": "2025-11-11T18:53:41Z", "created_at_i": 1762887221, "num_comments": 2, "objectID": "45891261", "points": 2, "story_id": 45891261, "title": "NextJS 16 broke our production", "updated_at": "2025-11-11T20:06:42Z", "url": "https://iamoeken.com/blog/chasing-ghost-bug-nextjs-16"}], "hitsPerPage": 15, "nbHits": 45, "nbPages": 3, "page": 0, "params": "query=nestjs+production&tags=story&hitsPerPage=15&advancedSyntax=true&analyticsTags=backend", "processingTimeMS": 10, "processingTimingsMS": {"_request": {"roundTrip": 24}, "afterFetch": {"format": {"highlighting": 1, "total": 1}}, "fetch": {"query": 6, "scanning": 2, "total": 9}, "total": 10}, "query": "nestjs production", "serverTimeMS": 12}}