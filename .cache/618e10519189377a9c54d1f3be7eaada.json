{"d": "# Yup\n\nYup is a schema builder for runtime value parsing and validation. Define a schema, transform a value to match, assert the shape of an existing value, or both. Yup schema are extremely expressive and allow modeling complex, interdependent validations, or value transformation.\n\n> **You are viewing docs for the v1.0.0 of yup, pre-v1 docs are available: [here](https://github.com/jquense/yup/tree/pre-v1)**\n\n**Killer Features**:\n\n- Concise yet expressive schema interface, equipped to model simple to complex data models\n- Powerful TypeScript support. Infer static types from schema, or ensure schema correctly implement a type\n- Built-in async validation support. Model server-side and client-side validation equally well\n- Extensible: add your own type-safe methods and schema\n- Rich error details, make debugging a breeze\n- Compatible with [Standard Schema](https://github.com/standard-schema/standard-schema)\n\n## Getting Started\n\nSchema are comprised of parsing actions (transforms) as well as assertions (tests) about the input value.\nValidate an input value to parse it and run the configured set of assertions. Chain together methods to build a schema.\n\n```ts\nimport { object, string, number, date, InferType } from 'yup';\n\nlet userSchema = object({\n  name: string().required(),\n  age: number().required().positive().integer(),\n  email: string().email(),\n  website: string().url().nullable(),\n  createdOn: date().default(() => new Date()),\n});\n\n// parse and assert validity\nlet user = await userSchema.validate(await fetchUser());\n\ntype User = InferType<typeof userSchema>;\n/* {\n  name: string;\n  age: number;\n  email?: string | undefined\n  website?: string | null | undefined\n  createdOn: Date\n}*/\n```\n\nUse a schema to coerce or \"cast\" an input value into the correct type, and optionally\ntransform that value into more concrete and specific values, without making further assertions.\n\n```ts\n// Attempts to coerce values to the correct type\nlet parsedUser = userSchema.cast({\n  name: 'jimmy',\n  age: '24',\n  createdOn: '2014-09-23T19:25:25Z',\n});\n// \u2705  { name: 'jimmy', age: 24, createdOn: Date }\n```\n\nKnow that your input value is already parsed? You can \"strictly\" validate an input, and avoid the overhead\nof running parsing logic.\n\n```ts\n// \u274c  ValidationError \"age is not a number\"\nlet parsedUser = await userSchema.validate(\n  {\n    name: 'jimmy',\n    age: '24',\n  },\n  { strict: true },\n);\n```\n\n## Table of Contents\n\n<!-- START doctoc generated TOC please keep comment here to allow auto update -->\n<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->\n\n- [Schema basics](#schema-basics)\n  - [Parsing: Transforms](#parsing-transforms)\n  - [Validation: Tests](#validation-tests)\n    - [Customizing errors](#customizing-errors)\n  - [Composition and Reuse](#composition-and-reuse)\n- [TypeScript integration](#typescript-integration)\n  - [Schema defaults](#schema-defaults)\n  - [Ensuring a schema matches an existing type](#ensuring-a-schema-matches-an-existing-type)\n  - [Extending built-in schema with new methods](#extending-built-in-schema-with-new-methods)\n  - [TypeScript configuration](#typescript-configuration)\n- [Error message customization](#error-message-customization)\n  - [localization and i18n](#localization-and-i18n)\n- [Standard Schema Support](#standard-schema-support)\n- [API](#api)\n  - [`yup`](#yup)\n    - [`reach(schema: Schema, path: string, value?: object, context?: object): Schema`](#reachschema-schema-path-string-value-object-context-object-schema)\n    - [`addMethod(schemaType: Schema, name: string, method: ()=> Schema): void`](#addmethodschematype-schema-name-string-method--schema-void)\n    - [`ref(path: string, options: { contextPrefix: string }): Ref`](#refpath-string-options--contextprefix-string--ref)\n    - [`lazy((value: any) => Schema): Lazy`](#lazyvalue-any--schema-lazy)\n    - [`ValidationError(errors: string | Array<string>, value: any, path: string)`](#validationerrorerrors-string--arraystring-value-any-path-string)\n  - [`Schema`](#schema)\n    - [`Schema.clone(): Schema`](#schemaclone-schema)\n    - [`Schema.label(label: string): Schema`](#schemalabellabel-string-schema)\n    - [`Schema.meta(metadata: SchemaMetadata): Schema`](#schemametametadata-schemametadata-schema)\n    - [`Schema.describe(options?: ResolveOptions): SchemaDescription`](#schemadescribeoptions-resolveoptions-schemadescription)\n    - [`Schema.concat(schema: Schema): Schema`](#schemaconcatschema-schema-schema)\n    - [`Schema.validate(value: any, options?: object): Promise<InferType<Schema>, ValidationError>`](#schemavalidatevalue-any-options-object-promiseinfertypeschema-validationerror)\n    - [`Schema.validateSync(value: any, options?: object): InferType<Schema>`](#schemavalidatesyncvalue-any-options-object-infertypeschema)\n    - [`Schema.validateAt(path: string, value: any, options?: object): Promise<InferType<Schema>, ValidationError>`](#schemavalidateatpath-string-value-any-options-object-promiseinfertypeschema-validationerror)\n    - [`Schema.validateSyncAt(path: string, value: any, options?: object): InferType<Schema>`](#schemavalidatesyncatpath-string-value-any-options-object-infertypeschema)\n    - [`Schema.isValid(value: any, options?: object): Promise<boolean>`](#schemaisvalidvalue-any-options-object-promiseboolean)\n    - [`Schema.isValidSync(value: any, options?: object): boolean`](#schemaisvalidsyncvalue-any-options-object-boolean)\n    - [`Schema.cast(value: any, options = {}): InferType<Schema>`](#schemacastvalue-any-options---infertypeschema)\n    - [`Schema.isType(value: any): value is InferType<Schema>`](#schemaistypevalue-any-value-is-infertypeschema)\n    - [`Schema.strict(enabled: boolean = false): Schema`](#schemastrictenabled-boolean--false-schema)\n    - [`Schema.strip(enabled: boolean = true): Schema`](#schemastripenabled-boolean--true-schema)\n    - [`Schema.withMutation(builder: (current: Schema) => void): void`](#schemawithmutationbuilder-current-schema--void-void)\n    - [`Schema.default(value: any): Schema`](#schemadefaultvalue-any-schema)\n    - [`Schema.getDefault(options?: object): Any`](#schemagetdefaultoptions-object-any)\n    - [`Schema.nullable(message?: string | function): Schema`](#schemanullablemessage-string--function-schema)\n    - [`Schema.nonNullable(message?: string | function): Schema`](#schemanonnullablemessage-string--function-schema)\n    - [`Schema.defined(): Schema`](#schemadefined-schema)\n    - [`Schema.optional(): Schema`](#schemaoptional-schema)\n    - [`Schema.required(message?: string | function): Schema`](#schemarequiredmessage-string--function-schema)\n    - [`Schema.notRequired(): Schema`](#schemanotrequired-schema)\n    - [`Schema.typeError(message: string): Schema`](#schematypeerrormessage-string-schema)\n    - [`Schema.oneOf(arrayOfValues: Array<any>, message?: string | function): Schema` Alias: `equals`](#schemaoneofarrayofvalues-arrayany-message-string--function-schema-alias-equals)\n    - [`Schema.notOneOf(arrayOfValues: Array<any>, message?: string | function)`](#schemanotoneofarrayofvalues-arrayany-message-string--function)\n    - [`Schema.when(keys: string | string[], builder: object | (values: any[], schema) => Schema): Schema`](#schemawhenkeys-string--string-builder-object--values-any-schema--schema-schema)\n    - [`Schema.test(name: string, message: string | function | any, test: function): Schema`](#schematestname-string-message-string--function--any-test-function-schema)\n    - [`Schema.test(options: object): Schema`](#schematestoptions-object-schema)\n    - [`Schema.transform((currentValue: any, originalValue: any, schema: Schema,  options: object) => any): Schema`](#schematransformcurrentvalue-any-originalvalue-any-schema-schema--options-object--any-schema)\n  - [mixed](#mixed)\n  - [string](#string)\n    - [`string.required(message?: string | function): Schema`](#stringrequiredmessage-string--function-schema)\n    - [`string.length(limit: number | Ref, message?: string | function): Schema`](#stringlengthlimit-number--ref-message-string--function-schema)\n    - [`string.min(limit: number | Ref, message?: string | function): Schema`](#stringminlimit-number--ref-message-string--function-schema)\n    - [`string.max(limit: number | Ref, message?: string | function): Schema`](#stringmaxlimit-number--ref-message-string--function-schema)\n    - [`string.matches(regex: Regex, message?: string | function): Schema`](#stringmatchesregex-regex-message-string--function-schema)\n    - [`string.matches(regex: Regex, options: { message: string, excludeEmptyString: bool }): Schema`](#stringmatchesregex-regex-options--message-string-excludeemptystring-bool--schema)\n    - [`string.email(message?: string | function): Schema`](#stringemailmessage-string--function-schema)\n    - [`string.url(message?: string | function): Schema`](#stringurlmessage-string--function-schema)\n    - [`string.uuid(message?: string | function): Schema`](#stringuuidmessage-string--function-schema)\n    - [`string.datetime(options?: {message?: string | function, allowOffset?: boolean, precision?: number})`](#stringdatetimeoptions-message-string--function-allowoffset-boolean-precision-number)\n    - [`string.datetime(message?: string | function)`](#stringdatetimemessage-string--function)\n    - [`string.ensure(): Schema`](#stringensure-schema)\n    - [`string.trim(message?: string | function): Schema`](#stringtrimmessage-string--function-schema)\n    - [`string.lowercase(message?: string | function): Schema`](#stringlowercasemessage-string--function-schema)\n    - [`string.uppercase(message?: string | function): Schema`](#stringuppercasemessage-string--function-schema)\n  - [number](#number)\n    - [`number.min(limit: number | Ref, message?: string | function): Schema`](#numberminlimit-number--ref-message-string--function-schema)\n    - [`number.max(limit: number | Ref, message?: string | function): Schema`](#numbermaxlimit-number--ref-message-string--function-schema)\n    - [`number.lessThan(max: number | Ref, message?: string | function): Schema`](#numberlessthanmax-number--ref-message-string--function-schema)\n    - [`number.moreThan(min: number | Ref, message?: string | function): Schema`](#numbermorethanmin-number--ref-message-string--function-schema)\n    - [`number.positive(message?: string | function): Schema`](#numberpositivemessage-string--function-schema)\n    - [`number.negative(message?: string | function): Schema`](#numbernegativemessage-string--function-schema)\n    - [`number.integer(message?: string | function): Schema`](#numberintegermessage-string--function-schema)\n    - [`number.truncate(): Schema`](#numbertruncate-schema)\n    - [`number.round(type: 'floor' | 'ceil' | 'trunc' | 'round' = 'round'): Schema`](#numberroundtype-floor--ceil--trunc--round--round-schema)\n  - [boolean](#boolean)\n  - [date](#date)\n    - [`date.min(limit: Date | string | Ref, message?: string | function): Schema`](#dateminlimit-date--string--ref-message-string--function-schema)\n    - [`date.max(limit: Date | string | Ref, message?: string | function): Schema`](#datemaxlimit-date--string--ref-message-string--function-schema)\n  - [array](#array)\n    - [`array.of(type: Schema): this`](#arrayoftype-schema-this)\n    - [`array.json(): this`](#arrayjson-this)\n    - [`array.length(length: number | Ref, message?: string | function): this`](#arraylengthlength-number--ref-message-string--function-this)\n    - [`array.min(limit: number | Ref, message?: string | function): this`](#arrayminlimit-number--ref-message-string--function-this)\n    - [`array.max(limit: number | Ref, message?: string | function): this`](#arraymaxlimit-number--ref-message-string--function-this)\n    - [`array.ensure(): this`](#arrayensure-this)\n    - [`array.compact(rejector: (value) => boolean): Schema`](#arraycompactrejector-value--boolean-schema)\n  - [tuple](#tuple)\n  - [object](#object)\n    - [Object schema defaults](#object-schema-defaults)\n    - [`object.shape(fields: object, noSortEdges?: Array<[string, string]>): Schema`](#objectshapefields-object-nosortedges-arraystring-string-schema)\n    - [`object.json(): this`](#objectjson-this)\n    - [`object.concat(schemaB: ObjectSchema): ObjectSchema`](#objectconcatschemab-objectschema-objectschema)\n    - [`object.pick(keys: string[]): Schema`](#objectpickkeys-string-schema)\n    - [`object.omit(keys: string[]): Schema`](#objectomitkeys-string-schema)\n    - [`object.from(fromKey: string, toKey: string, alias: boolean = false): this`](#objectfromfromkey-string-tokey-string-alias-boolean--false-this)\n    - [`object.exact(message?: string | function): Schema`](#objectexactmessage-string--function-schema)\n    - [`object.stripUnknown(): Schema`](#objectstripunknown-schema)\n    - [`object.noUnknown(onlyKnownKeys: boolean = true, message?: string | function): Schema`](#objectnounknownonlyknownkeys-boolean--true-message-string--function-schema)\n    - [`object.camelCase(): Schema`](#objectcamelcase-schema)\n    - [`object.constantCase(): Schema`](#objectconstantcase-schema)\n\n<!-- END doctoc generated TOC please keep comment here to allow auto update -->\n\n## Schema basics\n\nSchema definitions, are comprised of parsing \"transforms\" which manipulate inputs into the desired shape and type, \"tests\", which make assertions over parsed data. Schema also store a bunch of \"metadata\", details about the schema itself, which can be used to improve error messages, build tools that dynamically consume schema, or serialize schema into another format.\n\nIn order to be maximally flexible yup allows running both parsing and assertions separately to match specific needs\n\n### Parsing: Transforms\n\nEach built-in type implements basic type parsing, which comes in handy when parsing serialized data, such as JSON.\nAdditionally types implement type specific transforms that can be enabled.\n\n```ts\nlet num = number().cast('1'); // 1\n\nlet obj = object({\n  firstName: string().lowercase().trim(),\n})\n  .json()\n  .camelCase()\n  .cast('{\"first_name\": \"jAnE \"}'); // { firstName: 'jane' }\n```\n\nCustom transforms can be added\n\n```ts\nlet reversedString = string()\n  .transform((currentValue) => currentValue.split('').reverse().join(''))\n  .cast('dlrow olleh'); // \"hello world\"\n```\n\nTransforms form a \"pipeline\", where the value of a previous transform is piped into the next one.\nWhen an input value is `undefined` yup will apply the schema default if it's configured.\n\n> Watch out! values are not guaranteed to be valid types in transform functions. Previous transforms\n> may have failed. For example a number transform may be receive the input value, `NaN`, or a number.\n\n### Validation: Tests\n\nYup schema run \"tests\" over input values. Tests assert that inputs conform to some\ncriteria. Tests are distinct from transforms, in that they do not change or alter the input (or its type)\nand are usually reserved for checks that are hard, if not impossible, to represent in static types.\n\n```ts\nstring()\n  .min(3, 'must be at least 3 characters long')\n  .email('must be a valid email')\n  .validate('no'); // ValidationError\n```\n\nAs with transforms, tests can be customized on the fly\n\n```ts\nlet jamesSchema = string().test(\n  'is-james',\n  (d) => `${d.path} is not James`,\n  (value) => value == null || value === 'James',\n);\n\njamesSchema.validateSync('James'); // \"James\"\n\njamesSchema.validateSync('Jane'); // ValidationError \"this is not James\"\n```\n\n> Heads up: unlike transforms, `value` in a custom test is guaranteed to be the correct type\n> (in this case an optional string). It still may be `undefined` or `null` depending on your schema\n> in those cases, you may want to return `true` for absent values unless your transform makes presence\n> related assertions. The test option `skipAbsent` will do this for you if set.\n\n#### Customizing errors\n\nIn the simplest case a test function returns `true` or `false` depending on the whether the check\npassed. In the case of a failing test, yup will throw\na [`ValidationError`](#validationerrorerrors-string--arraystring-value-any-path-string) with your (or the default)\nmessage for that test. ValidationErrors also contain a bunch of other metadata about the test,\nincluding it's name, what arguments (if any) it was called with, and the path to the failing field\nin the case of a nested validation.\n\nError messages can also be constructed on the fly to customize how the schema fails.\n\n```ts\nlet order = object({\n  no: number().required(),\n  sku: string().test({\n    name: 'is-sku',\n    skipAbsent: true,\n    test(value, ctx) {\n      if (!value.startsWith('s-')) {\n        return ctx.createError({ message: 'SKU missing correct prefix' });\n      }\n      if (!value.endsWith('-42a')) {\n        return ctx.createError({ message: 'SKU missing correct suffix' });\n      }\n      if (value.length < 10) {\n        return ctx.createError({ message: 'SKU is not the right length' });\n      }\n      return true;\n    },\n  }),\n});\n\norder.validate({ no: 1234, sku: 's-1a45-14a' });\n```\n\n### Composition and Reuse\n\nSchema are immutable, each method call returns a new schema object. Reuse and pass them around without\nfear of mutating another instance.\n\n```ts\nlet optionalString = string().optional();\n\nlet definedString = optionalString.defined();\n\nlet value = undefined;\noptionalString.isValid(value); // true\ndefinedString.isValid(value); // false\n```\n\n## TypeScript integration\n\nYup schema produce static TypeScript interfaces. Use `InferType` to extract that interface:\n\n```ts\nimport * as yup from 'yup';\n\nlet personSchema = yup.object({\n  firstName: yup.string().defined(),\n  nickName: yup.string().default('').nullable(),\n  sex: yup\n    .mixed()\n    .oneOf(['male', 'female', 'other'] as const)\n    .defined(),\n  email: yup.string().nullable().email(),\n  birthDate: yup.date().nullable().min(new Date(1900, 0, 1)),\n});\n\ninterface Person extends yup.InferType<typeof personSchema> {\n  // using interface instead of type generally gives nicer editor feedback\n}\n```\n\n### Schema defaults\n\nA schema's default is used when casting produces an `undefined` output value. Because of this,\nsetting a default affects the output type of the schema, essentially marking it as \"defined()\".\n\n```ts\nimport { string } from 'yup';\n\nlet value: string = string().default('hi').validate(undefined);\n\n// vs\n\nlet value: string | undefined = string().validate(undefined);\n```\n\n### Ensuring a schema matches an existing type\n\nIn some cases a TypeScript type already exists, and you want to ensure that\nyour schema produces a compatible type:\n\n```ts\nimport { object, number, string, ObjectSchema } from 'yup';\n\ninterface Person {\n  name: string;\n  age?: number;\n  sex: 'male' | 'female' | 'other' | null;\n}\n\n// will raise a compile-time type error if the schema does not produce a valid Person\nlet schema: ObjectSchema<Person> = object({\n  name: string().defined(),\n  age: number().optional(),\n  sex: string<'male' | 'female' | 'other'>().nullable().defined(),\n});\n\n// \u274c errors:\n// \"Type 'number | undefined' is not assignable to type 'string'.\"\nlet badSchema: ObjectSchema<Person> = object({\n  name: number(),\n});\n```\n\n### Extending built-in schema with new methods\n\nYou can use TypeScript's interface merging behavior to extend the schema types\nif needed. Type extensions should go in an \"ambient\" type definition file such as your\n`globals.d.ts`. Remember to actually extend the yup type in your application code!\n\n> Watch out! merging only works if the type definition is _exactly_ the same, including\n> generics. Consult the yup source code for each type to ensure you are defining it correctly\n\n```ts\n// globals.d.ts\ndeclare module 'yup' {\n  interface StringSchema<TType, TContext, TDefault, TFlags> {\n    append(appendStr: string): this;\n  }\n}\n\n// app.ts\nimport { addMethod, string } from 'yup';\n\naddMethod(string, 'append', function append(appendStr: string) {\n  return this.transform((value) => `${value}${appendStr}`);\n});\n\nstring().append('~~~~').cast('hi'); // 'hi~~~~'\n```\n\n### TypeScript configuration\n\nYou **must** have the `strictNullChecks` compiler option enabled for type inference to work.\n\nWe also recommend settings `strictFunctionTypes` to `false`, for functionally better types. Yes\nthis reduces overall soundness, however TypeScript already disables this check\nfor methods and constructors (note from TS docs):\n\n> During development of this feature, we discovered a large number of inherently\n> unsafe class hierarchies, including some in the DOM. Because of this,\n> the setting only applies to functions written in function syntax, not to those in method syntax:\n\nYour mileage will vary, but we've found that this check doesn't prevent many of\nreal bugs, while increasing the amount of onerous explicit type casting in apps.\n\n## Error message customization\n\nDefault error messages can be customized for when no message is provided with a validation test.\nIf any message is missing in the custom dictionary the error message will default to Yup's one.\n\n```js\nimport { setLocale } from 'yup';\n\nsetLocale({\n  mixed: {\n    default: 'N\u00e3o \u00e9 v\u00e1lido',\n  },\n  number: {\n    min: 'Deve ser maior que ${min}',\n  },\n});\n\n// now use Yup schemas AFTER you defined your custom dictionary\nlet schema = yup.object().shape({\n  name: yup.string(),\n  age: yup.number().min(18),\n});\n\ntry {\n  await schema.validate({ name: 'jimmy', age: 11 });\n} catch (err) {\n  err.name; // => 'ValidationError'\n  err.errors; // => ['Deve ser maior que 18']\n}\n```\n\n### localization and i18n\n\nIf you need multi-language support, yup has got you covered. The function `setLocale` accepts functions that can be used to\ngenerate error objects with translation keys and values. These can be fed it into your favorite i18n library.\n\n```js\nimport { setLocale } from 'yup';\n\nsetLocale({\n  // use constant translation keys for messages without values\n  mixed: {\n    default: 'field_invalid',\n  },\n  // use functions to generate an error object that includes the value from the schema\n  number: {\n    min: ({ min }) => ({ key: 'field_too_short', values: { min } }),\n    max: ({ max }) => ({ key: 'field_too_big', values: { max } }),\n  },\n});\n\n// ...\n\nlet schema = yup.object().shape({\n  name: yup.string(),\n  age: yup.number().min(18),\n});\n\ntry {\n  await schema.validate({ name: 'jimmy', age: 11 });\n} catch (err) {\n  messages = err.errors.map((err) => i18next.t(err.key));\n}\n```\n\n## Standard Schema Support\n\nYup is compatible with [Standard Schema](https://github.com/standard-schema/standard-schema).\n\n## API\n\n### `yup`\n\nThe module export.\n\n```ts\n// core schema\nimport {\n  mixed,\n  string,\n  number,\n  boolean,\n  bool,\n  date,\n  object,\n  array,\n  ref,\n  lazy,\n} from 'yup';\n\n// Classes\nimport {\n  Schema,\n  MixedSchema,\n  StringSchema,\n  NumberSchema,\n  BooleanSchema,\n  DateSchema,\n  ArraySchema,\n  ObjectSchema,\n} from 'yup';\n\n// Types\nimport type { InferType, ISchema, AnySchema, AnyObjectSchema } from 'yup';\n```\n\n#### `reach(schema: Schema, path: string, value?: object, context?: object): Schema`\n\nFor nested schemas, `reach` will retrieve an inner schema based on the provided path.\n\nFor nested schemas that need to resolve dynamically, you can provide a `value` and optionally\na `context` object.\n\n```js\nimport { reach } from 'yup';\n\nlet schema = object({\n  nested: object({\n    arr: array(object({ num: number().max(4) })),\n  }),\n});\n\nreach(schema, 'nested.arr.num');\nreach(schema, 'nested.arr[].num');\nreach(schema, 'nested.arr[1].num');\nreach(schema, 'nested[\"arr\"][1].num');\n```\n\n#### `addMethod(schemaType: Schema, name: string, method: ()=> Schema): void`\n\nAdds a new method to the core schema types. A friendlier convenience method for `schemaType.prototype[name] = method`.\n\n```ts\nimport { addMethod, date } from 'yup';\n\naddMethod(date, 'format', function format(formats, parseStrict) {\n  return this.transform((value, originalValue, ctx) => {\n    if (ctx.isType(value)) return value;\n\n    value = Moment(originalValue, formats, parseStrict);\n\n    return value.isValid() ? value.toDate() : new Date('');\n  });\n});\n```\n\nIf you want to add a method to ALL schema types, extend the abstract base class: `Schema`\n\n```ts\nimport { addMethod, Schema } from 'yup';\n\naddMethod(Schema, 'myMethod', ...)\n```\n\n#### `ref(path: string, options: { contextPrefix: string }): Ref`\n\nCreates a reference to another sibling or sibling descendant field. Refs are resolved\nat _validation/cast time_ and supported where specified. Refs are evaluated in the proper order so that\nthe ref value is resolved before the field using the ref (be careful of circular dependencies!).\n\n```js\nimport { ref, object, string } from 'yup';\n\nlet schema = object({\n  baz: ref('foo.bar'),\n  foo: object({\n    bar: string(),\n  }),\n  x: ref('$x'),\n});\n\nschema.cast({ foo: { bar: 'boom' } }, { context: { x: 5 } });\n// => { baz: 'boom',  x: 5, foo: { bar: 'boom' } }\n```\n\n#### `lazy((value: any) => Schema): Lazy`\n\nCreates a schema that is evaluated at validation/cast time. Useful for creating\nrecursive schema like Trees, for polymorphic fields and arrays.\n\n**CAUTION!** When defining parent-child recursive object schema, you want to reset the `default()`\nto `null` on the child\u2014otherwise the object will infinitely nest itself when you cast it!\n\n```js\nlet node = object({\n  id: number(),\n  child: yup.lazy(() => node.default(undefined)),\n});\n\nlet renderable = yup.lazy((value) => {\n  switch (typeof value) {\n    case 'number':\n      return number();\n    case 'string':\n      return string();\n    default:\n      return mixed();\n  }\n});\n\nlet renderables = array().of(renderable);\n```\n\n#### `ValidationError(errors: string | Array<string>, value: any, path: string)`\n\nThrown on failed validations, with the following properties\n\n- `name`: \"ValidationError\"\n- `type`: the specific test type or test \"name\", that failed.\n- `value`: The field value that was tested;\n- `params`?: The test inputs, such as max value, regex, etc;\n- `path`: a string, indicating where there error was thrown. `path` is empty at the root level.\n- `errors`: array of error messages\n- `inner`: in the case of aggregate errors, inner is an array of `ValidationErrors` throw earlier in the\n  validation chain. When the `abortEarly` option is `false` this is where you can inspect each error thrown,\n  alternatively, `errors` will have all of the messages from each inner error.\n\n### `Schema`\n\n`Schema` is the abstract base class that all schema type inherit from. It provides a number of base methods and properties\nto all other schema types.\n\n> Note: unless you are creating a custom schema type, Schema should never be used directly. For unknown/any types use [`mixed()`](#mixed)\n\n#### `Schema.clone(): Schema`\n\nCreates a deep copy of the schema. Clone is used internally to return a new schema with every schema state change.\n\n#### `Schema.label(label: string): Schema`\n\nOverrides the key name which is used in error messages.\n\n#### `Schema.meta(metadata: SchemaMetadata): Schema`\n\nAdds to a metadata object, useful for storing data with a schema, that doesn't belong\nto the cast object itself.\n\nA custom `SchemaMetadata` interface can be defined through\n[merging](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#merging-interfaces)\nwith the `CustomSchemaMetadata` interface. Start by creating a `yup.d.ts` file\nin your package and creating your desired `CustomSchemaMetadata` interface:\n\n```ts\n// yup.d.ts\nimport 'yup';\n\ndeclare module 'yup' {\n  // Define your desired `SchemaMetadata` interface by merging the\n  // `CustomSchemaMetadata` interface.\n  export interface CustomSchemaMetadata {\n    placeholderText?: string;\n    tooltipText?: string;\n    // \u2026\n  }\n}\n```\n\n#### `Schema.describe(options?: ResolveOptions): SchemaDescription`\n\nCollects schema details (like meta, labels, and active tests) into a serializable\ndescription object.\n\n```ts\nlet schema = object({\n  name: string().required(),\n});\n\nlet description = schema.describe();\n```\n\nFor schema with dynamic components (references, lazy, or conditions), describe requires\nmore context to accurately return the schema description. In these cases provide `options`\n\n```ts\nimport { ref, object, string, boolean } from 'yup';\n\nlet schema = object({\n  isBig: boolean(),\n  count: number().when('isBig', {\n    is: true,\n    then: (schema) => schema.min(5),\n    otherwise: (schema) => schema.min(0),\n  }),\n});\n\nschema.describe({ value: { isBig: true } });\n```\n\nAnd below are the description types, which differ a bit depending on the schema type.\n\n```ts\ninterface SchemaDescription {\n  type: string;\n  label?: string;\n  meta: object | undefined;\n  oneOf: unknown[];\n  notOneOf: unknown[];\n  default?: unknown;\n  nullable: boolean;\n  optional: boolean;\n  tests: Array<{ name?: string; params: ExtraParams | undefined }>;\n\n  // Present on object schema descriptions\n  fields: Record<string, SchemaFieldDescription>;\n\n  // Present on array schema descriptions\n  innerType?: SchemaFieldDescription;\n}\n\ntype SchemaFieldDescription =\n  | SchemaDescription\n  | SchemaRefDescription\n  | SchemaLazyDescription;\n\ninterface SchemaRefDescription {\n  type: 'ref';\n  key: string;\n}\n\ninterface SchemaLazyDescription {\n  type: string;\n  label?: string;\n  meta: object | undefined;\n}\n```\n\n#### `Schema.concat(schema: Schema): Schema`\n\nCreates a new instance of the schema by combining two schemas. Only schemas of the same type can be concatenated.\n`concat` is not a \"merge\" function in the sense that all settings from the provided schema, override ones in the\nbase, including type, presence and nullability.\n\n```ts\nmixed<string>().defined().concat(mixed<number>().nullable());\n\n// produces the equivalent to:\n\nmixed<number>().defined().nullable();\n```\n\n#### `Schema.validate(value: any, options?: object): Promise<InferType<Schema>, ValidationError>`\n\nReturns the parses and validates an input value, returning the parsed value or throwing an error. This method is **asynchronous** and returns a Promise object, that is fulfilled with the value, or rejected\nwith a `ValidationError`.\n\n```js\nvalue = await schema.validate({ name: 'jimmy', age: 24 });\n```\n\nProvide `options` to more specifically control the behavior of `validate`.\n\n``"}