{"d": {"exhaustive": {"nbHits": false, "typo": false}, "exhaustiveNbHits": false, "exhaustiveTypo": false, "hits": [{"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "rajasimon"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["telegram", "bot", "production"], "value": "Hi there,<p>Recently I created a very simple <em>telegram bot</em> to get notification about my embed-blog.com activity. Activities like who signed up to the trial period and who is currently paying and who is created something, etc...<p>These are important metrics I've to know immediatly and Google analytics is not the place to learn it.<p>Setting up this is very easy and it's a two step process.<p>1. Create a telegram group and add [@Lognowbot](https://t.me/Lognowbot) into it.\n2. You receive a chat_id from [@Lognowbot](https://t.me/Lognowbot)\n3. Send a post message to https://lognowbot-<em>production</em>.up.railway.app/forward with chat_id and text you wanted to send.\n4. Receive notification<p>i.e) code<p>def notify_telegram(text):\n    payload = {\n        &quot;chat_id&quot;: settings.TELEGRAM_CHAT_ID,\n        &quot;text&quot;: text,\n    }\n    endpoint = &quot;https://lognowbot-<em>production</em>.up.railway.app/forward&quot;\n    requests.post(endpoint, json=payload)\n    return True"}, "title": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["telegram", "bot"], "value": "Show HN: I created a <em>telegram bot</em> to notify my website activity"}}, "_tags": ["story", "author_rajasimon", "story_34216830", "show_hn"], "author": "rajasimon", "created_at": "2023-01-02T11:33:43Z", "created_at_i": 1672659223, "num_comments": 0, "objectID": "34216830", "points": 1, "story_id": 34216830, "story_text": "Hi there,<p>Recently I created a very simple telegram bot to get notification about my embed-blog.com activity. Activities like who signed up to the trial period and who is currently paying and who is created something, etc...<p>These are important metrics I&#x27;ve to know immediatly and Google analytics is not the place to learn it.<p>Setting up this is very easy and it&#x27;s a two step process.<p>1. Create a telegram group and add [@Lognowbot](https:&#x2F;&#x2F;t.me&#x2F;Lognowbot) into it.\n2. You receive a chat_id from [@Lognowbot](https:&#x2F;&#x2F;t.me&#x2F;Lognowbot)\n3. Send a post message to https:&#x2F;&#x2F;lognowbot-production.up.railway.app&#x2F;forward with chat_id and text you wanted to send.\n4. Receive notification<p>i.e) code<p>def notify_telegram(text):\n    payload = {\n        &quot;chat_id&quot;: settings.TELEGRAM_CHAT_ID,\n        &quot;text&quot;: text,\n    }\n    endpoint = &quot;https:&#x2F;&#x2F;lognowbot-production.up.railway.app&#x2F;forward&quot;\n    requests.post(endpoint, json=payload)\n    return True", "title": "Show HN: I created a telegram bot to notify my website activity", "updated_at": "2024-09-20T12:57:55Z"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "spirovskib"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["telegram", "bot", "production"], "value": "This past Friday afternoon, a member in our Discord server reported a phishing email pointing to a fake login page.<p>We took up to research it and because of clumsy decisions by the attacker we got their GitHub and their operational <em>Telegram bot</em>.<p>Screenshots: https://imgur.com/a/FTy4mrH<p>Sometimes the attacker incompetence can be a defender's best weapon  \u00af\\_(\u30c4)_/\u00af<p>The phishing page was a standard clone of an &quot;email&quot;, unbranded anf generic service. A bit of gobuster reconnaissance and we got the site's .git directory publicly accessible and listing its contents.<p>Inspecting of the requests also got us the first <em>Telegram bot</em> token. \nThis is the digital equivalent of leaving the blueprints to your entire operation, including past versions and deleted files, lying on the front lawn.<p>We pulled the repository, found automated deployments and multiple fake pages with different hardcoded <em>Telegram bot</em> tokens and Chat IDs.<p>With the source code, repo and the active <em>Telegram bot</em> token, we filed detailed abuse reports:<p>- GitHub: We reported the repository containing the phishing kit's source code. It was taken down for violating TOS.<p>- Telegram: We reported the bot using the provided token and chat ID, leading to its removal.<p>- Hosting Provider: The malicious site was reported and taken offline.<p>Lesson learned? Never deploy a .git folder to <em>production</em>. Even if you are a criminal.<p>Acknowledgement: This was a collaborative effort by members of the BeyondMachines Discord community. The crowdsourced speed and collaboration helped us take this down very fast."}, "title": {"matchLevel": "none", "matchedWords": [], "value": "An exposed .git folder let us dox a phishing campaign"}}, "_tags": ["story", "author_spirovskib", "story_45943802", "ask_hn"], "author": "spirovskib", "children": [45944037, 45944077, 45944129, 45944294, 45946315, 45946373, 45954307], "created_at": "2025-11-16T09:29:21Z", "created_at_i": 1763285361, "num_comments": 21, "objectID": "45943802", "points": 64, "story_id": 45943802, "story_text": "This past Friday afternoon, a member in our Discord server reported a phishing email pointing to a fake login page.<p>We took up to research it and because of clumsy decisions by the attacker we got their GitHub and their operational Telegram bot.<p>Screenshots: https:&#x2F;&#x2F;imgur.com&#x2F;a&#x2F;FTy4mrH<p>Sometimes the attacker incompetence can be a defender&#x27;s best weapon  \u00af\\_(\u30c4)_&#x2F;\u00af<p>The phishing page was a standard clone of an &quot;email&quot;, unbranded anf generic service. A bit of gobuster reconnaissance and we got the site&#x27;s .git directory publicly accessible and listing its contents.<p>Inspecting of the requests also got us the first Telegram bot token. \nThis is the digital equivalent of leaving the blueprints to your entire operation, including past versions and deleted files, lying on the front lawn.<p>We pulled the repository, found automated deployments and multiple fake pages with different hardcoded Telegram bot tokens and Chat IDs.<p>With the source code, repo and the active Telegram bot token, we filed detailed abuse reports:<p>- GitHub: We reported the repository containing the phishing kit&#x27;s source code. It was taken down for violating TOS.<p>- Telegram: We reported the bot using the provided token and chat ID, leading to its removal.<p>- Hosting Provider: The malicious site was reported and taken offline.<p>Lesson learned? Never deploy a .git folder to production. Even if you are a criminal.<p>Acknowledgement: This was a collaborative effort by members of the BeyondMachines Discord community. The crowdsourced speed and collaboration helped us take this down very fast.", "title": "An exposed .git folder let us dox a phishing campaign", "updated_at": "2025-11-20T21:24:19Z"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "nghiahsgs"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["telegram", "bot", "production"], "value": "Most AI agents today run with unchecked access to tools like shell execution, database writes, and arbitrary HTTP calls. There's  \n  no systematic way to constrain what they can do before execution happens. You're essentially giving a new employee root access and\n   no employment contract.<p><pre><code>  LawClaw applies a separation-of-powers model to agent governance \u2014 borrowing from constitutional design to create layered,\n  enforceable rules.\n\n  Three layers:\n\n  Constitution: Immutable core rules embedded in the system prompt. The agent cannot override these regardless of user instruction.\n\n  Legislature: Detailed behavioral laws written as plain markdown files. Human-readable, git-diffable, no custom DSL. Change the law\n   by editing a file and committing.\n\n  Pre-Judiciary: Automated enforcement that runs before tool execution, not after. It inspects the LLM's intended action and blocks\n  it if it violates law. Think traffic cameras, not courtrooms. This is where &quot;rm -rf /&quot;, &quot;DROP TABLE&quot;, and &quot;curl | bash&quot; get\n  intercepted.\n\n  Because the governed &quot;society&quot; has exactly one citizen (the agent), there's no need for an Executive branch \u2014 enforcement is fully\n   automated.\n\n  What ships with it:\n\n  - <em>Telegram bot</em> interface\n  - Multi-provider LLM support (OpenRouter, Z.AI, Claude Max proxy)\n  - Cron job scheduling\n  - Full audit trail of every action attempted and whether it was allowed or blocked\n  - Runtime tool ban/approve without restart\n\n  The governance layer itself is just markdown. If you want to prohibit file deletions in <em>production</em> paths, you write a markdown\n  file that says so. The Pre-Judiciary reads it, parses the constraint, and enforces it before any tool fires.\n\n  This started as a practical response to a real problem: we needed to deploy agents with meaningful autonomy but couldn't accept\n  unconstrained tool use. The constitutional framing turned out to be a useful mental model for reasoning about agent permissions\n  and audit.\n\n  GitHub: https://github.com/nghiahsgs/LawClaw\n\n  MIT licensed. Early stage. Interested in feedback from anyone running agents in <em>production</em>, particularly on the Pre-Judiciary\n  enforcement model and whether the constitutional framing maps well to other agent architectures. Security researchers welcome \u2014\n  the threat model for agents bypassing their own governance is worth scrutinizing.</code></pre>"}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Show HN: LawClaw \u2013 Constitutional governance for AI agents (MIT)"}}, "_tags": ["story", "author_nghiahsgs", "story_47109076", "show_hn"], "author": "nghiahsgs", "children": [47109110, 47109713], "created_at": "2026-02-22T07:34:57Z", "created_at_i": 1771745697, "num_comments": 1, "objectID": "47109076", "points": 2, "story_id": 47109076, "story_text": "Most AI agents today run with unchecked access to tools like shell execution, database writes, and arbitrary HTTP calls. There&#x27;s  \n  no systematic way to constrain what they can do before execution happens. You&#x27;re essentially giving a new employee root access and\n   no employment contract.<p><pre><code>  LawClaw applies a separation-of-powers model to agent governance \u2014 borrowing from constitutional design to create layered,\n  enforceable rules.\n\n  Three layers:\n\n  Constitution: Immutable core rules embedded in the system prompt. The agent cannot override these regardless of user instruction.\n\n  Legislature: Detailed behavioral laws written as plain markdown files. Human-readable, git-diffable, no custom DSL. Change the law\n   by editing a file and committing.\n\n  Pre-Judiciary: Automated enforcement that runs before tool execution, not after. It inspects the LLM&#x27;s intended action and blocks\n  it if it violates law. Think traffic cameras, not courtrooms. This is where &quot;rm -rf &#x2F;&quot;, &quot;DROP TABLE&quot;, and &quot;curl | bash&quot; get\n  intercepted.\n\n  Because the governed &quot;society&quot; has exactly one citizen (the agent), there&#x27;s no need for an Executive branch \u2014 enforcement is fully\n   automated.\n\n  What ships with it:\n\n  - Telegram bot interface\n  - Multi-provider LLM support (OpenRouter, Z.AI, Claude Max proxy)\n  - Cron job scheduling\n  - Full audit trail of every action attempted and whether it was allowed or blocked\n  - Runtime tool ban&#x2F;approve without restart\n\n  The governance layer itself is just markdown. If you want to prohibit file deletions in production paths, you write a markdown\n  file that says so. The Pre-Judiciary reads it, parses the constraint, and enforces it before any tool fires.\n\n  This started as a practical response to a real problem: we needed to deploy agents with meaningful autonomy but couldn&#x27;t accept\n  unconstrained tool use. The constitutional framing turned out to be a useful mental model for reasoning about agent permissions\n  and audit.\n\n  GitHub: https:&#x2F;&#x2F;github.com&#x2F;nghiahsgs&#x2F;LawClaw\n\n  MIT licensed. Early stage. Interested in feedback from anyone running agents in production, particularly on the Pre-Judiciary\n  enforcement model and whether the constitutional framing maps well to other agent architectures. Security researchers welcome \u2014\n  the threat model for agents bypassing their own governance is worth scrutinizing.</code></pre>", "title": "Show HN: LawClaw \u2013 Constitutional governance for AI agents (MIT)", "updated_at": "2026-02-22T13:28:52Z"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "Ente"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["telegram", "bot", "production"], "value": "I made a <em>Telegram bot</em> that adds songs to a shared Spotify playlist. Drop &quot;Everlong by Foo Fighters&quot; in your group chat and it figures out which track you meant.<p>It handles Spotify links (instant add), cross-platform links like YouTube/Apple Music (resolves and asks for confirmation), and natural language requests. The LLM disambiguation is the fun part - it goes through 4 stages to nail down exactly which track you want, handling ambiguous requests surprisingly well.<p>Built it in Go with flood protection (because someone always tries to spam 50 songs at once) and duplicate detection so the same track doesn't get added twice. It also auto-manages the queue to keep music playing continuously.<p>Fair warning: this is a passion project I vibe-coded. Works great for my friend group but probably not <em>production</em>-ready.<p>Would love to hear what you think!"}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Show HN: I built an AI DJ bot that understands \"play some chill Arctic Monkeys\""}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://github.com/Enteee/DJAlgoRhythm"}}, "_tags": ["story", "author_Ente", "story_45844519", "show_hn"], "author": "Ente", "children": [45844640], "created_at": "2025-11-07T08:20:24Z", "created_at_i": 1762503624, "num_comments": 3, "objectID": "45844519", "points": 1, "story_id": 45844519, "story_text": "I made a Telegram bot that adds songs to a shared Spotify playlist. Drop &quot;Everlong by Foo Fighters&quot; in your group chat and it figures out which track you meant.<p>It handles Spotify links (instant add), cross-platform links like YouTube&#x2F;Apple Music (resolves and asks for confirmation), and natural language requests. The LLM disambiguation is the fun part - it goes through 4 stages to nail down exactly which track you want, handling ambiguous requests surprisingly well.<p>Built it in Go with flood protection (because someone always tries to spam 50 songs at once) and duplicate detection so the same track doesn&#x27;t get added twice. It also auto-manages the queue to keep music playing continuously.<p>Fair warning: this is a passion project I vibe-coded. Works great for my friend group but probably not production-ready.<p>Would love to hear what you think!", "title": "Show HN: I built an AI DJ bot that understands \"play some chill Arctic Monkeys\"", "updated_at": "2025-11-07T12:38:54Z", "url": "https://github.com/Enteee/DJAlgoRhythm"}], "hitsPerPage": 15, "nbHits": 4, "nbPages": 1, "page": 0, "params": "query=telegram-bot+production&tags=story&hitsPerPage=15&advancedSyntax=true&analyticsTags=backend", "processingTimeMS": 15, "processingTimingsMS": {"_request": {"roundTrip": 18}, "afterFetch": {"merge": {"mergeLoop": {"total": 1}, "total": 1}, "total": 1}, "fetch": {"query": 11, "scanning": 1, "total": 13}, "total": 15}, "query": "telegram-bot production", "serverTimeMS": 16}}