{"d": {"exhaustive": {"nbHits": false, "typo": false}, "exhaustiveNbHits": false, "exhaustiveTypo": false, "hits": [{"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "level09"}, "story_text": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["production"], "value": "Hi HN! I've been building ReadyKit, an open-source SaaS boilerplate that handles all the hard parts: multi-tenant workspaces, Stripe billing, OAuth + MFA authentication, and a <em>production</em>-ready stack.<p>Built with Python/Flask, PostgreSQL, Redis, and Vue 3, it's designed for indie makers and teams who want to ship SaaS products fast. Clone, configure your OAuth and Stripe keys, and you're running in 5 minutes.<p>Features include automatic query scoping for workspace isolation, audit logs, role-based access, and a modern UX kit. MIT licensed and free forever.<p>GitHub: <a href=\"https://github.com/level09/readykit\" rel=\"nofollow\">https://github.com/level09/readykit</a>"}, "title": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["supertest"], "value": "Show HN: ReadyKit \u2013 <em>Superfast</em> SaaS Starter with Multi-Tenant Workspaces"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://readykit.dev/"}}, "_tags": ["story", "author_level09", "story_46094552", "show_hn"], "author": "level09", "children": [46129525, 46129555, 46189423, 46189662, 46189669, 46189949, 46190531, 46191932, 46192086, 46192604, 46193880, 46200603], "created_at": "2025-11-30T07:18:15Z", "created_at_i": 1764487095, "num_comments": 35, "objectID": "46094552", "points": 121, "story_id": 46094552, "story_text": "Hi HN! I&#x27;ve been building ReadyKit, an open-source SaaS boilerplate that handles all the hard parts: multi-tenant workspaces, Stripe billing, OAuth + MFA authentication, and a production-ready stack.<p>Built with Python&#x2F;Flask, PostgreSQL, Redis, and Vue 3, it&#x27;s designed for indie makers and teams who want to ship SaaS products fast. Clone, configure your OAuth and Stripe keys, and you&#x27;re running in 5 minutes.<p>Features include automatic query scoping for workspace isolation, audit logs, role-based access, and a modern UX kit. MIT licensed and free forever.<p>GitHub: <a href=\"https:&#x2F;&#x2F;github.com&#x2F;level09&#x2F;readykit\" rel=\"nofollow\">https:&#x2F;&#x2F;github.com&#x2F;level09&#x2F;readykit</a>", "title": "Show HN: ReadyKit \u2013 Superfast SaaS Starter with Multi-Tenant Workspaces", "updated_at": "2025-12-11T20:46:50Z", "url": "https://readykit.dev/"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "beanpup_py"}, "story_text": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["production"], "value": "Hey HN, I've been working on Soppo, a language that compiles to Go, adding features to catch errors at compile time instead of runtime: enums with exhaustive matching, `?` for error propagation, and nil safety from static analysis of nil flows (sort of like <a href=\"https://github.com/uber-go/nilaway\" rel=\"nofollow\">https://github.com/uber-go/nilaway</a> but currently much less sophisticated). It's designed to still look and feel like Go, and be able to use any Go library directly.<p>Playground: <a href=\"https://play.soppolang.dev\" rel=\"nofollow\">https://play.soppolang.dev</a><p>Not <em>production</em> ready and still a little early in development, but curious what people think about the design."}, "title": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["supertest"], "value": "Show HN: Soppo \u2013 A Golang <em>superset</em> that adds enums, pattern matching, nil safety"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://github.com/halcyonnouveau/soppo"}}, "_tags": ["story", "author_beanpup_py", "story_46135593", "show_hn"], "author": "beanpup_py", "created_at": "2025-12-03T15:28:07Z", "created_at_i": 1764775687, "num_comments": 0, "objectID": "46135593", "points": 2, "story_id": 46135593, "story_text": "Hey HN, I&#x27;ve been working on Soppo, a language that compiles to Go, adding features to catch errors at compile time instead of runtime: enums with exhaustive matching, `?` for error propagation, and nil safety from static analysis of nil flows (sort of like <a href=\"https:&#x2F;&#x2F;github.com&#x2F;uber-go&#x2F;nilaway\" rel=\"nofollow\">https:&#x2F;&#x2F;github.com&#x2F;uber-go&#x2F;nilaway</a> but currently much less sophisticated). It&#x27;s designed to still look and feel like Go, and be able to use any Go library directly.<p>Playground: <a href=\"https:&#x2F;&#x2F;play.soppolang.dev\" rel=\"nofollow\">https:&#x2F;&#x2F;play.soppolang.dev</a><p>Not production ready and still a little early in development, but curious what people think about the design.", "title": "Show HN: Soppo \u2013 A Golang superset that adds enums, pattern matching, nil safety", "updated_at": "2025-12-03T23:08:18Z", "url": "https://github.com/halcyonnouveau/soppo"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "rubenfiszel"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["supertest", "production"], "value": "Ruben here, software engineer, long-time lurker of Hacker News and founder of Windmill. Windmill is a fully open-source self-hostable platform and runtime to build complex workflows, internal apps and integrations using any scripts in Python or Typescript-deno. I am back after having been revealed a bit too soon on HN and miraculously getting into YC (<a href=\"https://news.ycombinator.com/item?id=31272793\" rel=\"nofollow\">https://news.ycombinator.com/item?id=31272793</a>).<p>To build internal apps for ops, integrations between services that cannot talk to each other directly, or to run background jobs that run your business logic and analytics, the two main options today are no-code solutions and old-fashioned, roll-your-own scripting. Both have problems, and our goal with Windmill is to find a new sweet spot between the two. No-code solutions are productive <i>if</i> your problem matches the tool exactly - but it not, they are rigid, hard to extend and quickly become tech debt, annihilating their initial time advantage. Indeed, no-code is just code but made by an opinionated someone else and hidden as a blackbox with an UI.<p>The alternative is to do it the old-fashioned way, writing everything from scratch, both backend and frontend, perhaps deploying it on the latest flavor of serverless, and pray to never have to touch it again because that took way too much time and it has now became a burden that the ops and business team might poke you about regularly.<p>Furthermore, the landscape of SaaS is specialized tools for everything\u2014alerting, data analytics, administration panels, support management, integration between services\u2014when it feels like a few scripts would have been as good or even better and spared you the need of depending on one yet another tool. This could be even further facilitated if there was a way to import the right bunch of scripts from a fellow community of engineers, tweak it and deploy it like you can do in communities where automation can be shared as simple JSON files, for instance in the node-red or home assistant community.. That\u2019s the idea of Windmill: to bring back the power of scripting in an easy way.<p>With Windmill, you write normal scripts, or reuse ones made by others, and we make them <em>production</em>-grade and composable. You shouldn\u2019t have to worry about things like http requests or scheduling jobs. We abstract much of that away, making your scripts be both more focused and more composable. You end up doing things the right way but much quicker.<p>We reduce the complexity of workflows, integrations and internal apps by uniting them all under one banner. At the heart, they mostly have the same needs: workflows with a UI or a schedule. One tool that does it all out-of-the-box offers greater consistency and allows you to grow the complexity of your toolset at your own pace.<p>I have an academic background in compilers and industry experience in distributed systems. My compiler work made me wary of solving every problem with a domain-specific-language (DSL) or complex frameworks. We can just do more with the well-crafted existing languages like Python or Typescript.  Rolling up your own DSL is nice in theory, you can make it very ergonomic and focused on the task at hand, but then you start adding features and either reinvent existing \u2013 albeit worse \u2013 programming language or decide to stop there. In the very large majority of cases, a well crafted library is vastly superior to any DSL. By being able to use any library of Python and Typescript, we stand on the shoulders of giants.<p>I have also observed that the best distributed systems are often the most simple as they are more predictable and have invariants that are easier to reason with and scale horizontally. This is why for Windmill, we rely solely on Postgres + our native workers + our http REST api layer. Later on, we plan to build adapters to host the workers on AWS lambda or Cloudflare workers, and the queue on Kafka if your needs are exceptionally high.<p>At the heart of what we have built is a queue implemented in Postgres and workers implemented in Rust that create a sandbox (using nsjail), fetch dependencies, and execute  scripts. Every script can be triggered through its name  with an HTTP POST by passing a JSON payload in which every field corresponds 1:1 to an argument of the script\u2019s main parameters. Most primitive types in Python or Typescript have a natural corresponding type in JSON so the conversion is always what you would expect.  We then execute the script inside a new sandbox and then store the results in the same Postgres DB at the end of the job execution.<p>The HTTP payload can be sent from your own frontend or you can use our automatically generated UI. Indeed, we do a simple, yet effective analysis of the parameters of your script, and from it, generate the jsonschema corresponding to your parameters. That schema is what enables us to convert any script into a no-code like module for flows, or a standalone internal app with its auto-generated UI. In the case of Python, we also look at the imports to deduce the Pypi dependencies without you having to declare them.<p>For flows, we defined an open spec for building them out of those scripts we call OpenFlow: <a href=\"https://docs.windmill.dev/docs/openflow\" rel=\"nofollow\">https://docs.windmill.dev/docs/openflow</a>. It  is essentially a json format for describing a sequence of steps with for loops and soon branching. The most interesting bit here is that each input of each step can define its input as a javascript expression that refers to and transforms the output of any previous step. We make it fast by leveraging native v8 integration in Rust (thanks to the deno team) for executing those expressions. This makes this apparently linear sequence a flexible DAG in which one can express complex workflows.<p>Then on top of that we have an UI builder for flows that hides most of the complexity to give an experience that is similar to a low-code platform where every step is treated as a blackbox. The platform itself offers all the features that you would expect: a variable and object store for storing states, plain values and credentials; a cron scheduler, tight permissioning for the sensitive credentials, groups, a webeditor with smart assistant to edit the scripts directly in the platform etc. Finally, we made a hub (<a href=\"https://hub.windmill.dev\" rel=\"nofollow\">https://hub.windmill.dev</a>) to share flows and scripts with everyone. The goal is to grow over time an exhaustive library of pre-made modules and flows to tweak from so that you can focus on what is actually custom to you.<p>Windmill is open-source and self-hostable. You can think of it as a <em>superset</em> of both Pipedream and Airplane.dev. Compared to Temporal, the scripts themselves are agnostic of the flow in which they are embedded, which has the benefit of making it easier to build a hub of reusable modules. We are the only ones as far as we know to convert script parameters to UI automatically. We see ourselves as complementary to UI builder solutions like Retool or Tooljet as we do not want to focus too much on the auto-generated UI and could be used solely as the backend part of the two aforementioned tools.<p>We are now a team of 3 senior engineers and the product is progressing faster than ever with a public roadmap: <a href=\"https://github.com/orgs/windmill-labs/projects/2\" rel=\"nofollow\">https://github.com/orgs/windmill-labs/projects/2</a><p>We make money from commercial licenses, support and team plans on the hosted solution.<p>You can self-host it or try it  <a href=\"https://app.windmill.dev\" rel=\"nofollow\">https://app.windmill.dev</a>, the free tier is generous (and the paid one is not enforced yet). Our landing page is: <a href=\"https://windmill.dev\" rel=\"nofollow\">https://windmill.dev</a>. We would appreciate your feedback and ideas and look forward to all your comments!"}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Launch HN: Windmill (YC S22) \u2013 Turn scripts into internal apps and workflows"}}, "_tags": ["story", "author_rubenfiszel", "story_32400849", "launch_hn"], "author": "rubenfiszel", "children": [32401024, 32401130, 32401179, 32401382, 32401671, 32401979, 32402106, 32402484, 32402797, 32403674, 32405249, 32405271, 32405426, 32405497, 32407247, 32407428, 32408428, 32408482, 32409571, 32411171, 32411397, 32411697, 32413950, 32429873], "created_at": "2022-08-09T17:19:18Z", "created_at_i": 1660065558, "num_comments": 79, "objectID": "32400849", "points": 212, "story_id": 32400849, "story_text": "Ruben here, software engineer, long-time lurker of Hacker News and founder of Windmill. Windmill is a fully open-source self-hostable platform and runtime to build complex workflows, internal apps and integrations using any scripts in Python or Typescript-deno. I am back after having been revealed a bit too soon on HN and miraculously getting into YC (<a href=\"https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=31272793\" rel=\"nofollow\">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=31272793</a>).<p>To build internal apps for ops, integrations between services that cannot talk to each other directly, or to run background jobs that run your business logic and analytics, the two main options today are no-code solutions and old-fashioned, roll-your-own scripting. Both have problems, and our goal with Windmill is to find a new sweet spot between the two. No-code solutions are productive <i>if</i> your problem matches the tool exactly - but it not, they are rigid, hard to extend and quickly become tech debt, annihilating their initial time advantage. Indeed, no-code is just code but made by an opinionated someone else and hidden as a blackbox with an UI.<p>The alternative is to do it the old-fashioned way, writing everything from scratch, both backend and frontend, perhaps deploying it on the latest flavor of serverless, and pray to never have to touch it again because that took way too much time and it has now became a burden that the ops and business team might poke you about regularly.<p>Furthermore, the landscape of SaaS is specialized tools for everything\u2014alerting, data analytics, administration panels, support management, integration between services\u2014when it feels like a few scripts would have been as good or even better and spared you the need of depending on one yet another tool. This could be even further facilitated if there was a way to import the right bunch of scripts from a fellow community of engineers, tweak it and deploy it like you can do in communities where automation can be shared as simple JSON files, for instance in the node-red or home assistant community.. That\u2019s the idea of Windmill: to bring back the power of scripting in an easy way.<p>With Windmill, you write normal scripts, or reuse ones made by others, and we make them production-grade and composable. You shouldn\u2019t have to worry about things like http requests or scheduling jobs. We abstract much of that away, making your scripts be both more focused and more composable. You end up doing things the right way but much quicker.<p>We reduce the complexity of workflows, integrations and internal apps by uniting them all under one banner. At the heart, they mostly have the same needs: workflows with a UI or a schedule. One tool that does it all out-of-the-box offers greater consistency and allows you to grow the complexity of your toolset at your own pace.<p>I have an academic background in compilers and industry experience in distributed systems. My compiler work made me wary of solving every problem with a domain-specific-language (DSL) or complex frameworks. We can just do more with the well-crafted existing languages like Python or Typescript.  Rolling up your own DSL is nice in theory, you can make it very ergonomic and focused on the task at hand, but then you start adding features and either reinvent existing \u2013 albeit worse \u2013 programming language or decide to stop there. In the very large majority of cases, a well crafted library is vastly superior to any DSL. By being able to use any library of Python and Typescript, we stand on the shoulders of giants.<p>I have also observed that the best distributed systems are often the most simple as they are more predictable and have invariants that are easier to reason with and scale horizontally. This is why for Windmill, we rely solely on Postgres + our native workers + our http REST api layer. Later on, we plan to build adapters to host the workers on AWS lambda or Cloudflare workers, and the queue on Kafka if your needs are exceptionally high.<p>At the heart of what we have built is a queue implemented in Postgres and workers implemented in Rust that create a sandbox (using nsjail), fetch dependencies, and execute  scripts. Every script can be triggered through its name  with an HTTP POST by passing a JSON payload in which every field corresponds 1:1 to an argument of the script\u2019s main parameters. Most primitive types in Python or Typescript have a natural corresponding type in JSON so the conversion is always what you would expect.  We then execute the script inside a new sandbox and then store the results in the same Postgres DB at the end of the job execution.<p>The HTTP payload can be sent from your own frontend or you can use our automatically generated UI. Indeed, we do a simple, yet effective analysis of the parameters of your script, and from it, generate the jsonschema corresponding to your parameters. That schema is what enables us to convert any script into a no-code like module for flows, or a standalone internal app with its auto-generated UI. In the case of Python, we also look at the imports to deduce the Pypi dependencies without you having to declare them.<p>For flows, we defined an open spec for building them out of those scripts we call OpenFlow: <a href=\"https:&#x2F;&#x2F;docs.windmill.dev&#x2F;docs&#x2F;openflow\" rel=\"nofollow\">https:&#x2F;&#x2F;docs.windmill.dev&#x2F;docs&#x2F;openflow</a>. It  is essentially a json format for describing a sequence of steps with for loops and soon branching. The most interesting bit here is that each input of each step can define its input as a javascript expression that refers to and transforms the output of any previous step. We make it fast by leveraging native v8 integration in Rust (thanks to the deno team) for executing those expressions. This makes this apparently linear sequence a flexible DAG in which one can express complex workflows.<p>Then on top of that we have an UI builder for flows that hides most of the complexity to give an experience that is similar to a low-code platform where every step is treated as a blackbox. The platform itself offers all the features that you would expect: a variable and object store for storing states, plain values and credentials; a cron scheduler, tight permissioning for the sensitive credentials, groups, a webeditor with smart assistant to edit the scripts directly in the platform etc. Finally, we made a hub (<a href=\"https:&#x2F;&#x2F;hub.windmill.dev\" rel=\"nofollow\">https:&#x2F;&#x2F;hub.windmill.dev</a>) to share flows and scripts with everyone. The goal is to grow over time an exhaustive library of pre-made modules and flows to tweak from so that you can focus on what is actually custom to you.<p>Windmill is open-source and self-hostable. You can think of it as a superset of both Pipedream and Airplane.dev. Compared to Temporal, the scripts themselves are agnostic of the flow in which they are embedded, which has the benefit of making it easier to build a hub of reusable modules. We are the only ones as far as we know to convert script parameters to UI automatically. We see ourselves as complementary to UI builder solutions like Retool or Tooljet as we do not want to focus too much on the auto-generated UI and could be used solely as the backend part of the two aforementioned tools.<p>We are now a team of 3 senior engineers and the product is progressing faster than ever with a public roadmap: <a href=\"https:&#x2F;&#x2F;github.com&#x2F;orgs&#x2F;windmill-labs&#x2F;projects&#x2F;2\" rel=\"nofollow\">https:&#x2F;&#x2F;github.com&#x2F;orgs&#x2F;windmill-labs&#x2F;projects&#x2F;2</a><p>We make money from commercial licenses, support and team plans on the hosted solution.<p>You can self-host it or try it  <a href=\"https:&#x2F;&#x2F;app.windmill.dev\" rel=\"nofollow\">https:&#x2F;&#x2F;app.windmill.dev</a>, the free tier is generous (and the paid one is not enforced yet). Our landing page is: <a href=\"https:&#x2F;&#x2F;windmill.dev\" rel=\"nofollow\">https:&#x2F;&#x2F;windmill.dev</a>. We would appreciate your feedback and ideas and look forward to all your comments!", "title": "Launch HN: Windmill (YC S22) \u2013 Turn scripts into internal apps and workflows", "updated_at": "2024-09-20T11:44:34Z"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "ashpreetbedi"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["supertest", "production"], "value": "Hi HN,<p>I\u2019ve been a data engineer for over a decade and have slowly been working on a way for 1 person to run a data platform (mostly to automate my job)<p>When I was starting, I found the wide range of tools required to build data products overwhelming. Infrastructure setup, app deployment, pipeline development, creating metrics, dashboards and finally, integrating ML into product. No wonder companies have 100s of people working on this. So last year I quit the best job in the world to figure this out.<p>I\u2019d like to introduce Phidata: Building Blocks for Data Engineering<p>It works like this:\n1. You start with a codebase that has common data tools like Airflow, <em>Superset</em> and Jupyter pre-configured. Infrastructure and Apps are defined as python objects.\n2. Build data products (tables, metrics, models) in python or SQL. Test locally using docker and run <em>production</em> on AWS. \n3. Infrastructure, Apps and Data Products live in the same codebase. Teams working together share code and dependencies in a pythonic way.<p>Using phidata, I\u2019ve been running multiple data platforms and have automated most of my boilerplate code using a specially trained GPT-3 data assistant.<p>If you work with data and are looking for a better development experience, checkout [phidata.com](<a href=\"https://www.phidata.com/\" rel=\"nofollow\">https://www.phidata.com/</a>) or message me, I\u2019d love your feedback.<p>Ashpreet"}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Show HN: Phidata \u2013 Building Blocks for Data Engineering"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://docs.phidata.com"}}, "_tags": ["story", "author_ashpreetbedi", "story_34491600", "show_hn"], "author": "ashpreetbedi", "children": [34492530, 34492613, 34493484], "created_at": "2023-01-23T17:04:01Z", "created_at_i": 1674493441, "num_comments": 4, "objectID": "34491600", "points": 16, "story_id": 34491600, "story_text": "Hi HN,<p>I\u2019ve been a data engineer for over a decade and have slowly been working on a way for 1 person to run a data platform (mostly to automate my job)<p>When I was starting, I found the wide range of tools required to build data products overwhelming. Infrastructure setup, app deployment, pipeline development, creating metrics, dashboards and finally, integrating ML into product. No wonder companies have 100s of people working on this. So last year I quit the best job in the world to figure this out.<p>I\u2019d like to introduce Phidata: Building Blocks for Data Engineering<p>It works like this:\n1. You start with a codebase that has common data tools like Airflow, Superset and Jupyter pre-configured. Infrastructure and Apps are defined as python objects.\n2. Build data products (tables, metrics, models) in python or SQL. Test locally using docker and run production on AWS. \n3. Infrastructure, Apps and Data Products live in the same codebase. Teams working together share code and dependencies in a pythonic way.<p>Using phidata, I\u2019ve been running multiple data platforms and have automated most of my boilerplate code using a specially trained GPT-3 data assistant.<p>If you work with data and are looking for a better development experience, checkout [phidata.com](<a href=\"https:&#x2F;&#x2F;www.phidata.com&#x2F;\" rel=\"nofollow\">https:&#x2F;&#x2F;www.phidata.com&#x2F;</a>) or message me, I\u2019d love your feedback.<p>Ashpreet", "title": "Show HN: Phidata \u2013 Building Blocks for Data Engineering", "updated_at": "2024-09-20T13:07:45Z", "url": "https://docs.phidata.com"}], "hitsPerPage": 15, "nbHits": 4, "nbPages": 1, "page": 0, "params": "query=supertest+production&tags=story&hitsPerPage=15&advancedSyntax=true&analyticsTags=backend", "processingTimeMS": 14, "processingTimingsMS": {"_request": {"roundTrip": 18}, "afterFetch": {"format": {"total": 1}}, "fetch": {"query": 12, "scanning": 1, "total": 14}, "total": 14}, "query": "supertest production", "serverTimeMS": 16}}