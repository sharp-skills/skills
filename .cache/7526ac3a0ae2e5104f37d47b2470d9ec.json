{"d": {"exhaustive": {"nbHits": false, "typo": false}, "exhaustiveNbHits": false, "exhaustiveTypo": false, "hits": [{"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "ricardodevelop"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["husky", "production"], "value": "Hello everyone,<p>I\u2019ve created this starter project for creating <em>production</em> ready web apps in Vite and React that I hope some might find useful.<p>This template came about as a necessity to provide some standardization across new projects at work. A few of the initial goals when creating this project were to:<p>- Reduce setup time<p>- Standardize codebase with ESLint and Prettier<p>- Improve commit messages with tools like <em>husky</em>, commitizen and commitlint<p>- Improve codebase maintainability and scalability by providing a reasonable folder structure<p>- Simplify React Component development through use of tools like Storybook<p>- Improving codebase stability with unit and E2E tests via Vitest + React Testing Library and Playwright respectively<p>- Ease the deployment process by providing a simple starter Dockerfile<p>In addition to all the aforementioned goals, I also wanted to use modern tools such as React Query + Zustand for state management, React Hook Form + Zod for creating and validating forms, Tailwind CSS for building out UI\u2019s, etc.<p>I tried to cover everything I, and others, might need but recognize that everyones requirements are different. Luckily, this isn\u2019t a framework so removing unneeded packages or adding new ones is as simple it would normally be. The project itself doesn\u2019t come with a demo as its purpose is to simply provide a foundation for any new projects you might have in mind.<p>Feedback is always welcome and I appreciate anyone willing to checkout this project.<p>Thank you and have a great day."}, "title": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["production"], "value": "Show HN: Vite React Boilerplate \u2013 A <em>Production</em> Ready, Scalable Starter Template"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://github.com/RicardoValdovinos/vite-react-boilerplate"}}, "_tags": ["story", "author_ricardodevelop", "story_36926095", "show_hn"], "author": "ricardodevelop", "children": [36927690, 36928003], "created_at": "2023-07-29T23:49:15Z", "created_at_i": 1690674555, "num_comments": 5, "objectID": "36926095", "points": 18, "story_id": 36926095, "story_text": "Hello everyone,<p>I\u2019ve created this starter project for creating production ready web apps in Vite and React that I hope some might find useful.<p>This template came about as a necessity to provide some standardization across new projects at work. A few of the initial goals when creating this project were to:<p>- Reduce setup time<p>- Standardize codebase with ESLint and Prettier<p>- Improve commit messages with tools like husky, commitizen and commitlint<p>- Improve codebase maintainability and scalability by providing a reasonable folder structure<p>- Simplify React Component development through use of tools like Storybook<p>- Improving codebase stability with unit and E2E tests via Vitest + React Testing Library and Playwright respectively<p>- Ease the deployment process by providing a simple starter Dockerfile<p>In addition to all the aforementioned goals, I also wanted to use modern tools such as React Query + Zustand for state management, React Hook Form + Zod for creating and validating forms, Tailwind CSS for building out UI\u2019s, etc.<p>I tried to cover everything I, and others, might need but recognize that everyones requirements are different. Luckily, this isn\u2019t a framework so removing unneeded packages or adding new ones is as simple it would normally be. The project itself doesn\u2019t come with a demo as its purpose is to simply provide a foundation for any new projects you might have in mind.<p>Feedback is always welcome and I appreciate anyone willing to checkout this project.<p>Thank you and have a great day.", "title": "Show HN: Vite React Boilerplate \u2013 A Production Ready, Scalable Starter Template", "updated_at": "2024-09-20T14:45:12Z", "url": "https://github.com/RicardoValdovinos/vite-react-boilerplate"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "thesssaism"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["husky", "production"], "value": "I recently ran an audit on our latest full-stack repo to figure out why &quot;spinning up a new project&quot; felt like such a heavy lift. I counted every file required just to reach a &quot;<em>production</em>-ready&quot; baseline\u2014before writing a single line of unique feature code.<p>The count was roughly 600 files.<p>To be clear, I'm not talking about a `create-react-app` sandbox. I mean a compliant, scalable SaaS foundation: Next.js frontend, Node.js/NestJS backend, mobile wrapper, CI/CD pipelines, and enough security config to pass a SOC2 audit.<p>It sounds ridiculous (and honestly, it feels ridiculous), but when I broke it down, I couldn't find many files I was willing to delete.<p>Here is where the bloat comes from:<p>First, the &quot;Configuration Hell&quot; accounts for about 40-50 files alone. We aren't just dealing with `package.json` anymore. It's `tsconfig.json` (base), `tsconfig.build.json`, `tsconfig.spec.json`... multiplied across frontend, backend, and shared libraries. Then add `.eslintrc.js`, `.prettierrc`, `jest.config.js`, `vitest.config.ts`, `nodemon.json`, and the Docker-compose variants for dev, test, and prod.<p>Then there\u2019s the DevOps and Quality layer. We have roughly 20-30 files for GitHub Actions workflows (lint, test, build, deploy, semantic release), <em>Husky</em> hooks (pre-commit, commit-msg), and pull request templates.<p>But the real multiplier is the separation of concerns. In a modern monorepo, a &quot;Hello World&quot; isn't just `console.log`. It\u2019s:\n- A NestJS module (Controller, Service, Module, DTO, Entity, Unit Test, E2E Test).\n- A Next.js slice (Page, Component, Type definition, API client wrapper).\n- A shared library entry.<p>We found that adding a single &quot;minimal&quot; API endpoint usually touches 5-7 files just to maintain architectural standards.<p>The trade-off is painful. On one hand, this setup handles the things we used to forget: security headers, proper logging, consistent error handling, and type safety across boundaries. It prevents the &quot;spaghetti code&quot; distinct to startups that scale too fast.<p>On the other hand, the cognitive load of managing a 600-file &quot;empty&quot; project is massive. Updating dependencies becomes a chore because a major version bump in one tool (like ESLint) cascades through forty config files.<p>I\u2019m curious how others are handling this &quot;starting line&quot; complexity.<p>Are you accepting the boilerplate as the cost of doing business? Or have you found a way to strip this down without sacrificing the compliance/safety guardrails that enterprise clients demand?<p>It feels like we've over-engineered the entry point of software development, but I\u2019m not sure what the alternative is for a serious project. We tried going &quot;lean&quot; initially, but spent weeks retrofitting auth and testing harnesses later\u2014which was worse.<p>Is there a middle ground I'm missing, or is ~600 files just the new normal?"}, "title": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["production"], "value": "Tell HN: A <em>production</em>-ready \"Hello World\" is now ~600 files"}}, "_tags": ["story", "author_thesssaism", "story_47074571", "ask_hn"], "author": "thesssaism", "children": [47074794, 47075001, 47075012, 47076406], "created_at": "2026-02-19T15:07:03Z", "created_at_i": 1771513623, "num_comments": 4, "objectID": "47074571", "points": 4, "story_id": 47074571, "story_text": "I recently ran an audit on our latest full-stack repo to figure out why &quot;spinning up a new project&quot; felt like such a heavy lift. I counted every file required just to reach a &quot;production-ready&quot; baseline\u2014before writing a single line of unique feature code.<p>The count was roughly 600 files.<p>To be clear, I&#x27;m not talking about a `create-react-app` sandbox. I mean a compliant, scalable SaaS foundation: Next.js frontend, Node.js&#x2F;NestJS backend, mobile wrapper, CI&#x2F;CD pipelines, and enough security config to pass a SOC2 audit.<p>It sounds ridiculous (and honestly, it feels ridiculous), but when I broke it down, I couldn&#x27;t find many files I was willing to delete.<p>Here is where the bloat comes from:<p>First, the &quot;Configuration Hell&quot; accounts for about 40-50 files alone. We aren&#x27;t just dealing with `package.json` anymore. It&#x27;s `tsconfig.json` (base), `tsconfig.build.json`, `tsconfig.spec.json`... multiplied across frontend, backend, and shared libraries. Then add `.eslintrc.js`, `.prettierrc`, `jest.config.js`, `vitest.config.ts`, `nodemon.json`, and the Docker-compose variants for dev, test, and prod.<p>Then there\u2019s the DevOps and Quality layer. We have roughly 20-30 files for GitHub Actions workflows (lint, test, build, deploy, semantic release), Husky hooks (pre-commit, commit-msg), and pull request templates.<p>But the real multiplier is the separation of concerns. In a modern monorepo, a &quot;Hello World&quot; isn&#x27;t just `console.log`. It\u2019s:\n- A NestJS module (Controller, Service, Module, DTO, Entity, Unit Test, E2E Test).\n- A Next.js slice (Page, Component, Type definition, API client wrapper).\n- A shared library entry.<p>We found that adding a single &quot;minimal&quot; API endpoint usually touches 5-7 files just to maintain architectural standards.<p>The trade-off is painful. On one hand, this setup handles the things we used to forget: security headers, proper logging, consistent error handling, and type safety across boundaries. It prevents the &quot;spaghetti code&quot; distinct to startups that scale too fast.<p>On the other hand, the cognitive load of managing a 600-file &quot;empty&quot; project is massive. Updating dependencies becomes a chore because a major version bump in one tool (like ESLint) cascades through forty config files.<p>I\u2019m curious how others are handling this &quot;starting line&quot; complexity.<p>Are you accepting the boilerplate as the cost of doing business? Or have you found a way to strip this down without sacrificing the compliance&#x2F;safety guardrails that enterprise clients demand?<p>It feels like we&#x27;ve over-engineered the entry point of software development, but I\u2019m not sure what the alternative is for a serious project. We tried going &quot;lean&quot; initially, but spent weeks retrofitting auth and testing harnesses later\u2014which was worse.<p>Is there a middle ground I&#x27;m missing, or is ~600 files just the new normal?", "title": "Tell HN: A production-ready \"Hello World\" is now ~600 files", "updated_at": "2026-02-20T00:09:42Z"}, {"_highlightResult": {"author": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["husky"], "value": "a_bored_<em>husky</em>"}, "title": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["production"], "value": "Companies using Phoenix LiveView in <em>production</em>"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://twitter.com/elixirphoenix/status/1504133097075453953"}}, "_tags": ["story", "author_a_bored_husky", "story_30715218"], "author": "a_bored_husky", "created_at": "2022-03-17T19:54:17Z", "created_at_i": 1647546857, "num_comments": 0, "objectID": "30715218", "points": 4, "story_id": 30715218, "title": "Companies using Phoenix LiveView in production", "updated_at": "2024-09-20T10:43:14Z", "url": "https://twitter.com/elixirphoenix/status/1504133097075453953"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "Croffasia"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["husky", "production"], "value": "The Problem We're Solving<p>Setting up a <em>production</em>-ready Vue.js project takes days. You need to configure TypeScript, set up build tools, choose the right state management, configure linting, add UI components, set up testing\u2014and then teach your AI coding assistant how to work with your specific stack and patterns.<p>By the time you're done with setup, you've lost momentum on your actual idea.<p>The pattern is predictable:<p>Day 1-2: Research and configure build tools, TypeScript, linting \nDay 3-4: Set up state management, routing, UI components\nDay 5-6: Configure development workflow, AI coding instructions \nDay 7+: Finally start building your actual application<p>Most developers either skip best practices to move fast, or spend weeks on setup instead of building.<p>Our Solution: <em>Production</em>-Ready Starter + AI Instructions<p>Vibe Code Kit eliminates the setup phase entirely. You get a battle-tested Vue.js stack that's been refined through dozens of <em>production</em> applications, plus AI development instructions that teach Claude Code how to work effectively with your specific setup.<p>Technology Stack:<p>- Vue 3 with Composition API and TypeScript support\n- Vite for lightning-fast development and optimized builds\n- Pinia for global state management + Pinia Colada for data fetching\n- Tailwind CSS + DaisyUI for rapid UI development\n- VueUse composables library for common patterns\n- ESLint, Prettier, <em>Husky</em> for code quality<p>Each technology includes AI coding best practices that prevent Claude Code from reinventing patterns.<p>How It Works<p>- Blueprint-Driven Development: Enhanced R&amp;D workflow commands guide Claude Code through proper project analysis and feature planning\n- Specialized AI Agents: Built-in agents for standards checking, code validation, and codebase research\n- Stack-Specific Instructions: AI learns the proper patterns for each library in your stack\n- <em>Production</em> Configuration: Everything pre-configured for deployment from day one\n- The result: Turn your ideas into <em>production</em> Vue.js apps in minutes, not days.<p>Real Impact\nSince using this approach:<p>- New Vue.js projects start with feature development, not configuration\n- Claude Code consistently follows Vue 3 Composition API best practices\n- AI agents catch architectural issues before they become problems\n- <em>Production</em> deployments work from day one<p>Technical Details<p>Built on Vue 3 ecosystem best practices. Includes comprehensive Claude Code integration with specialized agents for Vue.js development. Works with existing AI-assisted development workflows and supports rapid prototyping to <em>production</em> scaling.<p>Currently supporting Vue.js projects with plans for React and other frameworks.<p>Try It\nEarly access available at <a href=\"https://vibecodekit.dev\" rel=\"nofollow\">https://vibecodekit.dev</a><p>This isn't about replacing Vue CLI or Vite\u2014it's about getting a <em>production</em>-ready foundation with AI that actually understands your stack. Would love feedback from Vue.js developers who've struggled with project setup overhead.<p>Questions I'm curious about:<p>- How much time do you spend on initial Vue.js project configuration?\n- What's been your experience with AI coding assistants on Vue projects?\n- What would convince you to use a pre-configured starter over building from scratch?"}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Show HN: Vibe Code Kit code with confidence"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://vibecodekit.dev"}}, "_tags": ["story", "author_Croffasia", "story_45216336", "show_hn"], "author": "Croffasia", "children": [45235122], "created_at": "2025-09-11T21:34:46Z", "created_at_i": 1757626486, "num_comments": 1, "objectID": "45216336", "points": 3, "story_id": 45216336, "story_text": "The Problem We&#x27;re Solving<p>Setting up a production-ready Vue.js project takes days. You need to configure TypeScript, set up build tools, choose the right state management, configure linting, add UI components, set up testing\u2014and then teach your AI coding assistant how to work with your specific stack and patterns.<p>By the time you&#x27;re done with setup, you&#x27;ve lost momentum on your actual idea.<p>The pattern is predictable:<p>Day 1-2: Research and configure build tools, TypeScript, linting \nDay 3-4: Set up state management, routing, UI components\nDay 5-6: Configure development workflow, AI coding instructions \nDay 7+: Finally start building your actual application<p>Most developers either skip best practices to move fast, or spend weeks on setup instead of building.<p>Our Solution: Production-Ready Starter + AI Instructions<p>Vibe Code Kit eliminates the setup phase entirely. You get a battle-tested Vue.js stack that&#x27;s been refined through dozens of production applications, plus AI development instructions that teach Claude Code how to work effectively with your specific setup.<p>Technology Stack:<p>- Vue 3 with Composition API and TypeScript support\n- Vite for lightning-fast development and optimized builds\n- Pinia for global state management + Pinia Colada for data fetching\n- Tailwind CSS + DaisyUI for rapid UI development\n- VueUse composables library for common patterns\n- ESLint, Prettier, Husky for code quality<p>Each technology includes AI coding best practices that prevent Claude Code from reinventing patterns.<p>How It Works<p>- Blueprint-Driven Development: Enhanced R&amp;D workflow commands guide Claude Code through proper project analysis and feature planning\n- Specialized AI Agents: Built-in agents for standards checking, code validation, and codebase research\n- Stack-Specific Instructions: AI learns the proper patterns for each library in your stack\n- Production Configuration: Everything pre-configured for deployment from day one\n- The result: Turn your ideas into production Vue.js apps in minutes, not days.<p>Real Impact\nSince using this approach:<p>- New Vue.js projects start with feature development, not configuration\n- Claude Code consistently follows Vue 3 Composition API best practices\n- AI agents catch architectural issues before they become problems\n- Production deployments work from day one<p>Technical Details<p>Built on Vue 3 ecosystem best practices. Includes comprehensive Claude Code integration with specialized agents for Vue.js development. Works with existing AI-assisted development workflows and supports rapid prototyping to production scaling.<p>Currently supporting Vue.js projects with plans for React and other frameworks.<p>Try It\nEarly access available at <a href=\"https:&#x2F;&#x2F;vibecodekit.dev\" rel=\"nofollow\">https:&#x2F;&#x2F;vibecodekit.dev</a><p>This isn&#x27;t about replacing Vue CLI or Vite\u2014it&#x27;s about getting a production-ready foundation with AI that actually understands your stack. Would love feedback from Vue.js developers who&#x27;ve struggled with project setup overhead.<p>Questions I&#x27;m curious about:<p>- How much time do you spend on initial Vue.js project configuration?\n- What&#x27;s been your experience with AI coding assistants on Vue projects?\n- What would convince you to use a pre-configured starter over building from scratch?", "title": "Show HN: Vibe Code Kit code with confidence", "updated_at": "2025-10-06T15:47:47Z", "url": "https://vibecodekit.dev"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "rhinorackattack"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["husky", "production"], "value": "Disclaimer - the goal isn't to build a fully fledged company from this. Rather build a project that developers/startups will find useful as well as generate some income for myself.<p>I\u2019m working on a project to streamline the setup of tech stacks for startups. There are countless free repos on GitHub designed to help startups hit the ground running, but they usually just give you the code, leaving a lot of configuration work to be done. My solution is different: I want to offer a unified platform that integrates with a range of 3rd-party vendors and automatically sets up their cloud environments using API keys or OAuth.<p>The Vision:\nIn my dashboard, users will provide the necessary API keys, and we'll take care of the rest, automatically configuring and deploying the entire tech stack. At the end of the process, they'll have a backend and frontend deployed on AWS, a working RDS, and everything fully terraformed. Think of it as a one-click solution to build and deploy a comprehensive, ready-to-go environment.<p>What\u2019s in the box:<p>The repo is comprised of a monorepo with a FE with a basic auth page for login/logout, backend, shared types, an admin FE dashboard and a whole bunch of necessary and modern technologies to get your *SaaS portal* up and running. (SEO is available but the expectation is that this product is behind a paywall/authwall.<p>The Code:<p>- Monorepo with FE, BE and shared types\n- React + Next.js (frontend)\n- pnpm\n- Nest.js (server)\n- Tailwind\n- Material UI\n- Apollo (GraphQL)\n- Jest (Testing)\n- Typescript + ESLint + Prettier + <em>Husky</em>\n- Turbo\n- TypeORM\n- Segment\n- Database migrations\n- Docker\n- Logging (Pino.js)<p>Configuration:<p>- Terraform\n- GitHub Actions (CI/CD)\n- Local DB env with docker compose<p>Deployment (3rd Parties):<p>- Sentry\n- Auth0\n- Analytics\n- Stripe\n- Managed staging/<em>production</em> on AWS\n- Storage with S3\n- Langchain (ChatGPT)\n- Feature Flags (LaunchDarkly)\n- Mail (mailgun) + Notifications (SNS)\n- Postgres (RDS)\n- Lambdas with SAM<p>Features:<p>- Shared types\n- Langchain\n- Admin dashboard\n- CLI\n- Docs<p>Extras:<p>- Storybook\n- SEO\n- i18n<p>The Value Proposition:<p>- Unified Setup: Quickly deploy a <em>production</em>-ready tech stack with minimal configuration.\n- Reduced Complexity: Even with bots and automations, setting up AWS and other tools can be complex. This tool simplifies the entire process.<p>Why Build This:<p>- Complexity Management: Managing roles and deployments across various cloud platforms can be a headache. This tool pulls together all the essential components and simplifies the deployment process.\n- Engineer-Level Setup: You typically need an engineer to set up AWS, but this solution makes it trivial for non-tech founders to deploy a professional-grade infrastructure across a wide range of necessary services to run your start up.<p>I'm looking for feedback and validation on this idea. What do you think?<p>Some Initial Questions:<p>- I\u2019m not presenting vendor alternatives for the MVP. Maybe later I can present more vendor options, but for now I\u2019m trying to take the vendor decision-making process away from the startups so they can just focus on building the products. Will this present some problems?\n- I\u2019ve chosen AWS because startups often have to spend time learning about AWS and having users, env, compute, DBs, storage etc auto set up will allow them to focus on building their product and not on complex infrastructure. Once they\u2019re in the ecosystem, they can leverage more of it. I know there are more modern and streamlined alternatives to some of these services e.g. Vercel, Cloudflare, Firebase, Railway, Digital Ocean app platform, Render, Aptible; or when it comes to databases; planetDB or SurrealDB etc.<p>Business Model:<p>- Offer the code for free, once off fee for auto deployment and set up"}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Ask HN: Idea Validation"}}, "_tags": ["story", "author_rhinorackattack", "story_40314582", "ask_hn"], "author": "rhinorackattack", "children": [40314703, 40314823, 40380254], "created_at": "2024-05-10T01:08:44Z", "created_at_i": 1715303324, "num_comments": 3, "objectID": "40314582", "points": 1, "story_id": 40314582, "story_text": "Disclaimer - the goal isn&#x27;t to build a fully fledged company from this. Rather build a project that developers&#x2F;startups will find useful as well as generate some income for myself.<p>I\u2019m working on a project to streamline the setup of tech stacks for startups. There are countless free repos on GitHub designed to help startups hit the ground running, but they usually just give you the code, leaving a lot of configuration work to be done. My solution is different: I want to offer a unified platform that integrates with a range of 3rd-party vendors and automatically sets up their cloud environments using API keys or OAuth.<p>The Vision:\nIn my dashboard, users will provide the necessary API keys, and we&#x27;ll take care of the rest, automatically configuring and deploying the entire tech stack. At the end of the process, they&#x27;ll have a backend and frontend deployed on AWS, a working RDS, and everything fully terraformed. Think of it as a one-click solution to build and deploy a comprehensive, ready-to-go environment.<p>What\u2019s in the box:<p>The repo is comprised of a monorepo with a FE with a basic auth page for login&#x2F;logout, backend, shared types, an admin FE dashboard and a whole bunch of necessary and modern technologies to get your *SaaS portal* up and running. (SEO is available but the expectation is that this product is behind a paywall&#x2F;authwall.<p>The Code:<p>- Monorepo with FE, BE and shared types\n- React + Next.js (frontend)\n- pnpm\n- Nest.js (server)\n- Tailwind\n- Material UI\n- Apollo (GraphQL)\n- Jest (Testing)\n- Typescript + ESLint + Prettier + Husky\n- Turbo\n- TypeORM\n- Segment\n- Database migrations\n- Docker\n- Logging (Pino.js)<p>Configuration:<p>- Terraform\n- GitHub Actions (CI&#x2F;CD)\n- Local DB env with docker compose<p>Deployment (3rd Parties):<p>- Sentry\n- Auth0\n- Analytics\n- Stripe\n- Managed staging&#x2F;production on AWS\n- Storage with S3\n- Langchain (ChatGPT)\n- Feature Flags (LaunchDarkly)\n- Mail (mailgun) + Notifications (SNS)\n- Postgres (RDS)\n- Lambdas with SAM<p>Features:<p>- Shared types\n- Langchain\n- Admin dashboard\n- CLI\n- Docs<p>Extras:<p>- Storybook\n- SEO\n- i18n<p>The Value Proposition:<p>- Unified Setup: Quickly deploy a production-ready tech stack with minimal configuration.\n- Reduced Complexity: Even with bots and automations, setting up AWS and other tools can be complex. This tool simplifies the entire process.<p>Why Build This:<p>- Complexity Management: Managing roles and deployments across various cloud platforms can be a headache. This tool pulls together all the essential components and simplifies the deployment process.\n- Engineer-Level Setup: You typically need an engineer to set up AWS, but this solution makes it trivial for non-tech founders to deploy a professional-grade infrastructure across a wide range of necessary services to run your start up.<p>I&#x27;m looking for feedback and validation on this idea. What do you think?<p>Some Initial Questions:<p>- I\u2019m not presenting vendor alternatives for the MVP. Maybe later I can present more vendor options, but for now I\u2019m trying to take the vendor decision-making process away from the startups so they can just focus on building the products. Will this present some problems?\n- I\u2019ve chosen AWS because startups often have to spend time learning about AWS and having users, env, compute, DBs, storage etc auto set up will allow them to focus on building their product and not on complex infrastructure. Once they\u2019re in the ecosystem, they can leverage more of it. I know there are more modern and streamlined alternatives to some of these services e.g. Vercel, Cloudflare, Firebase, Railway, Digital Ocean app platform, Render, Aptible; or when it comes to databases; planetDB or SurrealDB etc.<p>Business Model:<p>- Offer the code for free, once off fee for auto deployment and set up", "title": "Ask HN: Idea Validation", "updated_at": "2025-02-26T22:31:53Z"}], "hitsPerPage": 15, "nbHits": 5, "nbPages": 1, "page": 0, "params": "query=husky+production&tags=story&hitsPerPage=15&advancedSyntax=true&analyticsTags=backend", "processingTimeMS": 10, "processingTimingsMS": {"_request": {"roundTrip": 21}, "afterFetch": {"format": {"total": 1}}, "fetch": {"query": 7, "scanning": 1, "total": 9}, "total": 10}, "query": "husky production", "serverTimeMS": 11}}