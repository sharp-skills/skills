{"d": {"exhaustive": {"nbHits": false, "typo": false}, "exhaustiveNbHits": false, "exhaustiveTypo": false, "hits": [{"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "kobvel"}, "title": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["gitlab", "ci", "production"], "value": "From Zero to <em>Production</em> with Angular, Firebase, and <em>GitLab CI</em>"}, "url": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["gitlab", "ci", "production"], "value": "https://medium.com/@kobvel/from-zero-to-<em>production</em>-with-angular-firebase-and-<em>gitlab-ci</em>-598181cfc6e5"}}, "_tags": ["story", "author_kobvel", "story_15617720"], "author": "kobvel", "created_at": "2017-11-03T09:14:46Z", "created_at_i": 1509700486, "num_comments": 0, "objectID": "15617720", "points": 2, "story_id": 15617720, "title": "From Zero to Production with Angular, Firebase, and GitLab CI", "updated_at": "2024-09-20T01:33:51Z", "url": "https://medium.com/@kobvel/from-zero-to-production-with-angular-firebase-and-gitlab-ci-598181cfc6e5"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "CA0DA"}, "title": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["gitlab", "ci"], "value": "<em>Gitlab CI</em> runner apdex drop causing delays in pipeline processing"}, "url": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["production"], "value": "https://gitlab.com/gitlab-com/gl-infra/<em>production</em>/-/issues/4156"}}, "_tags": ["story", "author_CA0DA", "story_26724585"], "author": "CA0DA", "created_at": "2021-04-07T13:28:04Z", "created_at_i": 1617802084, "num_comments": 0, "objectID": "26724585", "points": 1, "story_id": 26724585, "title": "Gitlab CI runner apdex drop causing delays in pipeline processing", "updated_at": "2024-09-20T08:18:17Z", "url": "https://gitlab.com/gitlab-com/gl-infra/production/-/issues/4156"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "vmatsiiako"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["gitlab", "ci", "production"], "value": "Hi HN, we\u2019re the co-founders of Infisical (<a href=\"https://infisical.com\">https://infisical.com</a>), an open-source platform to sync application secrets and configs across your engineering team and infrastructure. We enable teams to store their secrets in a centralized location and distribute them anywhere from local development processes to staging/<em>production</em> environments.<p>Our Github is at <a href=\"https://github.com/infisical/infisical\">https://github.com/infisical/infisical</a>.<p>We previously worked at AWS, Figma, and another startup, where we frequently ran into problems dealing with secret management. For example, many companies used .env files to maintain their development secrets and struggled to keep secrets in sync amongst their teams (this routinely posed security and efficiency issues \u2014 secrets can get leaked or go missing). Some companies (especially bigger ones) used solutions like Vault which can be difficult to set up, maintain, and afford.<p>While secret managers exist, they\u2019re imperfect for many reasons: open-source solutions are either too complicated, not comprehensive, not user-friendly, or a mix of all three; there are nicer closed-source solutions but with no self-hosted options available. The gap we see is to make something that\u2019s simple, open-source, and powerful.<p>On the open-source front, our goal is to provide full transparency of our codebase and enable anyone in the community to build anything they want in an optimal secret management solution. If you need any feature or integration that we don\u2019t yet support, you can post an issue about it or directly send in a PR to be reviewed immediately.<p>You can inject the right set of secrets for any environment into your application by using the Infisical CLI together with your application start command (e.g. infisical run -- npm run dev). This removes the need to use a .env file. Everything stays encrypted with encryption/decryption operations occurring on the client-side \u2014 under the hood, secrets are encrypted by vault keys for which there are multiple copies of vault keys encrypted under the public key of each member of a vault (ensuring only members of vaults can decrypt secrets pertaining to that vault locally). An alternative way is to use our Open API - though it\u2019s a little complicated, and we\u2019re working on adding SDKs to abstract away the cryptography.<p>Infisical integrates with staging and <em>production</em> cloud services like AWS, Vercel, GitHub Actions, and Circle CI. We also added support for integrations with Docker, Kubernetes, and Terraform. Infisical is now a central source of truth for secrets across the entire development cycle from development to <em>production</em> with new integration releases every week.\nOne interesting thing is that, by default, our platform is end-to-end encrypted but users can opt out of that if they need to integrate with cloud platforms that require secrets to be sent in decrypted format (e.g. GitHub Actions, Vercel, Render). We\u2019re the only solution that we know of that offers this E2EE-with opt-out ability.<p>Since our last Show HN (<a href=\"https://news.ycombinator.com/item?id=34510516\" rel=\"nofollow\">https://news.ycombinator.com/item?id=34510516</a>), we\u2019ve layered authentication with 2FA (more MFA options coming soon) and upgraded all private key encryption/decryption steps to involve a 256-bit protected key decrypted by another key generated via Argon2id KDF from the user\u2019s password. We are starting the process of obtaining SOC2 and other security and compliance certifications. You can read more about our security here: <a href=\"https://infisical.com/docs/security/overview\">https://infisical.com/docs/security/overview</a><p>Beyond this, we\u2019ve added integrations with PM2, AWS Secrets Manager, AWS Parameter Store, Circle CI, Travis CI, <em>GitLab CI</em>/CD, Terraform and more. We\u2019ve also redesigned the main dashboard and added more advanced organizational structure for secrets. Lastly, we have added role-based access control, and improved our Kubernetes operator: your clusters are now auto-redeployed when secrets in Infisical change. In the coming weeks and months, we plan to add features like secret rotation, improved audit logs, SDKs and alerts; as well as increase the range of our integrations; and continue fortifying platform security and stability.<p>We\u2019ve launched this repo under the MIT license so any developer can use the platform. We don\u2019t charge individual developers or small teams\u2014all the integrations are fully available to everyone. We make money by charging a license fee for enterprise features as well as providing a hosted version and support.<p>If you found it interesting, you can see a demo video here: <a href=\"https://www.loom.com/share/9a8904c6ecc84d0899d53ee1f7a36385\" rel=\"nofollow\">https://www.loom.com/share/9a8904c6ecc84d0899d53ee1f7a36385</a><p>We\u2019d love for you to give Infisical a try (<a href=\"https://infisical.com\">https://infisical.com</a>) and provide any feedback. If you're interested, our code is available here: <a href=\"https://github.com/infisical/infisical\">https://github.com/infisical/infisical</a>. If we don\u2019t have something, let us know and we\u2019d be happy to build it for you. We look forward to your comments!"}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Launch HN: Infisical (YC W23) \u2013 Open-source secrets manager for developers"}}, "_tags": ["story", "author_vmatsiiako", "story_34955699", "launch_hn"], "author": "vmatsiiako", "children": [34955766, 34956280, 34956303, 34956309, 34956386, 34956484, 34956666, 34956694, 34956746, 34956759, 34956928, 34957054, 34957380, 34957529, 34957673, 34957748, 34958009, 34958209, 34958403, 34959016, 34959650, 34961850, 34962065, 34963142, 34963683, 34964525, 34964797, 34967332, 34967354], "created_at": "2023-02-27T12:39:29Z", "created_at_i": 1677501569, "num_comments": 121, "objectID": "34955699", "points": 231, "story_id": 34955699, "story_text": "Hi HN, we\u2019re the co-founders of Infisical (<a href=\"https:&#x2F;&#x2F;infisical.com\">https:&#x2F;&#x2F;infisical.com</a>), an open-source platform to sync application secrets and configs across your engineering team and infrastructure. We enable teams to store their secrets in a centralized location and distribute them anywhere from local development processes to staging&#x2F;production environments.<p>Our Github is at <a href=\"https:&#x2F;&#x2F;github.com&#x2F;infisical&#x2F;infisical\">https:&#x2F;&#x2F;github.com&#x2F;infisical&#x2F;infisical</a>.<p>We previously worked at AWS, Figma, and another startup, where we frequently ran into problems dealing with secret management. For example, many companies used .env files to maintain their development secrets and struggled to keep secrets in sync amongst their teams (this routinely posed security and efficiency issues \u2014 secrets can get leaked or go missing). Some companies (especially bigger ones) used solutions like Vault which can be difficult to set up, maintain, and afford.<p>While secret managers exist, they\u2019re imperfect for many reasons: open-source solutions are either too complicated, not comprehensive, not user-friendly, or a mix of all three; there are nicer closed-source solutions but with no self-hosted options available. The gap we see is to make something that\u2019s simple, open-source, and powerful.<p>On the open-source front, our goal is to provide full transparency of our codebase and enable anyone in the community to build anything they want in an optimal secret management solution. If you need any feature or integration that we don\u2019t yet support, you can post an issue about it or directly send in a PR to be reviewed immediately.<p>You can inject the right set of secrets for any environment into your application by using the Infisical CLI together with your application start command (e.g. infisical run -- npm run dev). This removes the need to use a .env file. Everything stays encrypted with encryption&#x2F;decryption operations occurring on the client-side \u2014 under the hood, secrets are encrypted by vault keys for which there are multiple copies of vault keys encrypted under the public key of each member of a vault (ensuring only members of vaults can decrypt secrets pertaining to that vault locally). An alternative way is to use our Open API - though it\u2019s a little complicated, and we\u2019re working on adding SDKs to abstract away the cryptography.<p>Infisical integrates with staging and production cloud services like AWS, Vercel, GitHub Actions, and Circle CI. We also added support for integrations with Docker, Kubernetes, and Terraform. Infisical is now a central source of truth for secrets across the entire development cycle from development to production with new integration releases every week.\nOne interesting thing is that, by default, our platform is end-to-end encrypted but users can opt out of that if they need to integrate with cloud platforms that require secrets to be sent in decrypted format (e.g. GitHub Actions, Vercel, Render). We\u2019re the only solution that we know of that offers this E2EE-with opt-out ability.<p>Since our last Show HN (<a href=\"https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=34510516\" rel=\"nofollow\">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=34510516</a>), we\u2019ve layered authentication with 2FA (more MFA options coming soon) and upgraded all private key encryption&#x2F;decryption steps to involve a 256-bit protected key decrypted by another key generated via Argon2id KDF from the user\u2019s password. We are starting the process of obtaining SOC2 and other security and compliance certifications. You can read more about our security here: <a href=\"https:&#x2F;&#x2F;infisical.com&#x2F;docs&#x2F;security&#x2F;overview\">https:&#x2F;&#x2F;infisical.com&#x2F;docs&#x2F;security&#x2F;overview</a><p>Beyond this, we\u2019ve added integrations with PM2, AWS Secrets Manager, AWS Parameter Store, Circle CI, Travis CI, GitLab CI&#x2F;CD, Terraform and more. We\u2019ve also redesigned the main dashboard and added more advanced organizational structure for secrets. Lastly, we have added role-based access control, and improved our Kubernetes operator: your clusters are now auto-redeployed when secrets in Infisical change. In the coming weeks and months, we plan to add features like secret rotation, improved audit logs, SDKs and alerts; as well as increase the range of our integrations; and continue fortifying platform security and stability.<p>We\u2019ve launched this repo under the MIT license so any developer can use the platform. We don\u2019t charge individual developers or small teams\u2014all the integrations are fully available to everyone. We make money by charging a license fee for enterprise features as well as providing a hosted version and support.<p>If you found it interesting, you can see a demo video here: <a href=\"https:&#x2F;&#x2F;www.loom.com&#x2F;share&#x2F;9a8904c6ecc84d0899d53ee1f7a36385\" rel=\"nofollow\">https:&#x2F;&#x2F;www.loom.com&#x2F;share&#x2F;9a8904c6ecc84d0899d53ee1f7a36385</a><p>We\u2019d love for you to give Infisical a try (<a href=\"https:&#x2F;&#x2F;infisical.com\">https:&#x2F;&#x2F;infisical.com</a>) and provide any feedback. If you&#x27;re interested, our code is available here: <a href=\"https:&#x2F;&#x2F;github.com&#x2F;infisical&#x2F;infisical\">https:&#x2F;&#x2F;github.com&#x2F;infisical&#x2F;infisical</a>. If we don\u2019t have something, let us know and we\u2019d be happy to build it for you. We look forward to your comments!", "title": "Launch HN: Infisical (YC W23) \u2013 Open-source secrets manager for developers", "updated_at": "2025-07-30T03:53:08Z"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "suryao"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["gitlab", "ci", "production"], "value": "Hello HN, I'm Surya, the founder of Argonaut (<a href=\"https://www.argonaut.dev/\">https://www.argonaut.dev/</a>), a unified platform that tries to make software ops painless, so teams can focus on building features instead of building and managing infrastructure. Argonaut combines Kubernetes PaaS, a CI pipeline builder, and a Terraform state manager with prebuilt AWS and GCP modules. Here\u2019s a demo: <a href=\"https://www.youtube.com/watch?v=8DZsYXxA2tQ\">https://www.youtube.com/watch?v=8DZsYXxA2tQ</a>.<p>I\u2019ve helped build infrastructure tooling from scratch at multiple companies and realized two things: that the shape of the solution with the advent of containerization, Kubernetes, and hyperscalers is quite similar across orgs, and that highly knowledgeable engineers are needed to build and manage this system.<p>Internal infrastructure teams juggle a multitude of tasks\u2014provisioning cloud infrastructure, configuring runtimes, building code, securing artifacts, running tests, and deploying at scale. Post-deployment, they're also tasked with monitoring app performance, errors, uptime, and cost visibility. It's a lot of work, and having to build this tooling in-house is a deep inefficiency in engineering teams. The root of the problem is that AWS and GCP provide a lower level of abstraction than the entities, such as environments and applications, that developers have to deal with, and a ton of work is getting duplicated, often by underfunded teams, across many orgs. Argonaut\u2019s objective is to be the developer platform and control center that you would otherwise have to build internally.<p>Argonaut provides an intuitive developer experience that simplifies working with Kubernetes and enables developer self-service, reducing the burden on devops and platform teams. We've productized this workflow orchestration, incorporating best practices to provide a push-to-deploy experience with flexible pipelines and scalable infrastructure, all within minutes.<p>Our users are startups across various domains like healthcare, IoT, fintech, AI, and SaaS products. Over the last two years, we\u2019ve enabled customers to scale their engineering teams 10x and manage 10+ environments in parallel without needing a dedicated infra/DevOps team, saving them precious time and resources.<p>Argonaut lets you set up <em>production</em>-ready infrastructure and customize as you scale. We then let you set up automated deployments of your application in minutes. We offer configurable build-and-deploy pipelines, powered by Dagger and ArgoCD, and deep integration with GitHub Actions and <em>GitLab CI</em>.  In addition, we support container registries, multiple cloud accounts, observability stacks, cost visibility providers, CDNs, and the entire helm chart ecosystem of Kubernetes, with more integrations on the way.<p>Key features include: (1) easily create environments encapsulating cloud infrastructure, applications, and deployment pipelines (2) autoscaling deployments for apps and cronjobs to GCP and AWS with a progression across environments (3) compose deployments across multiple environments with our visual pipeline builder (4) get cost estimates before making infra changes, giving you a clear understanding of your expenses; (5) managed Terraform state and pre-built modules that just work, fostering team collaboration on infrastructure.<p>Argonaut is self-serve, so you can sign up and start using the product right away: <a href=\"https://ship.argonaut.dev\">https://ship.argonaut.dev</a>. There is a free tier that doesn't require a credit card to get started. We'd be delighted to have you try it, and are happy to help with onboarding.<p>If your teams work with AWS, GCP, or Kubernetes, I\u2019d love to hear about your experiences, pain points, and what you think a product like Argonaut should be able to do. Looking forward to your comments!"}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Launch HN: Argonaut (YC S21) \u2013 Easily Deploy Apps and Infra to AWS and GCP"}}, "_tags": ["story", "author_suryao", "story_36480230", "launch_hn"], "author": "suryao", "children": [36480563, 36481562, 36481779, 36481788, 36481867, 36481946, 36481958, 36482015, 36482017, 36482292, 36482375, 36482570, 36483009, 36483364, 36483568, 36484649, 36484751, 36484791, 36485216, 36485392, 36485534, 36485547, 36486525, 36486646, 36487852, 36488032, 36489557], "created_at": "2023-06-26T14:41:47Z", "created_at_i": 1687790507, "num_comments": 76, "objectID": "36480230", "points": 152, "story_id": 36480230, "story_text": "Hello HN, I&#x27;m Surya, the founder of Argonaut (<a href=\"https:&#x2F;&#x2F;www.argonaut.dev&#x2F;\">https:&#x2F;&#x2F;www.argonaut.dev&#x2F;</a>), a unified platform that tries to make software ops painless, so teams can focus on building features instead of building and managing infrastructure. Argonaut combines Kubernetes PaaS, a CI pipeline builder, and a Terraform state manager with prebuilt AWS and GCP modules. Here\u2019s a demo: <a href=\"https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=8DZsYXxA2tQ\">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=8DZsYXxA2tQ</a>.<p>I\u2019ve helped build infrastructure tooling from scratch at multiple companies and realized two things: that the shape of the solution with the advent of containerization, Kubernetes, and hyperscalers is quite similar across orgs, and that highly knowledgeable engineers are needed to build and manage this system.<p>Internal infrastructure teams juggle a multitude of tasks\u2014provisioning cloud infrastructure, configuring runtimes, building code, securing artifacts, running tests, and deploying at scale. Post-deployment, they&#x27;re also tasked with monitoring app performance, errors, uptime, and cost visibility. It&#x27;s a lot of work, and having to build this tooling in-house is a deep inefficiency in engineering teams. The root of the problem is that AWS and GCP provide a lower level of abstraction than the entities, such as environments and applications, that developers have to deal with, and a ton of work is getting duplicated, often by underfunded teams, across many orgs. Argonaut\u2019s objective is to be the developer platform and control center that you would otherwise have to build internally.<p>Argonaut provides an intuitive developer experience that simplifies working with Kubernetes and enables developer self-service, reducing the burden on devops and platform teams. We&#x27;ve productized this workflow orchestration, incorporating best practices to provide a push-to-deploy experience with flexible pipelines and scalable infrastructure, all within minutes.<p>Our users are startups across various domains like healthcare, IoT, fintech, AI, and SaaS products. Over the last two years, we\u2019ve enabled customers to scale their engineering teams 10x and manage 10+ environments in parallel without needing a dedicated infra&#x2F;DevOps team, saving them precious time and resources.<p>Argonaut lets you set up production-ready infrastructure and customize as you scale. We then let you set up automated deployments of your application in minutes. We offer configurable build-and-deploy pipelines, powered by Dagger and ArgoCD, and deep integration with GitHub Actions and GitLab CI.  In addition, we support container registries, multiple cloud accounts, observability stacks, cost visibility providers, CDNs, and the entire helm chart ecosystem of Kubernetes, with more integrations on the way.<p>Key features include: (1) easily create environments encapsulating cloud infrastructure, applications, and deployment pipelines (2) autoscaling deployments for apps and cronjobs to GCP and AWS with a progression across environments (3) compose deployments across multiple environments with our visual pipeline builder (4) get cost estimates before making infra changes, giving you a clear understanding of your expenses; (5) managed Terraform state and pre-built modules that just work, fostering team collaboration on infrastructure.<p>Argonaut is self-serve, so you can sign up and start using the product right away: <a href=\"https:&#x2F;&#x2F;ship.argonaut.dev\">https:&#x2F;&#x2F;ship.argonaut.dev</a>. There is a free tier that doesn&#x27;t require a credit card to get started. We&#x27;d be delighted to have you try it, and are happy to help with onboarding.<p>If your teams work with AWS, GCP, or Kubernetes, I\u2019d love to hear about your experiences, pain points, and what you think a product like Argonaut should be able to do. Looking forward to your comments!", "title": "Launch HN: Argonaut (YC S21) \u2013 Easily Deploy Apps and Infra to AWS and GCP", "updated_at": "2025-04-29T16:07:26Z"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "pacmansyyu"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["gitlab", "ci", "production"], "value": "Hi HN, I've been building this tool for the past couple of weeks to solve a problem that seems universal across development teams: sharing environment variables securely.<p>You know the drill - someone needs the staging database URL, so it gets shared over chat. <em>Production</em> API keys end up in plaintext files. Or you set up some complex secret management system that becomes a single point of failure during critical deployments.<p>At Zerodha, we're a stock broker with strict regulatory requirements. Our infrastructure needs to be auditable, and our data must stay with us for instant recovery. But the deeper issue was that every solution we tried made deployments dependent on external services.<p>We tried <em>GitLab CI's</em> built-in secrets, but they're stored unencrypted and only repository maintainers can access them. HashiCorp Vault was too complex to manage with painful ACL setup, plus it's now crippled by their BSL license change. AWS Secrets Manager would create the vendor lock-in we wanted to avoid.<p>The breaking point came when we wanted to manage secrets through Terraform for idempotency and better infrastructure-as-code practices. But Terraform has no built-in way to encrypt secrets without relying on external providers. We could either store secrets in plaintext in our Terraform configs or add yet another external dependency to our deployment pipeline.<p>That's when I had the idea: what if we could inject encrypted environment variables directly into Terraform, so anyone with the right key could deploy without hunting down secrets from different systems? As I iterated through this idea, I realized the same pattern would work for any application - from personal projects to team deployments.<p>So I built kiln. It encrypts environment variables using age encryption into files that live alongside your code. No servers, no network calls, no external dependencies. Each team member gets their own key, and you control access per environment.<p>Here's how it works:<p><pre><code>  # Generate a new age key, or use your existing SSH keys\n  kiln init key\n  \n  # Initialize with your team's public keys\n  kiln init config --recipients &quot;alice=$(curl https://gitlab.company/alice.keys)&quot; --recipients &quot;me=$(cat ~/.ssh/id_ed25519.pub)&quot;\n  \n  # Set secrets (prompts securely, never shows in terminal)\n  kiln set DATABASE_URL\n  kiln set API_KEY\n  \n  # Run your app with decrypted environment\n  kiln run npm start\n  \n\n  # These encrypted files are safe to commit\n  git add .kiln.env kiln.toml\n\n</code></pre>\nWhy not SOPS? SOPS is great for general file encryption, but kiln is built specifically for the environment variable workflow. It has commands like &quot;run&quot;, &quot;export&quot;, and built-in team management. Think &quot;SOPS for .env files&quot; with a focus on developer UX.<p>Why not raw age encryption? Age is perfect for the crypto layer, but terrible for day-to-day team workflows. Try managing 20 team members across 5 environments with raw age commands - you'll go insane. kiln handles the orchestration.<p>As for technical details, kiln:<p>- Uses age encryption (modern, audited, simple)<p>- Works with existing SSH keys or generates new age keys<p>- Role-based access via TOML configuration<p>- Single, cross-platform Go binary<p>- Zero network dependencies - everything works offline<p>- MIT licensed<p>The game-changer: secrets travel with code. No more &quot;can someone send me the staging secrets?&quot; in chat. No more broken deploys because the secret service is down. No more hoping your vendor doesn't change their pricing or licensing.<p>Try it out - I'm confident it'll help improve your team's deployment workflows. Feel free to ask me any questions!<p>GitHub: <a href=\"https://github.com/thunderbottom/kiln\">https://github.com/thunderbottom/kiln</a><p>Docs: <a href=\"https://kiln.sh\" rel=\"nofollow\">https://kiln.sh</a><p>Or install now: go install github.com/thunderbottom/kiln@latest"}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Show HN: kiln \u2013 Git-native, decentralized secret management using age"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://kiln.sh/"}}, "_tags": ["story", "author_pacmansyyu", "story_44594367", "show_hn"], "author": "pacmansyyu", "children": [44594618], "created_at": "2025-07-17T15:23:24Z", "created_at_i": 1752765804, "num_comments": 2, "objectID": "44594367", "points": 12, "story_id": 44594367, "story_text": "Hi HN, I&#x27;ve been building this tool for the past couple of weeks to solve a problem that seems universal across development teams: sharing environment variables securely.<p>You know the drill - someone needs the staging database URL, so it gets shared over chat. Production API keys end up in plaintext files. Or you set up some complex secret management system that becomes a single point of failure during critical deployments.<p>At Zerodha, we&#x27;re a stock broker with strict regulatory requirements. Our infrastructure needs to be auditable, and our data must stay with us for instant recovery. But the deeper issue was that every solution we tried made deployments dependent on external services.<p>We tried GitLab CI&#x27;s built-in secrets, but they&#x27;re stored unencrypted and only repository maintainers can access them. HashiCorp Vault was too complex to manage with painful ACL setup, plus it&#x27;s now crippled by their BSL license change. AWS Secrets Manager would create the vendor lock-in we wanted to avoid.<p>The breaking point came when we wanted to manage secrets through Terraform for idempotency and better infrastructure-as-code practices. But Terraform has no built-in way to encrypt secrets without relying on external providers. We could either store secrets in plaintext in our Terraform configs or add yet another external dependency to our deployment pipeline.<p>That&#x27;s when I had the idea: what if we could inject encrypted environment variables directly into Terraform, so anyone with the right key could deploy without hunting down secrets from different systems? As I iterated through this idea, I realized the same pattern would work for any application - from personal projects to team deployments.<p>So I built kiln. It encrypts environment variables using age encryption into files that live alongside your code. No servers, no network calls, no external dependencies. Each team member gets their own key, and you control access per environment.<p>Here&#x27;s how it works:<p><pre><code>  # Generate a new age key, or use your existing SSH keys\n  kiln init key\n  \n  # Initialize with your team&#x27;s public keys\n  kiln init config --recipients &quot;alice=$(curl https:&#x2F;&#x2F;gitlab.company&#x2F;alice.keys)&quot; --recipients &quot;me=$(cat ~&#x2F;.ssh&#x2F;id_ed25519.pub)&quot;\n  \n  # Set secrets (prompts securely, never shows in terminal)\n  kiln set DATABASE_URL\n  kiln set API_KEY\n  \n  # Run your app with decrypted environment\n  kiln run npm start\n  \n\n  # These encrypted files are safe to commit\n  git add .kiln.env kiln.toml\n\n</code></pre>\nWhy not SOPS? SOPS is great for general file encryption, but kiln is built specifically for the environment variable workflow. It has commands like &quot;run&quot;, &quot;export&quot;, and built-in team management. Think &quot;SOPS for .env files&quot; with a focus on developer UX.<p>Why not raw age encryption? Age is perfect for the crypto layer, but terrible for day-to-day team workflows. Try managing 20 team members across 5 environments with raw age commands - you&#x27;ll go insane. kiln handles the orchestration.<p>As for technical details, kiln:<p>- Uses age encryption (modern, audited, simple)<p>- Works with existing SSH keys or generates new age keys<p>- Role-based access via TOML configuration<p>- Single, cross-platform Go binary<p>- Zero network dependencies - everything works offline<p>- MIT licensed<p>The game-changer: secrets travel with code. No more &quot;can someone send me the staging secrets?&quot; in chat. No more broken deploys because the secret service is down. No more hoping your vendor doesn&#x27;t change their pricing or licensing.<p>Try it out - I&#x27;m confident it&#x27;ll help improve your team&#x27;s deployment workflows. Feel free to ask me any questions!<p>GitHub: <a href=\"https:&#x2F;&#x2F;github.com&#x2F;thunderbottom&#x2F;kiln\">https:&#x2F;&#x2F;github.com&#x2F;thunderbottom&#x2F;kiln</a><p>Docs: <a href=\"https:&#x2F;&#x2F;kiln.sh\" rel=\"nofollow\">https:&#x2F;&#x2F;kiln.sh</a><p>Or install now: go install github.com&#x2F;thunderbottom&#x2F;kiln@latest", "title": "Show HN: kiln \u2013 Git-native, decentralized secret management using age", "updated_at": "2025-07-17T18:04:21Z", "url": "https://kiln.sh/"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "xmatos"}, "story_text": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["production"], "value": "We use GitLab at my job (goread.com) and I've been taking a look at its continuous integration feature. I wanted to see if we could automate our deployments, specially to our staging environment.<p>Today, we use git feature branches and handle deployment to both staging and <em>production</em> using python's fabric.<p>By default, GitLab's CI runs on every feature branch push, which I dislike, since you can push a feature branch that isn't ready for testing, for backup purposes. Although, it can be configured to automatically deploy only to staging, while having <em>production</em> deployment manually triggered. It can also run only on specific branches, like staging and master.<p>I was after a way to integrate deployment with task status updates, so once we updated a task status to Staging, for example, it would trigger a job to merge that task's feature branches to staging and deploy it. Once it gets tested and approved, we would update the task status to Approved, which would trigger a master merge and a push to <em>production</em>. To me, this would be the perfect solution.<p>Unfortunately, that's not how it works. It might be achievable through GitLab's web hooks and api, but i don't think it has a way to add a custom field to a task to store the related git branches and it only has an open / close status. We could use labels instead and parse the task description to extract the branch info.<p>What I've done in the past and worked great is use git hooks for deployment. Basically, we would add the fabric tasks functionality to the post_receive git hook, so once we push the staging or master branch, it would automatically trigger deployment. That would handle deployment's heavy lift, but I'd still like to automate branch merging, by linking it to task status.<p>In short, what I'd like to achieve is deployment based on task status updates.<p>Has anyone done that? Is it a good idea? Are there any caveats?<p>Any tips or ideas would be highly appeciated. Thanks!"}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Ask HN: GitLab Continuous Integration"}}, "_tags": ["story", "author_xmatos", "story_14453176", "ask_hn"], "author": "xmatos", "children": [14457140], "created_at": "2017-05-31T15:18:32Z", "created_at_i": 1496243912, "num_comments": 1, "objectID": "14453176", "points": 3, "story_id": 14453176, "story_text": "We use GitLab at my job (goread.com) and I&#x27;ve been taking a look at its continuous integration feature. I wanted to see if we could automate our deployments, specially to our staging environment.<p>Today, we use git feature branches and handle deployment to both staging and production using python&#x27;s fabric.<p>By default, GitLab&#x27;s CI runs on every feature branch push, which I dislike, since you can push a feature branch that isn&#x27;t ready for testing, for backup purposes. Although, it can be configured to automatically deploy only to staging, while having production deployment manually triggered. It can also run only on specific branches, like staging and master.<p>I was after a way to integrate deployment with task status updates, so once we updated a task status to Staging, for example, it would trigger a job to merge that task&#x27;s feature branches to staging and deploy it. Once it gets tested and approved, we would update the task status to Approved, which would trigger a master merge and a push to production. To me, this would be the perfect solution.<p>Unfortunately, that&#x27;s not how it works. It might be achievable through GitLab&#x27;s web hooks and api, but i don&#x27;t think it has a way to add a custom field to a task to store the related git branches and it only has an open &#x2F; close status. We could use labels instead and parse the task description to extract the branch info.<p>What I&#x27;ve done in the past and worked great is use git hooks for deployment. Basically, we would add the fabric tasks functionality to the post_receive git hook, so once we push the staging or master branch, it would automatically trigger deployment. That would handle deployment&#x27;s heavy lift, but I&#x27;d still like to automate branch merging, by linking it to task status.<p>In short, what I&#x27;d like to achieve is deployment based on task status updates.<p>Has anyone done that? Is it a good idea? Are there any caveats?<p>Any tips or ideas would be highly appeciated. Thanks!", "title": "Ask HN: GitLab Continuous Integration", "updated_at": "2024-09-20T00:53:28Z"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "nabanitade"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["gitlab", "ci", "production"], "value": "Hi HN,<p>I just released PrivacySDK \u2014 a privacy + security vulnerability scanner that plugs directly into GitLab, GitHub and various development CI/CD workflows. It scans your codebase for GDPR, CCPA, HIPAA, and security violations using a combination of AI (Google Gemini via Vertex AI) and hardcoded rule engines.<p>Think: linting, but for privacy compliance.<p>Key features:<p>Works with <em>GitLab CI</em>/CD, GitHub Actions, &amp; various development workflows<p>Scans 12+ programming languages (JS, Python, Go, Java, etc.)<p>AI + rule-based detection (fallback-ready for <em>production</em> reliability)<p>Catches privacy risks with severity levels<p>Offers specific privacy recommendations<p>Educates developers on privacy best practices as they code<p>Real-time merge request comments, auto-issue creation, and CI pipeline enforcement<p>Helps enforce privacy-by-design automatically<p>Live website interface: Upload your code and get instant privacy reviews<p>Fully documented, tested, and ready for DevSecOps teams<p>Open source for personal/non-commercial use<p>Repo: https://gitlab.com/tnabanitade/privacysdk\n Commercial license info: Apply here : https://privacylicense.ai/contact or reach out at https://www.linkedin.com/in/nabanitaai/<p>It\u2019s open source for non-commercial use (MIT + Commons Clause).\nWould love your feedback, ideas, and contributions\u2014or thoughts on how this could evolve.<p>Thanks!\n\u2013 Nabanita De,\nFounder and CEO,\nhttps://privacylicense.ai/"}, "title": {"matchLevel": "none", "matchedWords": [], "value": "PrivacySDK \u2013 Privacy scanner for Gitlab/GitHub CI/CD (12 langs, AI-powered)"}}, "_tags": ["story", "author_nabanitade", "story_44314543", "ask_hn"], "author": "nabanitade", "created_at": "2025-06-19T00:59:05Z", "created_at_i": 1750294745, "num_comments": 0, "objectID": "44314543", "points": 3, "story_id": 44314543, "story_text": "Hi HN,<p>I just released PrivacySDK \u2014 a privacy + security vulnerability scanner that plugs directly into GitLab, GitHub and various development CI&#x2F;CD workflows. It scans your codebase for GDPR, CCPA, HIPAA, and security violations using a combination of AI (Google Gemini via Vertex AI) and hardcoded rule engines.<p>Think: linting, but for privacy compliance.<p>Key features:<p>Works with GitLab CI&#x2F;CD, GitHub Actions, &amp; various development workflows<p>Scans 12+ programming languages (JS, Python, Go, Java, etc.)<p>AI + rule-based detection (fallback-ready for production reliability)<p>Catches privacy risks with severity levels<p>Offers specific privacy recommendations<p>Educates developers on privacy best practices as they code<p>Real-time merge request comments, auto-issue creation, and CI pipeline enforcement<p>Helps enforce privacy-by-design automatically<p>Live website interface: Upload your code and get instant privacy reviews<p>Fully documented, tested, and ready for DevSecOps teams<p>Open source for personal&#x2F;non-commercial use<p>Repo: https:&#x2F;&#x2F;gitlab.com&#x2F;tnabanitade&#x2F;privacysdk\n Commercial license info: Apply here : https:&#x2F;&#x2F;privacylicense.ai&#x2F;contact or reach out at https:&#x2F;&#x2F;www.linkedin.com&#x2F;in&#x2F;nabanitaai&#x2F;<p>It\u2019s open source for non-commercial use (MIT + Commons Clause).\nWould love your feedback, ideas, and contributions\u2014or thoughts on how this could evolve.<p>Thanks!\n\u2013 Nabanita De,\nFounder and CEO,\nhttps:&#x2F;&#x2F;privacylicense.ai&#x2F;", "title": "PrivacySDK \u2013 Privacy scanner for Gitlab/GitHub CI/CD (12 langs, AI-powered)", "updated_at": "2025-06-20T04:35:48Z"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "nathan_f77"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["gitlab", "ci", "production"], "value": "I'm migrating from Heroku to AWS. I have a lot of free AWS credits that expire in about 2 years, so I want to use those up and save some money on hosting. I also don't have autoscaling on Heroku, because I'm not using their expensive dynos.<p>It's just a Rails app with some custom buildpacks. I also have a Dockerfile that I'm using to run the tests on <em>GitLab CI</em>, so the app is ready to deploy as a container. I use Sidekiq for background jobs, and I have some scheduled tasks that run once a day.<p>I'm open to anything, if your setup is fast and stable. CloudWatch, Terraform, ECS, OpsWorks, Chef, Puppet, Ansible, SaltStack, Capistrano, Deis, Flynn, Convox, or whatever else you're using. I'm just looking for some <em>production</em>-ready and battle-tested infrastructure for Rails + Sidekiq.<p>Does anyone have some config that they're using in <em>production</em>, and wouldn't mind sharing?<p>Here's what I'm looking for:<p>* Multi-az VPC for high availability<p>* RDS (Postgres)<p>* Elasticache (Redis)<p>* Autoscaling for Rails app and Sidekiq workers<p>* Easy way to set up scheduled tasks<p>* CloudWatch alarms<p>* A simple way to deploy new code<p>* Rolling deploys<p>Nice to have:<p>* &quot;git push&quot; deploys<p>* Elasticsearch + Kibana for APM, logging, metrics, etc.<p>It would be great if someone has already done all of this work and would be willing to share their config. If I can't find anything, I'll open source my setup when it's finished. Segment.io's Stack looks good, but it doesn't seem like it's being maintained [2].<p>[1] https://github.com/segmentio/stack<p>[2] https://github.com/segmentio/stack/pull/139"}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Ask HN: How are you deploying Rails + Sidekiq on AWS?"}}, "_tags": ["story", "author_nathan_f77", "story_16447092", "ask_hn"], "author": "nathan_f77", "created_at": "2018-02-23T15:58:34Z", "created_at_i": 1519401514, "num_comments": 0, "objectID": "16447092", "points": 2, "story_id": 16447092, "story_text": "I&#x27;m migrating from Heroku to AWS. I have a lot of free AWS credits that expire in about 2 years, so I want to use those up and save some money on hosting. I also don&#x27;t have autoscaling on Heroku, because I&#x27;m not using their expensive dynos.<p>It&#x27;s just a Rails app with some custom buildpacks. I also have a Dockerfile that I&#x27;m using to run the tests on GitLab CI, so the app is ready to deploy as a container. I use Sidekiq for background jobs, and I have some scheduled tasks that run once a day.<p>I&#x27;m open to anything, if your setup is fast and stable. CloudWatch, Terraform, ECS, OpsWorks, Chef, Puppet, Ansible, SaltStack, Capistrano, Deis, Flynn, Convox, or whatever else you&#x27;re using. I&#x27;m just looking for some production-ready and battle-tested infrastructure for Rails + Sidekiq.<p>Does anyone have some config that they&#x27;re using in production, and wouldn&#x27;t mind sharing?<p>Here&#x27;s what I&#x27;m looking for:<p>* Multi-az VPC for high availability<p>* RDS (Postgres)<p>* Elasticache (Redis)<p>* Autoscaling for Rails app and Sidekiq workers<p>* Easy way to set up scheduled tasks<p>* CloudWatch alarms<p>* A simple way to deploy new code<p>* Rolling deploys<p>Nice to have:<p>* &quot;git push&quot; deploys<p>* Elasticsearch + Kibana for APM, logging, metrics, etc.<p>It would be great if someone has already done all of this work and would be willing to share their config. If I can&#x27;t find anything, I&#x27;ll open source my setup when it&#x27;s finished. Segment.io&#x27;s Stack looks good, but it doesn&#x27;t seem like it&#x27;s being maintained [2].<p>[1] https:&#x2F;&#x2F;github.com&#x2F;segmentio&#x2F;stack<p>[2] https:&#x2F;&#x2F;github.com&#x2F;segmentio&#x2F;stack&#x2F;pull&#x2F;139", "title": "Ask HN: How are you deploying Rails + Sidekiq on AWS?", "updated_at": "2024-09-20T02:04:20Z"}], "hitsPerPage": 15, "nbHits": 8, "nbPages": 1, "page": 0, "params": "query=gitlab-ci+production&tags=story&hitsPerPage=15&advancedSyntax=true&analyticsTags=backend", "processingTimeMS": 9, "processingTimingsMS": {"_request": {"roundTrip": 32}, "afterFetch": {"format": {"highlighting": 3, "total": 3}}, "fetch": {"query": 5, "scanning": 2, "total": 8}, "total": 9}, "query": "gitlab-ci production", "serverTimeMS": 13}}