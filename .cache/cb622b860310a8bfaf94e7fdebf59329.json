{"d": {"_id": "prometheus", "_rev": "253-fce77c6e99f9080e876adca6fc9f4f4f", "name": "prometheus", "description": "Simple ODM for Node.js with pluggable adapters", "dist-tags": {"latest": "0.1.7"}, "versions": {"0.0.1": {"author": {"name": "Alexander Farennikov", "email": "farennikov@gmail.com"}, "name": "prometheus", "description": "Simple ORM for Node.js with pluggable adapters", "keywords": ["ORM", "object relational mapping", "prometheus", "adapter", "mongodb"], "homepage": "https://github.com/shubik/prometheus", "license": "MIT", "contributors": [], "version": "0.0.1", "repository": {"type": "git", "url": "https://github.com/shubik/prometheus"}, "bugs": {"url": "https://github.com/shubik/prometheus/issues"}, "main": "./lib/index.js", "scripts": {}, "engines": {"node": ">= 0.4.0"}, "dependencies": {"underscore": "~1.4.4", "deferred": "~0.6.1", "mongodb": "~1.2.14", "MD5": "~1.0.3"}, "devDependencies": {}, "readme": "Prometheus\n==========\n\nPrometheus is a simple ORM for Node.js with adapter for MongoDB.\n\nBecause of async nature of database calls, Prometheus' model constructor always returns a promise (we prefer [Deferred](https://github.com/medikoo/deferred) library), not a model. This promise resolves with model once it is created (e.g. for a blank model, `var user = new UserModel()`), or once it is loaded from database (e.g. if you provide model id, `var user = new UserModel(123)`) or `null` if model was not found.\n\n## Defining models:\n\nYou define model by passing model-specific options to ModelFactory, which returns a model constructor.\n\n### Required params\n\n*   `name` \u2014 Name of your model, e.g. `UserModel`\n*   `schema` \u2014 Description of model attributes\n\n### Optional params\n\n*   `mixins` \u2014 An array with mixins that will be applied to constructor's prototype\n*   `prototype_methods` \u2014 Model-specific methods that will be added to constructor's prototype\n*   `static_methods` \u2014 Model-specific static methods that will be added to constructor\n*   `hooks` \u2014 Model-specific hooks (callbacks) that will be called during model lifecycle, e.g. `afterInitialize`, `beforeSave` etc.\n\n## Defining a model\n\n```javascript\nvar prometheus    = require('prometheus'),\n    ModelFactory  = prometheus.factory,\n    MongodbStore  = prometheus.stores.mongodb,\n    Validators    = prometheus.validators,\n    MD5           = prometheus.MD5,\n    UserModel,\n    model_options;\n\nmodel_options = {\n\n    name: 'ExampleModel',\n\n    store: new MongodbStore({\n        collection: 'example'\n    }),\n\n    schema: {\n        name: {\n            name: 'Name',\n            default: '',\n            type: ModelFactory.types.STRING\n        },\n        email: {\n            name: 'Email',\n            default: '',\n            type: ModelFactory.types.STRING,\n            validate: Validators.isEmail,\n            unique: true\n        },\n        password: {\n            name: 'Password',\n            default: '',\n            type: ModelFactory.types.STRING,\n            hidden: true\n        }\n    },\n\n    mixins: [],\n\n    prototype_methods: {},\n\n    static_methods: {\n        login: function(req, options) {\n            // your login logic\n        },\n\n        logout: function(req) {\n            // your logout logic\n        }\n    },\n\n    hooks: {\n        beforeSave: function() {\n            var password = this.get('password');\n\n            if (password.length !== 32) {\n                this.set('password', MD5(password));\n            }\n\n            this.set('updated_at', utils.now());\n        }\n    }\n}\n\nUserModel = module.exports = ModelFactory(model_options);\n```\n\n## Instantiating models\n\nBlank model is instantiated by calling a model constructor without arguments:\n\n```javascript\nvar user = new UserModel();\n\nuser(function(model) {\n    model.set({\n        name: 'Shubik',\n        email: 'farennikov@gmail.com',\n        password: 'password'\n    });\n\n    model.save()(function(model) {\n        // model successfully saved\n    }, function(err) {\n        // handle error\n    });\n}, function(err) {\n    // handle error\n});\n```\n\nExisting model is instantiated with model id as argument:\n\n```javascript\nvar user = new UserModel(123);\n\nuser(function(model) {\n    if (model === null) {\n        // model with id 123 was not found\n    } else {\n        var new_name = model.get('name') + ' updated';\n        model.set('name', new_name);\n        model.save();\n    }\n}, function(err) {\n    // handle error\n});\n```\n\nNote that if model with such id is not found, promise will resolve with `null`.\n\n## Model API\n\n__Instance methods__\n\n### model.get()\n\n`get(attr)` retrieves an attribute of the model, or an entire model if attribute name is not provided.\n\n### model.set()\n\n`set(attr, [value])` sssigns new value to an attribute or a number of attributes of the model. If given only 1 param which is an Object, method will use keys of the object as attributes.\n\n### model.save()\n\n`save()` saves a new model or model that has been changed by `set()`. Returns a promise which is resolved with model if model was successfully saved or error if saving model failed. If model was initialized without an id, new model will be attempted to be created.\n\n### model.destroy()\n\n`destroy()` deletes model from a store. Returns a promise which is resolved with this model once model is deleted from database.\n\n### model.keys()\n\n`keys()` returns attribute names of this model.\n\n### model.toJSON()\n\n`toJSON()` returns all attributes of the model (key-value pairs).\n\n### model.validate()\n\n`validate()` validates model attributes according to the model's schema. Returns true or false.\n\n### model.toForm()\n\n`toForm()` returns an object that can be used to create HTML form for this model.\n\n### model.parseForm()\n\n`parseForm(req)` populates a model by values from a request.\n\n### model.toTable()\n\n`toTable()` returns an object that can be used to show this model in table form.\n\nYou can add model-specific instance methods by adding them to `prototype_methods` param of the options you pass to `ModelFactory`.\n\n__Static methods__\n\nModel constructors can have static methods which you can use without instantiating a model. By default there are two static methods: `find()` and `count()`:\n\n### SomeModel.find()\n\n`find(query, offset, limit, sort)` returns a promise which is resolved with an array of models found in database using provided arguments. Example:\n\n```javascript\nUserModel.find({ name: 'Shubik' })(function(results) {\n    // do somethig with `results`\n});\n```\n\n### SomeModel.count()\n\n`count()` returns a promise which is resolved with number of all models in the database. Example:\n\n```javascript\nUserModel.count()(function(num) {\n    // do somethig with `num`\n});\n```\n\nYou can add more model-specific static methods to `static_methods` param of the options you pass to `ModelFactory`.", "readmeFilename": "README.md", "_id": "prometheus@0.0.1", "dist": {"shasum": "55fc43abe01f97653528477f0e4e3a7e485eb3b7", "tarball": "https://registry.npmjs.org/prometheus/-/prometheus-0.0.1.tgz", "integrity": "sha512-5c4joh54yAIGhjgQNZ0uM9FZWOXUpdbMKcoCKxD8J6p9mQ7Jh/CTOkhm2xj2ebOydQPFD5xtIAKp82W76s8kPw==", "signatures": [{"keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA", "sig": "MEQCIGM8uI1ViNies9ekHIa+AsLdF8wHNIBDSR23NSRhBIz6AiAw3P0OfhiIcapmTl8sZ+6vkSNFbVSFm7FcnRDHoTlpjA=="}]}, "_from": ".", "_npmVersion": "1.2.18", "_npmUser": {"name": "shubik", "email": "farennikov@gmail.com"}, "maintainers": [{"name": "shubik", "email": "farennikov@gmail.com"}], "directories": {}}, "0.0.2": {"author": {"name": "Alexander Farennikov", "email": "farennikov@gmail.com"}, "name": "prometheus", "description": "Simple ORM for Node.js with pluggable adapters", "keywords": ["ORM", "object relational mapping", "prometheus", "adapter", "mongodb"], "homepage": "https://github.com/shubik/prometheus", "license": "MIT", "contributors": [], "version": "0.0.2", "repository": {"type": "git", "url": "https://github.com/shubik/prometheus"}, "bugs": {"url": "https://github.com/shubik/prometheus/issues"}, "main": "./lib/index.js", "scripts": {}, "engines": {"node": ">= 0.4.0"}, "dependencies": {"underscore": "~1.4.4", "deferred": "~0.6.1", "mongodb": "~1.2.14", "MD5": "~1.0.3"}, "devDependencies": {}, "readme": "Prometheus\n==========\n\nPrometheus is a simple ORM for Node.js with adapter for MongoDB (so far) and built-in __form builder__, __form parser__, and __table builder__. Form parser has __uploads handler__ with __image resizer.__\n\nBecause of async nature of database calls, Prometheus' model constructor always returns a promise (we use [Deferred](https://github.com/medikoo/deferred) library), not a model itself. This promise resolves with model once it is created (e.g. for a blank model, `var user = new UserModel()`), or when it is loaded from database (e.g. if you provide model id, `var user = new UserModel(123)`) or `null` if model was not found.\n\n## Installation\n\n### NPM\n\nIn your project path:\n\n```javascript\n$ npm install prometheus\n```\n\n## Defining models:\n\nYou define model by passing model-specific options to ModelFactory, which returns a model constructor.\n\n### Required params\n\n*   `name` \u2014 Friendly name of your model, e.g. `UserModel`\n*   `schema` \u2014 Description of model attributes\n\n### Optional params\n\n*   `mixins` \u2014 An array with mixins that will be applied to constructor's prototype\n*   `prototype_methods` \u2014 Model-specific methods that will be added to constructor's prototype\n*   `static_methods` \u2014 Model-specific static methods that will be added to constructor\n*   `hooks` \u2014 Model-specific hooks (callbacks) that will be called during model lifecycle, e.g. `afterInitialize`, `beforeSave` etc.\n\n## Defining a model example\n\n```javascript\nvar prometheus    = require('prometheus'),\n    ModelFactory  = prometheus.factory,\n    MongodbStore  = prometheus.stores.mongodb,\n    MD5           = prometheus.MD5,\n    UserModel,\n    model_options;\n\nmodel_options = {\n\n    name: 'ExampleModel',\n\n    store: new MongodbStore({\n        collection: 'example'\n    }),\n\n    schema: {\n        name: {\n            name: 'Name',\n            default: '',\n            type: ModelFactory.types.STRING\n        },\n        email: {\n            name: 'Email',\n            default: '',\n            type: ModelFactory.types.STRING,\n            validate: Validators.isEmail,\n            unique: true\n        },\n        password: {\n            name: 'Password',\n            default: '',\n            type: ModelFactory.types.STRING,\n            hidden: true\n        }\n    },\n\n    mixins: [],\n\n    prototype_methods: {},\n\n    static_methods: {\n        login: function(req, options) {\n            // your login logic\n        },\n\n        logout: function(req) {\n            // your logout logic\n        }\n    },\n\n    hooks: {\n        beforeSave: function() {\n            var password = this.get('password');\n\n            if (password.length !== 32) {\n                this.set('password', MD5(password));\n            }\n\n            this.set('updated_at', utils.now());\n        }\n    }\n}\n\nUserModel = module.exports = ModelFactory(model_options);\n```\n\n## Instantiating models\n\nBlank model is instantiated by calling a model constructor without arguments:\n\n```javascript\nvar user = new UserModel();\n\nuser(function(model) {\n    model.set({\n        name: 'Shubik',\n        email: 'farennikov@gmail.com',\n        password: 'password'\n    });\n\n    model.save()(function(model) {\n        // model successfully saved\n    }, function(err) {\n        // handle error\n    });\n}, function(err) {\n    // handle error\n});\n```\n\nExisting model is instantiated with model id as argument:\n\n```javascript\nvar user = new UserModel(123);\n\nuser(function(model) {\n    if (model === null) {\n        // model with id 123 was not found\n    } else {\n        var new_name = model.get('name') + ' updated';\n        model.set('name', new_name);\n        model.save();\n    }\n}, function(err) {\n    // handle error\n});\n```\n\nNote that if model with such id is not found, promise will resolve with `null`.\n\n## Model API\n\n__Instance methods__\n\n### model.get()\n\n`get(attr)` retrieves an attribute of the model, or an entire model if attribute name is not provided.\n\n### model.set()\n\n`set(attr, [value])` sssigns new value to an attribute or a number of attributes of the model. If given only 1 param which is an Object, method will use keys of the object as attributes.\n\n### model.save()\n\n`save()` saves a new model or model that has been changed by `set()`. Returns a promise which is resolved with model if model was successfully saved or error if saving model failed. If model was initialized without an id, new model will be attempted to be created.\n\n### model.destroy()\n\n`destroy()` deletes model from a store. Returns a promise which is resolved with this model once model is deleted from database.\n\n### model.keys()\n\n`keys()` returns attribute names of this model.\n\n### model.toJSON()\n\n`toJSON()` returns all attributes of the model (key-value pairs).\n\n### model.validate()\n\n`validate()` validates model attributes according to the model's schema. Returns true or false.\n\n### model.toForm()\n\n`toForm()` returns an object that can be used to create HTML form for this model.\n\n### model.parseForm()\n\n`parseForm(req)` populates a model by values from a request.\n\n### model.toTable()\n\n`toTable()` returns an object that can be used to show this model in table form.\n\nYou can add model-specific instance methods by adding them to `prototype_methods` param of the options you pass to `ModelFactory`.\n\n__Static methods__\n\nModel constructors can have static methods which you can use without instantiating a model. By default there are two static methods: `find()` and `count()`:\n\n### SomeModel.find()\n\n`find(query, offset, limit, sort)` returns a promise which is resolved with an array of models found in database using provided arguments. Example:\n\n```javascript\nUserModel.find({ name: 'Shubik' })(function(results) {\n    // do somethig with `results`\n});\n```\n\n### SomeModel.count()\n\n`count()` returns a promise which is resolved with number of all models in the database. Example:\n\n```javascript\nUserModel.count()(function(num) {\n    // do somethig with `num`\n});\n```\n\nYou can add more model-specific static methods to `static_methods` param of the options you pass to `ModelFactory`.\n\n## Form builder\n\nEach model has built-in method `model.toForm()` which returns an object that you can use to render forms. Below is an example route that uses `toForm()` method to display form for adding a new company:\n\n```javascript\nadd: function(req, res) {\n    var company = new CompanyModel();\n\n    company(function(model) {\n\n        model.set('auth_token', MD5(_.random(99999999, 999999999) + config.auth.salt));\n\n        var model_form = model.toForm({\n            url         : '/rest/company',\n            method      : 'POST',\n            show_hidden : true\n        });\n\n        res.render('admin/company_add', {\n            title      : 'Add company',\n            model_form : model_form\n        });\n\n    }, function(err) {\n        res.send(400, err.toString());\n    });\n}\n```\n\nActual form is rendered using a Jade mixin and Twitter Bootstrap, as follows:\n\n```jade\nmixin form_builder(formdata)\n  form.form-horizontal.themed(id=\"#{formdata.tag.id}\", name=\"#{formdata.tag.name}\", method=\"#{formdata.tag.method}\", action=\"#{formdata.tag.action}\", enctype=\"#{formdata.tag.enctype}\")\n    fieldset\n      for field in formdata.fields\n        .control-group\n          label.control-label #{field.label}\n          .controls\n            for inp in field.inputs\n\n              if field.type == 'text'\n                !{inp}\n\n              if field.type == 'textarea'\n                !{inp}\n\n              if field.type == 'select'\n                !{inp}\n\n              if field.type == 'checkbox'\n                label.checkbox\n                  !{inp}\n\n              if field.type == 'radio'\n                label.radio\n                  !{inp}\n\n              if field.type == 'other'\n                !{inp}\n\n      .form-actions\n        button.btn.medium.btn-primary(type=\"submit\") Save\n```\n\nAnd this mixin is called from respective view as follows:\n\n```jade\n+form_builder(model_form)\n```\n\n## Form parser\n\nEach model has built-in method `model.parseForm()` which returns an object that you can use to render forms. Below is an example route that uses `parseForm()` method to add a new company:\n\n```javascript\ncreate: function(req, res) {\n    var params  = _.extend(req.params || {}, req.query || {}, req.body || {}),\n        company = new CompanyModel();\n\n    company(function(model) {\n        model.parseForm(req)(function(model) {\n            model.save()(function(model) {\n                res.json(200, model.toJSON());\n            }, function(err) {\n                res.send(400, err.toString());\n            });\n        }, function(err) {\n            res.send(400, err.toString());\n        });\n    });\n}\n```\n\n### Using image resizer\n\nYou can optionally resize your image uploads by adding `resize` property to schema attribute, such as in this example:\n\n```javascript\nschema: {\n    logo: {\n        name: 'Company Logo',\n        default: null,\n        type: ModelFactory.types.STRING,\n        content_type: 'image/jpeg, image/png, image/gif',\n        resize: ['c100', 's600x600', 's1200x1200']\n    }\n}\n```\n\nPlease note, that uploads are saved in store as their public URLs, not as a binary. Therefore in order to save uploads, your model definition needs to have `uploads` attribute, which is an object with two params: `path` and `path_public`, where `path` is path to upload folder on the server, and `path_public` is a path to the upload relative to your domain, e.g.:\n\n```javascript\nuploads: {\n    path: '/home/ubuntu/myproject/node/public/uploads/',\n    path_public: '/uploads/'\n}\n```\n\nYou can generate `path` in your app.js as follows:\n\n```javascript\nvar uploads = {\n    path_public: '/uploads/'\n};\nuploads.path = __dirname + '/public' + config.uploads.path_public;\n```\n\nUploaded images will be saved in the provided path and will be persisted in the store as public path, e.g. `/uploads/3e192ca4fa8ec546cdb6ef6e2ab55b00.jpg`.\n\n### Image sizes\n\nImage sizes are listed in the `resize` param of the attribute schema and you can add as many size definitions as you want. There are two notations for the image sizes:\n\n*   __Crop:__ `cXXX`, e.g. `c100` which will generate thumbs 100x100px centered in the middle of the original image\n*   __Resize:__ `sXXXxYYY`, e.g. `s600x600` which will generate image with either size up to 600px wide or high\n\nAll additional sizes are saved using image basename followed with `_{size}.ext`, e.g. `3e192ca4fa8ec546cdb6ef6e2ab55b00_c100.jpg` or `3e192ca4fa8ec546cdb6ef6e2ab55b00_s600x600.jpg`.\n\nImage resizer required [Imagemagick](http://www.imagemagick.org/script/index.php) to be installed on your host.\n\n## Validators\n\nPrometheus does validation by data type as long as you use `type` property in schema item description. But if attribute's value requires more specific validation, you can add a `validate` property to schema item. For example, if you want to know if value is a number Pi (to a certain proximity), you can add a validator:\n\n```javascript\nschema: {\n    pi: {\n        name: 'Pi',\n        default: null,\n        type: ModelFactory.types.NUMBER,\n        validate: function(val) {\n            return val / Math.PI > 0.999;\n        }\n    }\n}\n```\n\n## Schema properties\n\n### Required\n\n*   `name` \u2014 {String} Friendly name for this attribute, e.g. \"UserModel\"\n*   `default` \u2014 {Mixed} Default attribute value, e.g. `null` or `\"changeme\"`\n*   `type` \u2014 {String} Data type from list of constants in ModelFactory.types\n\n### Optional\n\n*   `validate` \u2014 {Function} that validates attribute value (see above)\n*   `permitted` \u2014 {Array} Permitted values\n*   `unique` \u2014 {Boolean} True if value must be unique\n*   `content_type` \u2014 {String} Comma separated mime types, default `text/plain`\n*   `resize` \u2014 {Array} Desired image sizes (see above)\n*   `multiline` \u2014 {Boolean} True if this string is text (length > 255)\n*   `maxlength` \u2014 {Number} Number if string has a maximum length\n*   `maketag` \u2014 {Function} that returns a custom HTML tag for this field\n*   `readonly` \u2014 {Boolean} True if user is not allowed to change value\n\n## Changelog\n\n### v.0.0.2\n\n*   Refactored image uploader\n*   Added image resizer. Note that image resizer needs __imagemagick__ to be installed.", "readmeFilename": "README.md", "_id": "prometheus@0.0.2", "dist": {"shasum": "f171ae7cfda762f3ea4ff4f705446fe6358e7993", "tarball": "https://registry.npmjs.org/prometheus/-/prometheus-0.0.2.tgz", "integrity": "sha512-VpZKfJ8KMAEupOo3z3egxD94fjnVvSgSHk3RnDvC95HCZ0TPCmMte3RyRB4zUCv3tr43zV788En4/2Z4wAmM7g==", "signatures": [{"keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA", "sig": "MEUCIQDxi0kcLoYlKy5KKFa2fEXzlmsAk0YSeyDcFXIls9Ds8AIgXnhJRqq06coOuSqAdd2I8A7BDdMv2CVFBbhVG4fZjMg="}]}, "_from": ".", "_npmVersion": "1.2.18", "_npmUser": {"name": "shubik", "email": "farennikov@gmail.com"}, "maintainers": [{"name": "shubik", "email": "farennikov@gmail.com"}], "directories": {}}, "0.0.3": {"author": {"name": "Alexander Farennikov", "email": "farennikov@gmail.com"}, "name": "prometheus", "description": "Simple ORM for Node.js with pluggable adapters", "keywords": ["ORM", "object relational mapping", "prometheus", "adapter", "mongodb"], "homepage": "https://github.com/shubik/prometheus", "license": "MIT", "contributors": [], "version": "0.0.3", "repository": {"type": "git", "url": "https://github.com/shubik/prometheus"}, "bugs": {"url": "https://github.com/shubik/prometheus/issues"}, "main": "./lib/index.js", "scripts": {}, "engines": {"node": ">= 0.4.0"}, "dependencies": {"underscore": "~1.4.4", "deferred": "~0.6.1", "mongodb": "~1.2.14", "MD5": "~1.0.3"}, "devDependencies": {}, "readme": "Prometheus\n==========\n\nPrometheus is a simple ORM for Node.js with adapter for MongoDB (so far) and built-in __form builder__, __form parser__, and __table builder__. Form parser has __uploads handler__ with __image resizer.__\n\nBecause of async nature of database calls, Prometheus' model constructor always returns a promise (we use [Deferred](https://github.com/medikoo/deferred) library), not a model itself. This promise resolves with model once it is created (e.g. for a blank model, `var user = new UserModel()`), or when it is loaded from database (e.g. if you provide model id, `var user = new UserModel(123)`) or `null` if model was not found.\n\n## Installation\n\n### NPM\n\nIn your project path:\n\n```javascript\n$ npm install prometheus\n```\n\n## Defining models:\n\nYou define model by passing model-specific options to ModelFactory, which returns a model constructor.\n\n### Required params\n\n*   `name` \u2014 Friendly name of your model, e.g. `UserModel`\n*   `schema` \u2014 Description of model attributes\n\n### Optional params\n\n*   `mixins` \u2014 An array with mixins that will be applied to constructor's prototype\n*   `prototype_methods` \u2014 Model-specific methods that will be added to constructor's prototype\n*   `static_methods` \u2014 Model-specific static methods that will be added to constructor\n*   `hooks` \u2014 Model-specific hooks (callbacks) that will be called during model lifecycle, e.g. `afterInitialize`, `beforeSave` etc.\n\n## Defining a model example\n\n```javascript\nvar prometheus    = require('prometheus'),\n    ModelFactory  = prometheus.factory,\n    MongodbStore  = prometheus.stores.mongodb,\n    MD5           = prometheus.MD5,\n    UserModel,\n    model_options;\n\nmodel_options = {\n\n    name: 'ExampleModel',\n\n    store: new MongodbStore({\n        collection: 'example'\n    }),\n\n    schema: {\n        name: {\n            name: 'Name',\n            default: '',\n            type: ModelFactory.types.STRING\n        },\n        email: {\n            name: 'Email',\n            default: '',\n            type: ModelFactory.types.STRING,\n            validate: Validators.isEmail,\n            unique: true\n        },\n        password: {\n            name: 'Password',\n            default: '',\n            type: ModelFactory.types.STRING,\n            hidden: true\n        }\n    },\n\n    mixins: [],\n\n    prototype_methods: {},\n\n    static_methods: {\n        login: function(req, options) {\n            // your login logic\n        },\n\n        logout: function(req) {\n            // your logout logic\n        }\n    },\n\n    hooks: {\n        beforeSave: function() {\n            var password = this.get('password');\n\n            if (password.length !== 32) {\n                this.set('password', MD5(password));\n            }\n\n            this.set('updated_at', utils.now());\n        }\n    }\n}\n\nUserModel = module.exports = ModelFactory(model_options);\n```\n\n## Instantiating models\n\nBlank model is instantiated by calling a model constructor without arguments:\n\n```javascript\nvar user = new UserModel();\n\nuser(function(model) {\n    model.set({\n        name: 'Shubik',\n        email: 'farennikov@gmail.com',\n        password: 'password'\n    });\n\n    model.save()(function(model) {\n        // model successfully saved\n    }, function(err) {\n        // handle error\n    });\n}, function(err) {\n    // handle error\n});\n```\n\nExisting model is instantiated with model id as argument:\n\n```javascript\nvar user = new UserModel(123);\n\nuser(function(model) {\n    if (model === null) {\n        // model with id 123 was not found\n    } else {\n        var new_name = model.get('name') + ' updated';\n        model.set('name', new_name);\n        model.save();\n    }\n}, function(err) {\n    // handle error\n});\n```\n\nNote that if model with such id is not found, promise will resolve with `null`.\n\n## Model API\n\n__Instance methods__\n\n### model.get()\n\n`get(attr)` retrieves an attribute of the model, or an entire model if attribute name is not provided.\n\n### model.set()\n\n`set(attr, [value])` sssigns new value to an attribute or a number of attributes of the model. If given only 1 param which is an Object, method will use keys of the object as attributes.\n\n### model.save()\n\n`save()` saves a new model or model that has been changed by `set()`. Returns a promise which is resolved with model if model was successfully saved or error if saving model failed. If model was initialized without an id, new model will be attempted to be created.\n\n### model.destroy()\n\n`destroy()` deletes model from a store. Returns a promise which is resolved with this model once model is deleted from database.\n\n### model.keys()\n\n`keys()` returns attribute names of this model.\n\n### model.toJSON()\n\n`toJSON()` returns all attributes of the model (key-value pairs).\n\n### model.validate()\n\n`validate()` validates model attributes according to the model's schema. Returns true or false.\n\n### model.toForm()\n\n`toForm()` returns an object that can be used to create HTML form for this model.\n\n### model.parseForm()\n\n`parseForm(req)` populates a model by values from a request.\n\n### model.toTable()\n\n`toTable()` returns an object that can be used to show this model in table form.\n\nYou can add model-specific instance methods by adding them to `prototype_methods` param of the options you pass to `ModelFactory`.\n\n__Static methods__\n\nModel constructors can have static methods which you can use without instantiating a model. By default there are two static methods: `find()` and `count()`:\n\n### SomeModel.find()\n\n`find(query, offset, limit, sort)` returns a promise which is resolved with an array of models found in database using provided arguments. Example:\n\n```javascript\nUserModel.find({ name: 'Shubik' })(function(results) {\n    // do somethig with `results`\n});\n```\n\n### SomeModel.count()\n\n`count()` returns a promise which is resolved with number of all models in the database. Example:\n\n```javascript\nUserModel.count()(function(num) {\n    // do somethig with `num`\n});\n```\n\nYou can add more model-specific static methods to `static_methods` param of the options you pass to `ModelFactory`.\n\n## Form builder\n\nEach model has built-in method `model.toForm()` which returns an object that you can use to render forms. Below is an example route that uses `toForm()` method to display form for adding a new company:\n\n```javascript\nadd: function(req, res) {\n    var company = new CompanyModel();\n\n    company(function(model) {\n\n        model.set('auth_token', MD5(_.random(99999999, 999999999) + config.auth.salt));\n\n        var model_form = model.toForm({\n            url         : '/rest/company',\n            method      : 'POST',\n            show_hidden : true\n        });\n\n        res.render('admin/company_add', {\n            title      : 'Add company',\n            model_form : model_form\n        });\n\n    }, function(err) {\n        res.send(400, err.toString());\n    });\n}\n```\n\nActual form is rendered using a Jade mixin and Twitter Bootstrap, as follows:\n\n```jade\nmixin form_builder(formdata)\n  form.form-horizontal.themed(id=\"#{formdata.tag.id}\", name=\"#{formdata.tag.name}\", method=\"#{formdata.tag.method}\", action=\"#{formdata.tag.action}\", enctype=\"#{formdata.tag.enctype}\")\n    fieldset\n      for field in formdata.fields\n        .control-group\n          label.control-label #{field.label}\n          .controls\n            for inp in field.inputs\n\n              if field.type == 'text'\n                !{inp}\n\n              if field.type == 'textarea'\n                !{inp}\n\n              if field.type == 'select'\n                !{inp}\n\n              if field.type == 'checkbox'\n                label.checkbox\n                  !{inp}\n\n              if field.type == 'radio'\n                label.radio\n                  !{inp}\n\n              if field.type == 'other'\n                !{inp}\n\n      .form-actions\n        button.btn.medium.btn-primary(type=\"submit\") Save\n```\n\nAnd this mixin is called from respective view as follows:\n\n```jade\n+form_builder(model_form)\n```\n\n## Form parser\n\nEach model has built-in method `model.parseForm()` which returns an object that you can use to render forms. Below is an example route that uses `parseForm()` method to add a new company:\n\n```javascript\ncreate: function(req, res) {\n    var params  = _.extend(req.params || {}, req.query || {}, req.body || {}),\n        company = new CompanyModel();\n\n    company(function(model) {\n        model.parseForm(req)(function(model) {\n            model.save()(function(model) {\n                res.json(200, model.toJSON());\n            }, function(err) {\n                res.send(400, err.toString());\n            });\n        }, function(err) {\n            res.send(400, err.toString());\n        });\n    });\n}\n```\n\n### Using image resizer\n\nYou can optionally resize your image uploads by adding `resize` property to schema attribute, such as in this example:\n\n```javascript\nschema: {\n    logo: {\n        name: 'Company Logo',\n        default: null,\n        type: ModelFactory.types.STRING,\n        content_type: 'image/jpeg, image/png, image/gif',\n        resize: ['c100', 's600x600', 's1200x1200']\n    }\n}\n```\n\nPlease note, that uploads are saved in store as their public URLs, not as a binary. Therefore in order to save uploads, your model definition needs to have `uploads` attribute, which is an object with two params: `path` and `path_public`, where `path` is path to upload folder on the server, and `path_public` is a path to the upload relative to your domain, e.g.:\n\n```javascript\nuploads: {\n    path: '/home/ubuntu/myproject/node/public/uploads/',\n    path_public: '/uploads/'\n}\n```\n\nYou can generate `path` in your app.js as follows:\n\n```javascript\nvar uploads = {\n    path_public: '/uploads/'\n};\nuploads.path = __dirname + '/public' + config.uploads.path_public;\n```\n\nUploaded images will be saved in the provided path and will be persisted in the store as public path, e.g. `/uploads/3e192ca4fa8ec546cdb6ef6e2ab55b00.jpg`.\n\n### Image sizes\n\nImage sizes are listed in the `resize` param of the attribute schema and you can add as many size definitions as you want. There are two notations for the image sizes:\n\n*   __Crop:__ `cXXX`, e.g. `c100` which will generate thumbs 100x100px centered in the middle of the original image\n*   __Resize:__ `sXXXxYYY`, e.g. `s600x600` which will generate image with either size up to 600px wide or high\n\nAll additional sizes are saved using image basename followed with `_{size}.ext`, e.g. `3e192ca4fa8ec546cdb6ef6e2ab55b00_c100.jpg` or `3e192ca4fa8ec546cdb6ef6e2ab55b00_s600x600.jpg`.\n\nImage resizer required [Imagemagick](http://www.imagemagick.org/script/index.php) to be installed on your host.\n\n## Validators\n\nPrometheus does validation by data type as long as you use `type` property in schema item description. But if attribute's value requires more specific validation, you can add a `validate` property to schema item. For example, if you want to know if value is a number Pi (to a certain proximity), you can add a validator:\n\n```javascript\nschema: {\n    pi: {\n        name: 'Pi',\n        default: null,\n        type: ModelFactory.types.NUMBER,\n        validate: function(val) {\n            return val / Math.PI > 0.999;\n        }\n    }\n}\n```\n\n## Schema properties\n\n### Required\n\n*   `name` \u2014 {String} Friendly name for this attribute, e.g. \"UserModel\"\n*   `default` \u2014 {Mixed} Default attribute value, e.g. `null` or `\"changeme\"`\n*   `type` \u2014 {String} Data type from list of constants in ModelFactory.types\n\n### Optional\n\n*   `validate` \u2014 {Function} that validates attribute value (see above)\n*   `permitted` \u2014 {Array} Permitted values\n*   `unique` \u2014 {Boolean} True if value must be unique\n*   `content_type` \u2014 {String} Comma separated mime types, default `text/plain`\n*   `resize` \u2014 {Array} Desired image sizes (see above)\n*   `multiline` \u2014 {Boolean} True if this string is text (length > 255)\n*   `maxlength` \u2014 {Number} Number if string has a maximum length\n*   `maketag` \u2014 {Function} that returns a custom HTML tag for this field\n*   `readonly` \u2014 {Boolean} True if user is not allowed to change value\n\n## Changelog\n\n### v.0.0.3\n\n*   Added setters and getters for model attributes\n*   Removed built-in validators\n*   Added implicit check for changes in model attributes before update\n*   Refactored `destroy()` method\n\n### v.0.0.2\n\n*   Refactored image uploader\n*   Added image resizer. Note that image resizer needs __imagemagick__ to be installed.", "readmeFilename": "README.md", "_id": "prometheus@0.0.3", "dist": {"shasum": "e06a6d27ffb309a72af15a8ca445cffe321658ca", "tarball": "https://registry.npmjs.org/prometheus/-/prometheus-0.0.3.tgz", "integrity": "sha512-dxHIHRss78OvRKkIxQAryzg8iejWm+9i29SyN7bDBJfkPLwhtkiURYRbbnt3QYBqajnJT64R2P7FnEPlbFNmdA==", "signatures": [{"keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA", "sig": "MEYCIQDOl5gYozB3Gz1w2oCatbto8Z/Evt8jhs+asX9SIYQGXwIhAOAnSq1iSMEv4Y4BNMdL9VE3o194brqaRz7fz7xZ3f+u"}]}, "_from": ".", "_npmVersion": "1.2.18", "_npmUser": {"name": "shubik", "email": "farennikov@gmail.com"}, "maintainers": [{"name": "shubik", "email": "farennikov@gmail.com"}], "directories": {}}, "0.1.0": {"author": {"name": "Alexander Farennikov", "email": "farennikov@gmail.com"}, "name": "prometheus", "description": "Simple ORM for Node.js with pluggable adapters", "keywords": ["ORM", "object relational mapping", "prometheus", "adapter", "mongodb"], "homepage": "https://github.com/shubik/prometheus", "license": "MIT", "contributors": [], "version": "0.1.0", "repository": {"type": "git", "url": "https://github.com/shubik/prometheus"}, "bugs": {"url": "https://github.com/shubik/prometheus/issues"}, "main": "./lib/index.js", "scripts": {}, "engines": {"node": ">= 0.4.0"}, "dependencies": {"underscore": "~1.4.4", "deferred": "~0.6.1", "mongodb": "~1.2.14", "MD5": "~1.0.3"}, "devDependencies": {}, "readme": "Prometheus\n==========\n\nPrometheus is a simple ORM for Node.js with adapter for MongoDB (so far) and built-in __form builder__, __form parser__, and __table builder__. Form parser has __uploads handler__ with __image resizer.__\n\nBecause of async nature of database calls, Prometheus' model constructor has an internal promise (we use [Deferred](https://github.com/medikoo/deferred) library), which is exposed via attribute `ready`. This promise resolves with model once model is initialized (e.g. a blank model, `var user = new UserModel({})`), or loaded from database (e.g. if you provide a query, `var user = new UserModel({ id: 123 })`). If you're trying to load with a query a model that does not exist, you can know if by checking `model.get() === null` or `model.toJSON() === null`.\n\n## Installation\n\n### NPM\n\nIn your project path:\n\n```javascript\n$ npm install prometheus\n```\n\n## Defining models:\n\nYou define model by passing model-specific options to ModelFactory, which returns a model constructor.\n\n### Required params\n\n*   `name` \u2014 Friendly name of your model, e.g. `UserModel`\n*   `schema` \u2014 Description of model attributes\n\n### Optional params\n\n*   `mixins` \u2014 An array with mixins that will be applied to constructor's prototype\n*   `prototype_methods` \u2014 Model-specific methods that will be added to constructor's prototype\n*   `static_methods` \u2014 Model-specific static methods that will be added to constructor\n*   `hooks` \u2014 Model-specific hooks (callbacks) that will be called during model lifecycle, e.g. `afterInitialize`, `beforeSave` etc.\n*   `permissions` \u2014 Object with a list of CRUDT permissions\n*   `roles` \u2014 Object with functions which check permissions per each role listed in `permissions`\n\n## Defining a model example\n\n```javascript\nvar prometheus    = require('prometheus'),\n    ModelFactory  = prometheus.factory,\n    MongodbStore  = prometheus.stores.mongodb,\n    MD5           = prometheus.MD5,\n    UserModel,\n    model_options;\n\nmodel_options = {\n\n    name: 'ExampleModel',\n\n    store: new MongodbStore({\n        collection: 'example'\n    }),\n\n    schema: {\n        name: {\n            name: 'Name',\n            default: '',\n            type: ModelFactory.types.STRING\n        },\n        email: {\n            name: 'Email',\n            default: '',\n            type: ModelFactory.types.STRING,\n            validate: Validators.isEmail,\n            unique: true\n        },\n        password: {\n            name: 'Password',\n            default: '',\n            type: ModelFactory.types.STRING,\n            hidden: true\n        }\n    },\n\n    mixins: [],\n\n    prototype_methods: {},\n\n    static_methods: {\n        login: function(req, options) {\n            // your login logic\n        },\n\n        logout: function(req) {\n            // your logout logic\n        }\n    },\n\n    hooks: {\n        beforeSave: function() {\n            var password = this.get('password');\n\n            if (password.length !== 32) {\n                this.set('password', MD5(password));\n            }\n\n            this.set('updated_at', utils.now());\n        }\n    }\n}\n\nUserModel = module.exports = ModelFactory(model_options);\n```\n\n## Instantiating models\n\nBlank model is instantiated by calling a model constructor with a blank query:\n\n```javascript\nvar user = new UserModel({}, { req: req });\n\nuser.ready(function(model) {\n    model.set({\n        name: 'Shubik',\n        email: 'farennikov@gmail.com',\n        password: 'password'\n    });\n\n    model.save()(function(model) {\n        // model successfully saved\n    }, function(err) {\n        // handle error\n    });\n}, function(err) {\n    // handle error\n});\n```\n\nExisting model is instantiated with model id as argument:\n\n```javascript\nvar user = new UserModel({ email: 'farennikov@gmail.com' }, { req: req });\n\nuser.ready(function(model) {\n    if (model.toJSON() === null) {\n        // model with this email not found - save new\n        model.set({ email: 'farennikov@gmail.com' });\n    } else {\n        var new_name = model.get('name') + ' updated';\n        model.set('name', new_name);\n    }\n    model.save();\n}, function(err) {\n    // handle error\n});\n```\n\nNote that if model with such id is not found, promise will resolve with `null`.\n\n## Model API\n\n__Instance methods__\n\n### model.get()\n\n`get(attr)` retrieves an attribute of the model, or an entire model if attribute name is not provided.\n\n### model.set()\n\n`set(attr, [value])` sssigns new value to an attribute or a number of attributes of the model. If given only 1 param which is an Object, method will use keys of the object as attributes.\n\n### model.save()\n\n`save()` saves a new model or model that has been changed by `set()`. Returns a promise which is resolved with model if model was successfully saved or error if saving model failed. If model was initialized without an id, new model will be attempted to be created.\n\n### model.destroy()\n\n`destroy()` deletes model from a store. Returns a promise which is resolved with this model once model is deleted from database.\n\n### model.toJSON()\n\n`toJSON()` returns all attributes of the model (key-value pairs).\n\n### model.validate()\n\n`validate()` validates model attributes according to the model's schema. Returns true or false.\n\n### model.toForm()\n\n`toForm()` returns an object that can be used to create HTML form for this model.\n\n### model.parseForm()\n\n`parseForm(req)` populates a model by values from a request.\n\n### model.toTable()\n\n`toTable()` returns an object that can be used to show this model in table form.\n\nYou can add model-specific instance methods by adding them to `prototype_methods` param of the options you pass to `ModelFactory`.\n\n__Static methods__\n\nModel constructors can have static methods which you can use without instantiating a model. By default there are two static methods: `find()` and `count()`:\n\n### SomeModel.find()\n\n`find(query, offset, limit, sort)` returns a promise which is resolved with an array of models found in database using provided arguments. Example:\n\n```javascript\nUserModel.find({ name: 'Shubik' })(function(results) {\n    // do somethig with `results`\n});\n```\n\n### SomeModel.count()\n\n`count()` returns a promise which is resolved with number of all models in the database. Example:\n\n```javascript\nUserModel.count()(function(num) {\n    // do somethig with `num`\n});\n```\n\nYou can add more model-specific static methods to `static_methods` param of the options you pass to `ModelFactory`.\n\n## Form builder\n\nEach model has built-in method `model.toForm()` which returns an object that you can use to render forms. Below is an example route that uses `toForm()` method to display form for adding a new company:\n\n```javascript\nadd: function(req, res) {\n    var company = new CompanyModel({}, { req: req });\n\n    company.ready(function(model) {\n\n        model.set('auth_token', MD5(_.random(1000000, 9999999) + config.auth.salt));\n\n        var model_form = model.toForm({\n            url         : '/rest/company',\n            method      : 'POST',\n            show_hidden : true\n        });\n\n        res.render('admin/company_add', {\n            title      : 'Add company',\n            model_form : model_form\n        });\n\n    }, function(err) {\n        res.send(400, err.toString());\n    });\n}\n```\n\nActual form is rendered using a Jade mixin and Twitter Bootstrap, as follows:\n\n```jade\nmixin form_builder(formdata)\n  form.form-horizontal.themed(id=\"#{formdata.tag.id}\", name=\"#{formdata.tag.name}\", method=\"#{formdata.tag.method}\", action=\"#{formdata.tag.action}\", enctype=\"#{formdata.tag.enctype}\")\n    fieldset\n      for field in formdata.fields\n        .control-group\n          label.control-label #{field.label}\n          .controls\n            for inp in field.inputs\n\n              if field.type == 'text'\n                !{inp}\n\n              if field.type == 'textarea'\n                !{inp}\n\n              if field.type == 'select'\n                !{inp}\n\n              if field.type == 'checkbox'\n                label.checkbox\n                  !{inp}\n\n              if field.type == 'radio'\n                label.radio\n                  !{inp}\n\n              if field.type == 'other'\n                !{inp}\n\n      .form-actions\n        button.btn.medium.btn-primary(type=\"submit\") Save\n```\n\nAnd this mixin is called from respective view as follows:\n\n```jade\n+form_builder(model_form)\n```\n\n## Form parser\n\nEach model has built-in method `model.parseForm()` which returns an object that you can use to render forms. Below is an example route that uses `parseForm()` method to add a new company:\n\n```javascript\ncreate: function(req, res) {\n    var params  = _.extend(req.params || {}, req.query || {}, req.body || {}),\n        company = new CompanyModel({}, { req: req });\n\n    company.ready(function(model) {\n        model.parseForm(req)(function(model) {\n            model.save()(function(model) {\n                res.json(200, model.toJSON());\n            }, function(err) {\n                res.send(400, err.toString());\n            });\n        }, function(err) {\n            res.send(400, err.toString());\n        });\n    });\n}\n```\n\n### Using image resizer\n\nYou can optionally resize your image uploads by adding `resize` property to schema attribute, such as in this example:\n\n```javascript\nschema: {\n    logo: {\n        name: 'Company Logo',\n        default: null,\n        type: ModelFactory.types.STRING,\n        content_type: 'image/jpeg, image/png, image/gif',\n        resize: ['c100', 's600x600', 's1200x1200']\n    }\n}\n```\n\nPlease note, that uploads are saved in store as their public URLs, not as a binary. Therefore in order to save uploads, your model definition needs to have `uploads` attribute, which is an object with two params: `path` and `path_public`, where `path` is path to upload folder on the server, and `path_public` is a path to the upload relative to your domain, e.g.:\n\n```javascript\nuploads: {\n    path: '/home/ubuntu/myproject/node/public/uploads/',\n    path_public: '/uploads/'\n}\n```\n\nYou can generate `path` in your app.js as follows:\n\n```javascript\nvar uploads = {\n    path_public: '/uploads/'\n};\nuploads.path = __dirname + '/public' + config.uploads.path_public;\n```\n\nUploaded images will be saved in the provided path and will be persisted in the store as public path, e.g. `/uploads/3e192ca4fa8ec546cdb6ef6e2ab55b00.jpg`.\n\n### Image sizes\n\nImage sizes are listed in the `resize` param of the attribute schema and you can add as many size definitions as you want. There are two notations for the image sizes:\n\n*   __Crop:__ `cXXX`, e.g. `c100` which will generate thumbs 100x100px centered in the middle of the original image\n*   __Resize:__ `sXXXxYYY`, e.g. `s600x600` which will generate image with either size up to 600px wide or high\n\nAll additional sizes are saved using image basename followed with `_{size}.ext`, e.g. `3e192ca4fa8ec546cdb6ef6e2ab55b00_c100.jpg` or `3e192ca4fa8ec546cdb6ef6e2ab55b00_s600x600.jpg`.\n\nImage resizer required [Imagemagick](http://www.imagemagick.org/script/index.php) to be installed on your host.\n\n## Validators\n\nPrometheus does validation by data type as long as you use `type` property in schema item description. But if attribute's value requires more specific validation, you can add a `validate` property to schema item. For example, if you want to know if value is a number Pi (to a certain proximity), you can add a validator:\n\n```javascript\nschema: {\n    pi: {\n        name: 'Pi',\n        default: null,\n        type: ModelFactory.types.NUMBER,\n        validate: function(val) {\n            return val / Math.PI > 0.999;\n        }\n    }\n}\n```\n\n## Schema properties\n\n### Required\n\n*   `name` \u2014 {String} Friendly name for this attribute, e.g. \"UserModel\"\n*   `default` \u2014 {Mixed} Default attribute value, e.g. `null`, `\"changeme\"`, etc.\n*   `type` \u2014 {String} Data type from list of constants in ModelFactory.types\n\n### Optional\n\n*   `validate` \u2014 {Function} that validates attribute value (see above)\n*   `permitted` \u2014 {Array} Permitted values\n*   `unique` \u2014 {Boolean} True if value must be unique\n*   `content_type` \u2014 {String} Comma separated mime types, default `text/plain`\n*   `resize` \u2014 {Array} Desired image sizes (see above)\n*   `multiline` \u2014 {Boolean} True if this string is text (length > 255)\n*   `maxlength` \u2014 {Number} Number if string has a maximum length\n*   `maketag` \u2014 {Function} that returns a custom HTML tag for this field\n*   `readonly` \u2014 {Boolean} True if user is not allowed to change value\n*   `sync` \u2014 {Boolean} False if should not be synced with store\n\n## Permissions\n\nPrometheus has model level permissions management. Defining permissions is optional. If permission rules are not defined, all permissions are set to `true`.\n\n### Defining permissions\n\nYou can define permissions for models by adding `permissions` and `roles` properties to `model_options` of a model, as in the example below. `permissions` is a hash with key-value pairs, where keys are CRUD operations and values are arrays with user roles, able to perform corresponding operations:\n\n```javascript\npermissions: {\n    'create'   : ['admin'],\n    'read'     : ['admin', 'user', 'guest'],\n    'update'   : ['admin', 'user'],\n    'destroy'  : ['admin'],\n    'transfer' : ['admin']\n}\n```\n\nTwo built-in roles are `app` and `guest`: if you do no pass `req` to the model constructor in the options, we assume that this model is not created within a function handling a route, so it's created elsewhere by the application. At the other hand, if `req` was passed with options, we assume that model is created as a result of HTTP(S) request by a user, who by default is a guest.\n\n`roles` is a hash of functions which return promises resolved with boolean result of permission checks:\n\n```javascript\nroles: {\n    user: function (model, req) {\n        var def = deferred(),\n            pass = !!(req && req.session.user);\n\n        def.resolve({ user: pass });\n        return def.promise;\n    },\n\n    admin: function (model, req) {\n        var def = deferred(),\n            pass = !!(req && req.session.user && req.session.user.roles.indexOf('admin') !== -1);\n\n        def.resolve({ admin: pass });\n        return def.promise;\n    }\n}\n```\n\nAbove example adds custom user role checks for `user` and `admin`, where user is anyone with user hash inside `req.session` and `admin` is a user whose roles hash contains \"admin\".\n\nPlease note that all of these functions return a promise \u2014 this is important because in Prometheus' internals we use `deferred.map()` to check all permissions. We did this on purpose because some permission checkers may be asyncronous.\n\n### Handling 403 Forbidden situations\n\nIf you are using any method on the model that involves CRUD operations, and user's permissions are insufficient to do a certain operation on the model, an error event will fire on the model, which you can handle by subscribing to it where you instantiate the model:\n\n```javascript\nvar model = new UserModel({ email: 'farennikov@gmail.com '}, { req: req });\n\nmodel.on('error', function(err) {\n    res.send(403, err.toString());\n});\n\nmodel.ready(function(model) {\n    model.set('foo', 'bar');\n    model.save();\n});\n```\n\nAbove example will send client \"403 Forbidden\" headers if session user does not have update rights.\n\n## Changelog\n\n### v.0.1.0\n\n*   Instantiating model arguments changed to `query` and `[options]`\n*   Model constructor does not return promise any more; it returns self (model)\n*   If model is not found with a query, `model.ready` is resolved with `this`, not `null` as in previous versions. This allows you not to have to instantiate a new blank model, but instead reuse existing model instance\n*   Added model-level permissions\n\n### v.0.0.3\n\n*   Added setters and getters for model attributes\n*   Removed built-in validators\n*   Added implicit check for changes in model attributes before update\n*   Refactored `destroy()` method\n\n### v.0.0.2\n\n*   Refactored image uploader\n*   Added image resizer. Note that image resizer needs __imagemagick__ to be installed.", "readmeFilename": "README.md", "_id": "prometheus@0.1.0", "dist": {"shasum": "755ebe28d9640d8f37aabec6a04cd16dc75eed6e", "tarball": "https://registry.npmjs.org/prometheus/-/prometheus-0.1.0.tgz", "integrity": "sha512-7u9V02wfzwuJSIMhQQ5saY3ukh7Dskp1Lo4XvEHS2mBpAsl9U5gg4DEs1O5FdgWsP/ZF1avgtBfRj0K3mn714g==", "signatures": [{"keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA", "sig": "MEUCIQCBa91haqeW91/t+ArDVnakdkSzq99wQZB9PdIrFnSxjQIgPM5OQ2tUGnEJn2fi4cxbucD3Z4cBz4pK+t/bRMHiWHM="}]}, "_from": ".", "_npmVersion": "1.2.18", "_npmUser": {"name": "shubik", "email": "farennikov@gmail.com"}, "maintainers": [{"name": "shubik", "email": "farennikov@gmail.com"}], "directories": {}}, "0.1.1": {"author": {"name": "Alexander Farennikov", "email": "farennikov@gmail.com"}, "name": "prometheus", "description": "Simple ORM for Node.js with pluggable adapters", "keywords": ["ORM", "object relational mapping", "prometheus", "adapter", "mongodb"], "homepage": "https://github.com/shubik/prometheus", "license": "MIT", "contributors": [], "version": "0.1.1", "repository": {"type": "git", "url": "https://github.com/shubik/prometheus"}, "bugs": {"url": "https://github.com/shubik/prometheus/issues"}, "main": "./lib/index.js", "scripts": {}, "engines": {"node": ">= 0.4.0"}, "dependencies": {"underscore": "~1.4.4", "deferred": "~0.6.1", "mongodb": "~1.2.14", "MD5": "~1.0.3"}, "devDependencies": {}, "readme": "Prometheus\n==========\n\nPrometheus is a simple ORM for Node.js with adapter for MongoDB (so far) and built-in __form builder__, __form parser__, and __table builder__. Form parser has __uploads handler__ with __image resizer.__\n\nBecause of async nature of database calls, Prometheus' model constructor has an internal promise (we use [Deferred](https://github.com/medikoo/deferred) library), which is exposed via attribute `ready`. This promise resolves with model once model is initialized (e.g. a blank model, `var user = new UserModel({})`), or loaded from database (e.g. if you provide a query, `var user = new UserModel({ id: 123 })`). If you're trying to load with a query a model that does not exist, you can know if by checking `model.get() === null` or `model.toJSON() === null`.\n\n## Installation\n\n### NPM\n\nIn your project path:\n\n```javascript\n$ npm install prometheus\n```\n\n## Defining models:\n\nYou define model by passing model-specific options to ModelFactory, which returns a model constructor.\n\n### Required params\n\n*   `name` \u2014 Friendly name of your model, e.g. `UserModel`\n*   `schema` \u2014 Description of model attributes\n\n### Optional params\n\n*   `mixins` \u2014 An array with mixins that will be applied to constructor's prototype\n*   `prototype_methods` \u2014 Model-specific methods that will be added to constructor's prototype\n*   `static_methods` \u2014 Model-specific static methods that will be added to constructor\n*   `hooks` \u2014 Model-specific hooks (callbacks) that will be called during model lifecycle, e.g. `afterInitialize`, `beforeSave` etc.\n*   `permissions` \u2014 Object with a list of CRUDT permissions\n*   `roles` \u2014 Object with functions which check permissions per each role listed in `permissions`\n\n## Defining a model example\n\n```javascript\nvar prometheus    = require('prometheus'),\n    ModelFactory  = prometheus.factory,\n    MongodbStore  = prometheus.stores.mongodb,\n    MD5           = prometheus.MD5,\n    UserModel,\n    model_options;\n\nmodel_options = {\n\n    name: 'ExampleModel',\n\n    store: new MongodbStore({\n        collection: 'example'\n    }),\n\n    schema: {\n        name: {\n            name: 'Name',\n            default: '',\n            type: ModelFactory.types.STRING\n        },\n        email: {\n            name: 'Email',\n            default: '',\n            type: ModelFactory.types.STRING,\n            validate: Validators.isEmail,\n            unique: true\n        },\n        password: {\n            name: 'Password',\n            default: '',\n            type: ModelFactory.types.STRING,\n            hidden: true\n        }\n    },\n\n    mixins: [],\n\n    prototype_methods: {},\n\n    static_methods: {\n        login: function(req, options) {\n            // your login logic\n        },\n\n        logout: function(req) {\n            // your logout logic\n        }\n    },\n\n    hooks: {\n        beforeSave: function() {\n            var password = this.get('password');\n\n            if (password.length !== 32) {\n                this.set('password', MD5(password));\n            }\n\n            this.set('updated_at', utils.now());\n        }\n    }\n}\n\nUserModel = module.exports = ModelFactory(model_options);\n```\n\n## Instantiating models\n\nBlank model is instantiated by calling a model constructor with a blank query as first argument:\n\n```javascript\nvar user = new UserModel({}, { req: req });\n\nuser.ready(function(model) {\n    model.set({\n        name: 'Shubik',\n        email: 'farennikov@gmail.com',\n        password: 'password'\n    });\n\n    model.save()(function(model) {\n        // model successfully saved\n    }, function(err) {\n        // handle error\n    });\n}, function(err) {\n    // handle error\n});\n```\n\nExisting model is instantiated with a query as first argument:\n\n```javascript\nvar user = new UserModel({ email: 'farennikov@gmail.com' }, { req: req });\n\nuser.ready(function(model) {\n    if (model.toJSON() === null) {\n        // model with this email not found - save new\n        model.set({ email: 'farennikov@gmail.com' });\n    } else {\n        var new_name = model.get('name') + ' updated';\n        model.set('name', new_name);\n    }\n    model.save();\n}, function(err) {\n    // handle error\n});\n```\n\nNote that if model with such id is not found, promise will resolve with `null`.\n\n## Model API\n\n__Instance methods__\n\n### model.get()\n\n`get(attr)` retrieves an attribute of the model, or an entire model if attribute name is not provided.\n\n### model.set()\n\n`set(attr, [value])` sssigns new value to an attribute or a number of attributes of the model. If given only 1 param which is an Object, method will use keys of the object as attributes.\n\n### model.save()\n\n`save()` saves a new model or model that has been changed by `set()`. Returns a promise which is resolved with model if model was successfully saved or error if saving model failed. If model was initialized without an id, new model will be attempted to be created.\n\n### model.destroy()\n\n`destroy()` deletes model from a store. Returns a promise which is resolved with this model once model is deleted from database.\n\n### model.toJSON()\n\n`toJSON()` returns all attributes of the model (key-value pairs).\n\n### model.validate()\n\n`validate()` validates model attributes according to the model's schema. Returns true or false.\n\n### model.toForm()\n\n`toForm()` returns an object that can be used to create HTML form for this model.\n\n### model.parseForm()\n\n`parseForm(req)` populates a model by values from a request.\n\n### model.toTable()\n\n`toTable()` returns an object that can be used to show this model in table form.\n\nYou can add model-specific instance methods by adding them to `prototype_methods` param of the options you pass to `ModelFactory`.\n\n__Static methods__\n\nModel constructors can have static methods which you can use without instantiating a model. By default there are two static methods: `find()` and `count()`:\n\n### SomeModel.find()\n\n`find(query, offset, limit, sort)` returns a promise which is resolved with an array of models found in database using provided arguments. Example:\n\n```javascript\nUserModel.find({ name: 'Shubik' })(function(results) {\n    // do somethig with `results`\n});\n```\n\n### SomeModel.count()\n\n`count()` returns a promise which is resolved with number of all models in the database. Example:\n\n```javascript\nUserModel.count()(function(num) {\n    // do somethig with `num`\n});\n```\n\nYou can add more model-specific static methods to `static_methods` param of the options you pass to `ModelFactory`.\n\n## Form builder\n\nEach model has built-in method `model.toForm()` which returns an object that you can use to render forms. Below is an example route that uses `toForm()` method to display form for adding a new company:\n\n```javascript\nadd: function(req, res) {\n    var company = new CompanyModel({}, { req: req });\n\n    company.ready(function(model) {\n\n        model.set('auth_token', MD5(_.random(1000000, 9999999) + config.auth.salt));\n\n        var model_form = model.toForm({\n            url         : '/rest/company',\n            method      : 'POST',\n            show_hidden : true\n        });\n\n        res.render('admin/company_add', {\n            title      : 'Add company',\n            model_form : model_form\n        });\n\n    }, function(err) {\n        res.send(400, err.toString());\n    });\n}\n```\n\nActual form is rendered using a Jade mixin and Twitter Bootstrap, as follows:\n\n```jade\nmixin form_builder(formdata)\n  form.form-horizontal.themed(id=\"#{formdata.tag.id}\", name=\"#{formdata.tag.name}\", method=\"#{formdata.tag.method}\", action=\"#{formdata.tag.action}\", enctype=\"#{formdata.tag.enctype}\")\n    fieldset\n      for field in formdata.fields\n        .control-group\n          label.control-label #{field.label}\n          .controls\n            for inp in field.inputs\n\n              if field.type == 'text'\n                !{inp}\n\n              if field.type == 'textarea'\n                !{inp}\n\n              if field.type == 'select'\n                !{inp}\n\n              if field.type == 'checkbox'\n                label.checkbox\n                  !{inp}\n\n              if field.type == 'radio'\n                label.radio\n                  !{inp}\n\n              if field.type == 'other'\n                !{inp}\n\n      .form-actions\n        button.btn.medium.btn-primary(type=\"submit\") Save\n```\n\nAnd this mixin is called from respective view as follows:\n\n```jade\n+form_builder(model_form)\n```\n\n## Form parser\n\nEach model has built-in method `model.parseForm()` which returns an object that you can use to render forms. Below is an example route that uses `parseForm()` method to add a new company:\n\n```javascript\ncreate: function(req, res) {\n    var params  = _.extend(req.params || {}, req.query || {}, req.body || {}),\n        company = new CompanyModel({}, { req: req });\n\n    company.ready(function(model) {\n        model.parseForm(req)(function(model) {\n            model.save()(function(model) {\n                res.json(200, model.toJSON());\n            }, function(err) {\n                res.send(400, err.toString());\n            });\n        }, function(err) {\n            res.send(400, err.toString());\n        });\n    });\n}\n```\n\n### Using image resizer\n\nYou can optionally resize your image uploads by adding `resize` property to schema attribute, such as in this example:\n\n```javascript\nschema: {\n    logo: {\n        name: 'Company Logo',\n        default: null,\n        type: ModelFactory.types.STRING,\n        content_type: 'image/jpeg, image/png, image/gif',\n        resize: ['c100', 's600x600', 's1200x1200']\n    }\n}\n```\n\nPlease note, that uploads are saved in store as their public URLs, not as a binary. Therefore in order to save uploads, your model definition needs to have `uploads` attribute, which is an object with two params: `path` and `path_public`, where `path` is path to upload folder on the server, and `path_public` is a path to the upload relative to your domain, e.g.:\n\n```javascript\nuploads: {\n    path: '/home/ubuntu/myproject/node/public/uploads/',\n    path_public: '/uploads/'\n}\n```\n\nYou can generate `path` in your app.js as follows:\n\n```javascript\nvar uploads = {\n    path_public: '/uploads/'\n};\nuploads.path = __dirname + '/public' + config.uploads.path_public;\n```\n\nUploaded images will be saved in the provided path and will be persisted in the store as public path, e.g. `/uploads/3e192ca4fa8ec546cdb6ef6e2ab55b00.jpg`.\n\n### Image sizes\n\nImage sizes are listed in the `resize` param of the attribute schema and you can add as many size definitions as you want. There are two notations for the image sizes:\n\n*   __Crop:__ `cXXX`, e.g. `c100` which will generate thumbs 100x100px centered in the middle of the original image\n*   __Resize:__ `sXXXxYYY`, e.g. `s600x600` which will generate image with either size up to 600px wide or high\n\nAll additional sizes are saved using image basename followed with `_{size}.ext`, e.g. `3e192ca4fa8ec546cdb6ef6e2ab55b00_c100.jpg` or `3e192ca4fa8ec546cdb6ef6e2ab55b00_s600x600.jpg`.\n\nImage resizer required [Imagemagick](http://www.imagemagick.org/script/index.php) to be installed on your host.\n\n## Validators\n\nPrometheus does validation by data type as long as you use `type` property in schema item description. But if attribute's value requires more specific validation, you can add a `validate` property to schema item. For example, if you want to know if value is a number Pi (to a certain proximity), you can add a validator:\n\n```javascript\nschema: {\n    pi: {\n        name: 'Pi',\n        default: null,\n        type: ModelFactory.types.NUMBER,\n        validate: function(val) {\n            return val / Math.PI > 0.999;\n        }\n    }\n}\n```\n\n## Schema properties\n\n### Required\n\n*   `name` \u2014 {String} Friendly name for this attribute, e.g. \"UserModel\"\n*   `default` \u2014 {Mixed} Default attribute value, e.g. `null`, `\"changeme\"`, etc.\n*   `type` \u2014 {String} Data type from list of constants in ModelFactory.types\n\n### Optional\n\n*   `validate` \u2014 {Function} that validates attribute value (see above)\n*   `permitted` \u2014 {Array} Permitted values\n*   `unique` \u2014 {Boolean} True if value must be unique\n*   `content_type` \u2014 {String} Comma separated mime types, default `text/plain`\n*   `resize` \u2014 {Array} Desired image sizes (see above)\n*   `maxlength` \u2014 {Number} Number if string has a maximum length\n*   `maketag` \u2014 {Function} that returns a custom HTML tag for this field\n*   `readonly` \u2014 {Boolean} True if user is not allowed to change value\n*   `sync` \u2014 {Boolean} False if should not be synced with store\n\n## Permissions\n\nPrometheus has model level permissions management. Defining permissions is optional. If permission rules are not defined, all permissions are set to `true`.\n\n### Defining permissions\n\nYou can define permissions for models by adding `permissions` and `roles` properties to `model_options` of a model, as in the example below. `permissions` is a hash with key-value pairs, where keys are CRUD operations and values are arrays with user roles, able to perform corresponding operations:\n\n```javascript\npermissions: {\n    'create'   : ['admin'],\n    'read'     : ['admin', 'user', 'guest'],\n    'update'   : ['admin', 'user'],\n    'destroy'  : ['admin'],\n    'transfer' : ['admin']\n}\n```\n\nTwo built-in roles are `app` and `guest`: if you do no pass `req` to the model constructor in the options, we assume that this model is not created within a function handling a route, so it's created elsewhere by the application. At the other hand, if `req` was passed with options, we assume that model is created as a result of HTTP(S) request by a user, who by default is a guest.\n\n`roles` is a hash of functions which return promises resolved with boolean result of permission checks:\n\n```javascript\nroles: {\n    user: function (model, req) {\n        var def = deferred(),\n            pass = !!(req && req.session.user);\n\n        def.resolve({ user: pass });\n        return def.promise;\n    },\n\n    admin: function (model, req) {\n        var def = deferred(),\n            pass = !!(req && req.session.user && req.session.user.roles.indexOf('admin') !== -1);\n\n        def.resolve({ admin: pass });\n        return def.promise;\n    }\n}\n```\n\nAbove example adds custom user role checks for `user` and `admin`, where user is anyone with user hash inside `req.session` and `admin` is a user whose roles hash contains \"admin\".\n\nPlease note that all of these functions return a promise \u2014 this is important because in Prometheus' internals we use `deferred.map()` to check all permissions. We did this on purpose because some permission checkers may be asyncronous.\n\n### Handling 403 Forbidden situations\n\nIf you are using any method on the model that involves CRUD operations, and user's permissions are insufficient to do a certain operation on the model, an error event will fire on the model, which you can handle by subscribing to it where you instantiate the model:\n\n```javascript\nvar model = new UserModel({ email: 'farennikov@gmail.com' }, { req: req });\n\nmodel.on('error', function(err) {\n    res.send(403, err.toString());\n});\n\nmodel.ready(function(model) {\n    model.set('foo', 'bar');\n    model.save();\n});\n```\n\nAbove example will send client \"403 Forbidden\" headers if session user does not have update rights.\n\n## Changelog\n\n### v.0.1.1\n\n*   Moved some event handlers in model_factory.js initializer to separate dependencies\n*   Changed `model.find()` attributes to accept only `query` and `options`\n*   Removed `multiline` param from schema descriptions; use `datatypes.TEXT` instead\n\n### v.0.1.0\n\n*   Instantiating model arguments changed to `query` and `[options]`\n*   Model constructor does not return promise any more; it returns self (model)\n*   If model is not found with a query, `model.ready` is resolved with `this`, not `null` as in previous versions. This allows you not to have to instantiate a new blank model, but instead reuse existing model instance\n*   Added model-level permissions\n\n### v.0.0.3\n\n*   Added setters and getters for model attributes\n*   Removed built-in validators\n*   Added implicit check for changes in model attributes before update\n*   Refactored `destroy()` method\n\n### v.0.0.2\n\n*   Refactored image uploader\n*   Added image resizer. Note that image resizer needs __imagemagick__ to be installed.", "readmeFilename": "README.md", "_id": "prometheus@0.1.1", "dist": {"shasum": "ab063436d939f0f9af6c11a2efe24160d0525a05", "tarball": "https://registry.npmjs.org/prometheus/-/prometheus-0.1.1.tgz", "integrity": "sha512-coM9cYjJbEIe5Qkl09vzlGNO3lK1yj4UCJy2O5DEdiUu4sJZV+xZKsJJmPVedz6mxtXoMEJSHW5CeyLMUNuRdg==", "signatures": [{"keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA", "sig": "MEQCICiAk63Bi2dOb2hb4DUPsyWoIF7QRb3/PIj8PyfyssiVAiAdA/DPK3L/raBtidvkRSze3D/ntwOvLFVyybAXYCkYow=="}]}, "_from": ".", "_npmVersion": "1.2.27", "_npmUser": {"name": "shubik", "email": "farennikov@gmail.com"}, "maintainers": [{"name": "shubik", "email": "farennikov@gmail.com"}], "directories": {}}, "0.1.2": {"author": {"name": "Alexander Farennikov", "email": "farennikov@gmail.com"}, "name": "prometheus", "description": "Simple ODM for Node.js with pluggable adapters", "keywords": ["ODM", "object document mapping", "prometheus", "adapter", "mongodb"], "homepage": "https://github.com/shubik/prometheus", "license": "MIT", "contributors": [], "version": "0.1.2", "repository": {"type": "git", "url": "https://github.com/shubik/prometheus"}, "bugs": {"url": "https://github.com/shubik/prometheus/issues"}, "main": "./lib/index.js", "scripts": {}, "engines": {"node": ">= 0.4.0"}, "dependencies": {"underscore": "~1.4.4", "deferred": "~0.6.1", "mongodb": "~1.2.14", "MD5": "~1.0.3"}, "devDependencies": {}, "readme": "Prometheus\n==========\n\nPrometheus is a simple ODM for Node.js with adapter for MongoDB (so far) and built-in __form builder__, __form parser__, and __table builder__. Form parser has __uploads handler__ with __image resizer.__\n\nBecause of async nature of database calls, Prometheus' model constructor has an internal promise (we use [Deferred](https://github.com/medikoo/deferred) library), which is exposed via attribute `ready`. This promise resolves with model once model is initialized (e.g. a blank model, `var user = new UserModel({})`), or loaded from database (e.g. if you provide a query, `var user = new UserModel({ id: 123 })`). If you're trying to load with a query a model that does not exist, you can know if by checking `model.get() === null` or `model.toJSON() === null`.\n\n## Installation\n\n### NPM\n\nIn your project path:\n\n```javascript\n$ npm install prometheus\n```\n\n## Defining models:\n\nYou define model by passing model-specific options to ModelFactory, which returns a model constructor.\n\n### Required params\n\n*   `name` \u2014 Friendly name of your model, e.g. `UserModel`\n*   `schema` \u2014 Description of model attributes\n\n### Optional params\n\n*   `mixins` \u2014 An array with mixins that will be applied to constructor's prototype\n*   `prototype_methods` \u2014 Model-specific methods that will be added to constructor's prototype\n*   `static_methods` \u2014 Model-specific static methods that will be added to constructor\n*   `hooks` \u2014 Model-specific hooks (callbacks) that will be called during model lifecycle, e.g. `afterInitialize`, `beforeSave` etc.\n*   `permissions` \u2014 Object with a list of CRUDT permissions\n*   `roles` \u2014 Object with functions which check permissions per each role listed in `permissions`\n\n## Defining a model example\n\n```javascript\nvar prometheus    = require('prometheus'),\n    ModelFactory  = prometheus.factory,\n    MongodbStore  = prometheus.stores.mongodb,\n    MD5           = prometheus.MD5,\n    UserModel,\n    model_options;\n\nmodel_options = {\n\n    name: 'ExampleModel',\n\n    store: new MongodbStore({\n        collection: 'example'\n    }),\n\n    schema: {\n        name: {\n            name: 'Name',\n            default: '',\n            type: ModelFactory.types.STRING\n        },\n        email: {\n            name: 'Email',\n            default: '',\n            type: ModelFactory.types.STRING,\n            validate: Validators.isEmail,\n            unique: true\n        },\n        password: {\n            name: 'Password',\n            default: '',\n            type: ModelFactory.types.STRING,\n            hidden: true\n        }\n    },\n\n    mixins: [],\n\n    prototype_methods: {},\n\n    static_methods: {\n        login: function(req, options) {\n            // your login logic\n        },\n\n        logout: function(req) {\n            // your logout logic\n        }\n    },\n\n    hooks: {\n        beforeSave: function() {\n            var password = this.get('password');\n\n            if (password.length !== 32) {\n                this.set('password', MD5(password));\n            }\n\n            this.set('updated_at', utils.now());\n        }\n    }\n}\n\nUserModel = module.exports = ModelFactory(model_options);\n```\n\n## Instantiating models\n\nBlank model is instantiated by calling a model constructor with a blank query as first argument:\n\n```javascript\nvar user = new UserModel({}, { req: req });\n\nuser.ready(function(model) {\n    model.set({\n        name: 'Shubik',\n        email: 'farennikov@gmail.com',\n        password: 'password'\n    });\n\n    model.save()(function(model) {\n        // model successfully saved\n    }, function(err) {\n        // handle error\n    });\n}, function(err) {\n    // handle error\n});\n```\n\nExisting model is instantiated with a query as first argument:\n\n```javascript\nvar user = new UserModel({ email: 'farennikov@gmail.com' }, { req: req });\n\nuser.ready(function(model) {\n    if (model.toJSON() === null) {\n        // model with this email not found - save new\n        model.set({ email: 'farennikov@gmail.com' });\n    } else {\n        var new_name = model.get('name') + ' updated';\n        model.set('name', new_name);\n    }\n    model.save();\n}, function(err) {\n    // handle error\n});\n```\n\nNote that if model with such id is not found, promise will resolve with `null`.\n\n## Model API\n\n__Instance methods__\n\n### model.get()\n\n`get(attr)` retrieves an attribute of the model, or an entire model if attribute name is not provided.\n\n### model.set()\n\n`set(attr, [value])` sssigns new value to an attribute or a number of attributes of the model. If given only 1 param which is an Object, method will use keys of the object as attributes.\n\n### model.save()\n\n`save()` saves a new model or model that has been changed by `set()`. Returns a promise which is resolved with model if model was successfully saved or error if saving model failed. If model was initialized without an id, new model will be attempted to be created.\n\n### model.destroy()\n\n`destroy()` deletes model from a store. Returns a promise which is resolved with this model once model is deleted from database.\n\n### model.toJSON()\n\n`toJSON()` returns all attributes of the model (key-value pairs).\n\n### model.validate()\n\n`validate()` validates model attributes according to the model's schema. Returns true or false.\n\n### model.toForm()\n\n`toForm()` returns an object that can be used to create HTML form for this model.\n\n### model.parseForm()\n\n`parseForm(req)` populates a model by values from a request.\n\n### model.toTable()\n\n`toTable()` returns an object that can be used to show this model in table form.\n\nYou can add model-specific instance methods by adding them to `prototype_methods` param of the options you pass to `ModelFactory`.\n\n__Static methods__\n\nModel constructors can have static methods which you can use without instantiating a model. By default there are two static methods: `find()` and `count()`:\n\n### SomeModel.find()\n\n`find(query, offset, limit, sort)` returns a promise which is resolved with an array of models found in database using provided arguments. Example:\n\n```javascript\nUserModel.find({ name: 'Shubik' })(function(results) {\n    // do somethig with `results`\n});\n```\n\n### SomeModel.count()\n\n`count()` returns a promise which is resolved with number of all models in the database. Example:\n\n```javascript\nUserModel.count()(function(num) {\n    // do somethig with `num`\n});\n```\n\nYou can add more model-specific static methods to `static_methods` param of the options you pass to `ModelFactory`.\n\n## Form builder\n\nEach model has built-in method `model.toForm()` which returns an object that you can use to render forms. Below is an example route that uses `toForm()` method to display form for adding a new company:\n\n```javascript\nadd: function(req, res) {\n    var company = new CompanyModel({}, { req: req });\n\n    company.ready(function(model) {\n\n        model.set('auth_token', MD5(_.random(1000000, 9999999) + config.auth.salt));\n\n        var model_form = model.toForm({\n            url         : '/rest/company',\n            method      : 'POST',\n            show_hidden : true\n        });\n\n        res.render('admin/company_add', {\n            title      : 'Add company',\n            model_form : model_form\n        });\n\n    }, function(err) {\n        res.send(400, err.toString());\n    });\n}\n```\n\nActual form is rendered using a Jade mixin and Twitter Bootstrap, as follows:\n\n```jade\nmixin form_builder(formdata)\n  form.form-horizontal.themed(id=\"#{formdata.tag.id}\", name=\"#{formdata.tag.name}\", method=\"#{formdata.tag.method}\", action=\"#{formdata.tag.action}\", enctype=\"#{formdata.tag.enctype}\")\n    fieldset\n      for field in formdata.fields\n        .control-group\n          label.control-label #{field.label}\n          .controls\n            for inp in field.inputs\n\n              if field.type == 'text'\n                !{inp}\n\n              if field.type == 'textarea'\n                !{inp}\n\n              if field.type == 'select'\n                !{inp}\n\n              if field.type == 'checkbox'\n                label.checkbox\n                  !{inp}\n\n              if field.type == 'radio'\n                label.radio\n                  !{inp}\n\n              if field.type == 'other'\n                !{inp}\n\n      .form-actions\n        button.btn.medium.btn-primary(type=\"submit\") Save\n```\n\nAnd this mixin is called from respective view as follows:\n\n```jade\n+form_builder(model_form)\n```\n\n## Form parser\n\nEach model has built-in method `model.parseForm()` which returns an object that you can use to render forms. Below is an example route that uses `parseForm()` method to add a new company:\n\n```javascript\ncreate: function(req, res) {\n    var params  = _.extend(req.params || {}, req.query || {}, req.body || {}),\n        company = new CompanyModel({}, { req: req });\n\n    company.ready(function(model) {\n        model.parseForm(req)(function(model) {\n            model.save()(function(model) {\n                res.json(200, model.toJSON());\n            }, function(err) {\n                res.send(400, err.toString());\n            });\n        }, function(err) {\n            res.send(400, err.toString());\n        });\n    });\n}\n```\n\n### Using image resizer\n\nYou can optionally resize your image uploads by adding `resize` property to schema attribute, such as in this example:\n\n```javascript\nschema: {\n    logo: {\n        name: 'Company Logo',\n        default: null,\n        type: ModelFactory.types.STRING,\n        content_type: 'image/jpeg, image/png, image/gif',\n        resize: ['c100', 's600x600', 's1200x1200']\n    }\n}\n```\n\nPlease note, that uploads are saved in store as their public URLs, not as a binary. Therefore in order to save uploads, your model definition needs to have `uploads` attribute, which is an object with two params: `path` and `path_public`, where `path` is path to upload folder on the server, and `path_public` is a path to the upload relative to your domain, e.g.:\n\n```javascript\nuploads: {\n    path: '/home/ubuntu/myproject/node/public/uploads/',\n    path_public: '/uploads/'\n}\n```\n\nYou can generate `path` in your app.js as follows:\n\n```javascript\nvar uploads = {\n    path_public: '/uploads/'\n};\nuploads.path = __dirname + '/public' + config.uploads.path_public;\n```\n\nUploaded images will be saved in the provided path and will be persisted in the store as public path, e.g. `/uploads/3e192ca4fa8ec546cdb6ef6e2ab55b00.jpg`.\n\n### Image sizes\n\nImage sizes are listed in the `resize` param of the attribute schema and you can add as many size definitions as you want. There are two notations for the image sizes:\n\n*   __Crop:__ `cXXX`, e.g. `c100` which will generate thumbs 100x100px centered in the middle of the original image\n*   __Resize:__ `sXXXxYYY`, e.g. `s600x600` which will generate image with either size up to 600px wide or high\n\nAll additional sizes are saved using image basename followed with `_{size}.ext`, e.g. `3e192ca4fa8ec546cdb6ef6e2ab55b00_c100.jpg` or `3e192ca4fa8ec546cdb6ef6e2ab55b00_s600x600.jpg`.\n\nImage resizer required [Imagemagick](http://www.imagemagick.org/script/index.php) to be installed on your host.\n\n## Validators\n\nPrometheus does validation by data type as long as you use `type` property in schema item description. But if attribute's value requires more specific validation, you can add a `validate` property to schema item. For example, if you want to know if value is a number Pi (to a certain proximity), you can add a validator:\n\n```javascript\nschema: {\n    pi: {\n        name: 'Pi',\n        default: null,\n        type: ModelFactory.types.NUMBER,\n        validate: function(val) {\n            return val / Math.PI > 0.999;\n        }\n    }\n}\n```\n\n## Schema properties\n\n### Required\n\n*   `name` \u2014 {String} Friendly name for this attribute, e.g. \"UserModel\"\n*   `default` \u2014 {Mixed} Default attribute value, e.g. `null`, `\"changeme\"`, etc.\n*   `type` \u2014 {String} Data type from list of constants in ModelFactory.types\n\n### Optional\n\n*   `validate` \u2014 {Function} that validates attribute value (see above)\n*   `permitted` \u2014 {Array} Permitted values\n*   `unique` \u2014 {Boolean} True if value must be unique\n*   `content_type` \u2014 {String} Comma separated mime types, default `text/plain`\n*   `resize` \u2014 {Array} Desired image sizes (see above)\n*   `maxlength` \u2014 {Number} Number if string has a maximum length\n*   `maketag` \u2014 {Function} that returns a custom HTML tag for this field\n*   `readonly` \u2014 {Boolean} True if user is not allowed to change value\n*   `sync` \u2014 {Boolean} False if should not be synced with store\n\n## Permissions\n\nPrometheus has model level permissions management. Defining permissions is optional. If permission rules are not defined, all permissions are set to `true`.\n\n### Defining permissions\n\nYou can define permissions for models by adding `permissions` and `roles` properties to `model_options` of a model, as in the example below. `permissions` is a hash with key-value pairs, where keys are CRUD operations and values are arrays with user roles, able to perform corresponding operations:\n\n```javascript\npermissions: {\n    'create'   : ['admin'],\n    'read'     : ['admin', 'user', 'guest'],\n    'update'   : ['admin', 'user'],\n    'destroy'  : ['admin'],\n    'transfer' : ['admin']\n}\n```\n\nTwo built-in roles are `app` and `guest`: if you do no pass `req` to the model constructor in the options, we assume that this model is not created within a function handling a route, so it's created elsewhere by the application. At the other hand, if `req` was passed with options, we assume that model is created as a result of HTTP(S) request by a user, who by default is a guest.\n\n`roles` is a hash of functions which return promises resolved with boolean result of permission checks:\n\n```javascript\nroles: {\n    user: function (model, req) {\n        var def = deferred(),\n            pass = !!(req && req.session.user);\n\n        def.resolve({ user: pass });\n        return def.promise;\n    },\n\n    admin: function (model, req) {\n        var def = deferred(),\n            pass = !!(req && req.session.user && req.session.user.roles.indexOf('admin') !== -1);\n\n        def.resolve({ admin: pass });\n        return def.promise;\n    }\n}\n```\n\nAbove example adds custom user role checks for `user` and `admin`, where user is anyone with user hash inside `req.session` and `admin` is a user whose roles hash contains \"admin\".\n\nPlease note that all of these functions return a promise \u2014 this is important because in Prometheus' internals we use `deferred.map()` to check all permissions. We did this on purpose because some permission checkers may be asyncronous.\n\n### Handling 403 Forbidden situations\n\nIf you are using any method on the model that involves CRUD operations, and user's permissions are insufficient to do a certain operation on the model, an error event will fire on the model, which you can handle by subscribing to it where you instantiate the model:\n\n```javascript\nvar model = new UserModel({ email: 'farennikov@gmail.com' }, { req: req });\n\nmodel.on('error', function(err) {\n    res.send(403, err.toString());\n});\n\nmodel.ready(function(model) {\n    model.set('foo', 'bar');\n    model.save();\n});\n```\n\nAbove example will send client \"403 Forbidden\" headers if session user does not have update rights.\n\n## Changelog\n\n### v.0.1.2\n\n*   Refactored evt_handlers.js\n*   Fixed examples\n\n### v.0.1.1\n\n*   Moved some event handlers in model_factory.js initializer to separate dependencies\n*   Changed `model.find()` attributes to accept only `query` and `options`\n*   Removed `multiline` param from schema descriptions; use `datatypes.TEXT` instead\n\n### v.0.1.0\n\n*   Instantiating model arguments changed to `query` and `[options]`\n*   Model constructor does not return promise any more; it returns self (model)\n*   If model is not found with a query, `model.ready` is resolved with `this`, not `null` as in previous versions. This allows you not to have to instantiate a new blank model, but instead reuse existing model instance\n*   Added model-level permissions\n\n### v.0.0.3\n\n*   Added setters and getters for model attributes\n*   Removed built-in validators\n*   Added implicit check for changes in model attributes before update\n*   Refactored `destroy()` method\n\n### v.0.0.2\n\n*   Refactored image uploader\n*   Added image resizer. Note that image resizer needs __imagemagick__ to be installed.", "readmeFilename": "README.md", "_id": "prometheus@0.1.2", "dist": {"shasum": "3e2f0f0bbbab6e0b93d359925207d37de98bf2cb", "tarball": "https://registry.npmjs.org/prometheus/-/prometheus-0.1.2.tgz", "integrity": "sha512-xmVb4CCtcQ5T2S1hOcVAI3ELTLHqXimZA4GVzn87dA4DYFRusLx09InUrbaOf4o9J1V0oWRppZAoFnIer+AY8w==", "signatures": [{"keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA", "sig": "MEUCIQCoFa+iRnZah6siHV3NFgOqf1VMKIQeH0xEy1BGTxSJCwIgRFVpTE6W8U9AgZ+35fJOEGNyV2nex2uylS/C81rMYhI="}]}, "_from": ".", "_npmVersion": "1.2.27", "_npmUser": {"name": "shubik", "email": "farennikov@gmail.com"}, "maintainers": [{"name": "shubik", "email": "farennikov@gmail.com"}], "directories": {}}, "0.1.3": {"author": {"name": "Alexander Farennikov", "email": "farennikov@gmail.com"}, "name": "prometheus", "description": "Simple ODM for Node.js with pluggable adapters", "keywords": ["ODM", "object document mapping", "prometheus", "adapter", "mongodb"], "homepage": "https://github.com/shubik/prometheus", "license": "MIT", "contributors": [], "version": "0.1.3", "repository": {"type": "git", "url": "https://github.com/shubik/prometheus"}, "bugs": {"url": "https://github.com/shubik/prometheus/issues"}, "main": "./lib/index.js", "scripts": {}, "engines": {"node": ">= 0.4.0"}, "dependencies": {"underscore": "~1.4.4", "deferred": "~0.6.1", "mongodb": "~1.2.14", "MD5": "~1.0.3"}, "devDependencies": {}, "readme": "Prometheus\n==========\n\nPrometheus is a simple ODM for Node.js with adapter for MongoDB (so far) and built-in __form builder__, __form parser__, and __table builder__. Form parser has __uploads handler__ with __image resizer.__\n\nBecause of async nature of database calls, Prometheus' model constructor has an internal promise (we use [Deferred](https://github.com/medikoo/deferred) library), which is exposed via attribute `ready`. This promise resolves with model once model is initialized (e.g. a blank model, `var user = new UserModel({})`), or loaded from database (e.g. if you provide a query, `var user = new UserModel({ id: 123 })`). If you're trying to load with a query a model that does not exist, you can know if by checking `model.get() === null` or `model.toJSON() === null`.\n\n## Installation\n\n### NPM\n\nIn your project path:\n\n```javascript\n$ npm install prometheus\n```\n\n## Defining models:\n\nYou define model by passing model-specific options to ModelFactory, which returns a model constructor.\n\n### Required params\n\n*   `name` \u2014 Friendly name of your model, e.g. `UserModel`\n*   `schema` \u2014 Description of model attributes\n\n### Optional params\n\n*   `mixins` \u2014 An array with mixins that will be applied to constructor's prototype\n*   `prototype_methods` \u2014 Model-specific methods that will be added to constructor's prototype\n*   `static_methods` \u2014 Model-specific static methods that will be added to constructor\n*   `hooks` \u2014 Model-specific hooks (callbacks) that will be called during model lifecycle, e.g. `afterInitialize`, `beforeSave` etc.\n*   `permissions` \u2014 Object with a list of CRUDT permissions\n*   `roles` \u2014 Object with functions which check permissions per each role listed in `permissions`\n\n## Defining a model example\n\n```javascript\nvar prometheus    = require('prometheus'),\n    ModelFactory  = prometheus.factory,\n    MongodbStore  = prometheus.stores.mongodb,\n    MD5           = prometheus.MD5,\n    UserModel,\n    model_options;\n\nmodel_options = {\n\n    name: 'ExampleModel',\n\n    store: new MongodbStore({\n        collection: 'example'\n    }),\n\n    schema: {\n        name: {\n            name: 'Name',\n            default: '',\n            type: ModelFactory.types.STRING\n        },\n        email: {\n            name: 'Email',\n            default: '',\n            type: ModelFactory.types.STRING,\n            validate: Validators.isEmail,\n            index: ModelFactory.indexes.UNIQUE\n        },\n        password: {\n            name: 'Password',\n            default: '',\n            type: ModelFactory.types.STRING,\n            hidden: true\n        }\n    },\n\n    mixins: [],\n\n    prototype_methods: {},\n\n    static_methods: {\n        login: function(req, options) {\n            // your login logic\n        },\n\n        logout: function(req) {\n            // your logout logic\n        }\n    },\n\n    hooks: {\n        beforeSave: function() {\n            var password = this.get('password');\n\n            if (password.length !== 32) {\n                this.set('password', MD5(password));\n            }\n\n            this.set('updated_at', utils.now());\n        }\n    }\n}\n\nUserModel = module.exports = ModelFactory(model_options);\n```\n\n## Instantiating models\n\nBlank model is instantiated by calling a model constructor with a blank query as first argument:\n\n```javascript\nvar user = new UserModel({}, { req: req });\n\nuser.ready(function(model) {\n    model.set({\n        name: 'Shubik',\n        email: 'farennikov@gmail.com',\n        password: 'password'\n    });\n\n    model.save()(function(model) {\n        // model successfully saved\n    }, function(err) {\n        // handle error\n    });\n}, function(err) {\n    // handle error\n});\n```\n\nExisting model is instantiated with a query as first argument:\n\n```javascript\nvar user = new UserModel({ email: 'farennikov@gmail.com' }, { req: req });\n\nuser.ready(function(model) {\n    if (model.toJSON() === null) {\n        // model with this email not found - save new\n        model.set({ email: 'farennikov@gmail.com' });\n    } else {\n        var new_name = model.get('name') + ' updated';\n        model.set('name', new_name);\n    }\n    model.save();\n}, function(err) {\n    // handle error\n});\n```\n\nNote that if model with such id is not found, promise will resolve with `null`.\n\n## Model API\n\n__Instance methods__\n\n### model.get()\n\n`get(attr)` retrieves an attribute of the model, or an entire model if attribute name is not provided.\n\n### model.set()\n\n`set(attr, [value])` sssigns new value to an attribute or a number of attributes of the model. If given only 1 param which is an Object, method will use keys of the object as attributes.\n\n### model.save()\n\n`save()` saves a new model or model that has been changed by `set()`. Returns a promise which is resolved with model if model was successfully saved or error if saving model failed. If model was initialized without an id, new model will be attempted to be created.\n\n### model.destroy()\n\n`destroy()` deletes model from a store. Returns a promise which is resolved with this model once model is deleted from database.\n\n### model.toJSON()\n\n`toJSON()` returns all attributes of the model (key-value pairs).\n\n### model.validate()\n\n`validate()` validates model attributes according to the model's schema. Returns true or false.\n\n### model.toForm()\n\n`toForm()` returns an object that can be used to create HTML form for this model.\n\n### model.parseForm()\n\n`parseForm(req)` populates a model by values from a request.\n\n### model.toTable()\n\n`toTable()` returns an object that can be used to show this model in table form.\n\nYou can add model-specific instance methods by adding them to `prototype_methods` param of the options you pass to `ModelFactory`.\n\n__Static methods__\n\nModel constructors can have static methods which you can use without instantiating a model. By default there are two static methods: `find()` and `count()`:\n\n### SomeModel.find()\n\n`find(query, offset, limit, sort)` returns a promise which is resolved with an array of models found in database using provided arguments. Example:\n\n```javascript\nUserModel.find({ name: 'Shubik' })(function(results) {\n    // do somethig with `results`\n});\n```\n\n### SomeModel.count()\n\n`count()` returns a promise which is resolved with number of all models in the database. Example:\n\n```javascript\nUserModel.count()(function(num) {\n    // do somethig with `num`\n});\n```\n\nYou can add more model-specific static methods to `static_methods` param of the options you pass to `ModelFactory`.\n\n## Form builder\n\nEach model has built-in method `model.toForm()` which returns an object that you can use to render forms. Below is an example route that uses `toForm()` method to display form for adding a new company:\n\n```javascript\nadd: function(req, res) {\n    var company = new CompanyModel({}, { req: req });\n\n    company.ready(function(model) {\n\n        model.set('auth_token', MD5(_.random(1000000, 9999999) + config.auth.salt));\n\n        var model_form = model.toForm({\n            url         : '/rest/company',\n            method      : 'POST',\n            show_hidden : true\n        });\n\n        res.render('admin/company_add', {\n            title      : 'Add company',\n            model_form : model_form\n        });\n\n    }, function(err) {\n        res.send(400, err.toString());\n    });\n}\n```\n\nActual form is rendered using a Jade mixin and Twitter Bootstrap, as follows:\n\n```jade\nmixin form_builder(formdata)\n  form.form-horizontal.themed(id=\"#{formdata.tag.id}\", name=\"#{formdata.tag.name}\", method=\"#{formdata.tag.method}\", action=\"#{formdata.tag.action}\", enctype=\"#{formdata.tag.enctype}\")\n    fieldset\n      for field in formdata.fields\n        .control-group\n          label.control-label #{field.label}\n          .controls\n            for inp in field.inputs\n\n              if field.type == 'text'\n                !{inp}\n\n              if field.type == 'textarea'\n                !{inp}\n\n              if field.type == 'select'\n                !{inp}\n\n              if field.type == 'checkbox'\n                label.checkbox\n                  !{inp}\n\n              if field.type == 'radio'\n                label.radio\n                  !{inp}\n\n              if field.type == 'other'\n                !{inp}\n\n      .form-actions\n        button.btn.medium.btn-primary(type=\"submit\") Save\n```\n\nAnd this mixin is called from respective view as follows:\n\n```jade\n+form_builder(model_form)\n```\n\n## Form parser\n\nEach model has built-in method `model.parseForm()` which returns an object that you can use to render forms. Below is an example route that uses `parseForm()` method to add a new company:\n\n```javascript\ncreate: function(req, res) {\n    var params  = _.extend(req.params || {}, req.query || {}, req.body || {}),\n        company = new CompanyModel({}, { req: req });\n\n    company.ready(function(model) {\n        model.parseForm(req)(function(model) {\n            model.save()(function(model) {\n                res.json(200, model.toJSON());\n            }, function(err) {\n                res.send(400, err.toString());\n            });\n        }, function(err) {\n            res.send(400, err.toString());\n        });\n    });\n}\n```\n\n### Using image resizer\n\nYou can optionally resize your image uploads by adding `resize` property to schema attribute, such as in this example:\n\n```javascript\nschema: {\n    logo: {\n        name: 'Company Logo',\n        default: null,\n        type: ModelFactory.types.STRING,\n        content_type: 'image/jpeg, image/png, image/gif',\n        resize: ['c100', 's600x600', 's1200x1200']\n    }\n}\n```\n\nPlease note, that uploads are saved in store as their public URLs, not as a binary. Therefore in order to save uploads, your model definition needs to have `uploads` attribute, which is an object with two params: `path` and `path_public`, where `path` is path to upload folder on the server, and `path_public` is a path to the upload relative to your domain, e.g.:\n\n```javascript\nuploads: {\n    path: '/home/ubuntu/myproject/node/public/uploads/',\n    path_public: '/uploads/'\n}\n```\n\nYou can generate `path` in your app.js as follows:\n\n```javascript\nvar uploads = {\n    path_public: '/uploads/'\n};\nuploads.path = __dirname + '/public' + config.uploads.path_public;\n```\n\nUploaded images will be saved in the provided path and will be persisted in the store as public path, e.g. `/uploads/3e192ca4fa8ec546cdb6ef6e2ab55b00.jpg`.\n\n### Image sizes\n\nImage sizes are listed in the `resize` param of the attribute schema and you can add as many size definitions as you want. There are two notations for the image sizes:\n\n*   __Crop:__ `cXXX`, e.g. `c100` which will generate thumbs 100x100px centered in the middle of the original image\n*   __Resize:__ `sXXXxYYY`, e.g. `s600x600` which will generate image with either size up to 600px wide or high\n\nAll additional sizes are saved using image basename followed with `_{size}.ext`, e.g. `3e192ca4fa8ec546cdb6ef6e2ab55b00_c100.jpg` or `3e192ca4fa8ec546cdb6ef6e2ab55b00_s600x600.jpg`.\n\nImage resizer required [Imagemagick](http://www.imagemagick.org/script/index.php) to be installed on your host.\n\n## Validators\n\nPrometheus does validation by data type as long as you use `type` property in schema item description. But if attribute's value requires more specific validation, you can add a `validate` property to schema item. For example, if you want to know if value is a number Pi (to a certain proximity), you can add a validator:\n\n```javascript\nschema: {\n    pi: {\n        name: 'Pi',\n        default: null,\n        type: ModelFactory.types.NUMBER,\n        validate: function(val) {\n            return val / Math.PI > 0.999;\n        }\n    }\n}\n```\n\n## Schema properties\n\n### Required\n\n*   `name` \u2014 {String} Friendly name for this attribute, e.g. \"UserModel\"\n*   `default` \u2014 {Mixed} Default attribute value, e.g. `null`, `\"changeme\"`, etc.\n*   `type` \u2014 {String} Data type from list of constants in ModelFactory.types\n\n### Optional\n\n*   `validate` \u2014 {Function} that validates attribute value (see above)\n*   `permitted` \u2014 {Array} Permitted values\n*   `content_type` \u2014 {String} Comma separated mime types, default `text/plain`\n*   `resize` \u2014 {Array} Desired image sizes (see above)\n*   `maxlength` \u2014 {Number} Number if string has a maximum length\n*   `maketag` \u2014 {Function} that returns a custom HTML tag for this field\n*   `readonly` \u2014 {Boolean} True if user is not allowed to change value\n*   `sync` \u2014 {Boolean} False if should not be synced with store\n*   `index` \u2014 {String} Type of index, e.g. UNIQUE, FULLTEXT etc.\n\n## Permissions\n\nPrometheus has model level permissions management. Defining permissions is optional. If permission rules are not defined, all permissions are set to `true`.\n\n### Defining permissions\n\nYou can define permissions for models by adding `permissions` and `roles` properties to `model_options` of a model, as in the example below. `permissions` is a hash with key-value pairs, where keys are CRUD operations and values are arrays with user roles, able to perform corresponding operations:\n\n```javascript\npermissions: {\n    'create'   : ['admin'],\n    'read'     : ['admin', 'user', 'guest'],\n    'update'   : ['admin', 'user'],\n    'destroy'  : ['admin'],\n    'transfer' : ['admin']\n}\n```\n\nTwo built-in roles are `app` and `guest`: if you do no pass `req` to the model constructor in the options, we assume that this model is not created within a function handling a route, so it's created elsewhere by the application. At the other hand, if `req` was passed with options, we assume that model is created as a result of HTTP(S) request by a user, who by default is a guest.\n\n`roles` is a hash of functions which return promises resolved with boolean result of permission checks:\n\n```javascript\nroles: {\n    user: function (model, req) {\n        var def = deferred(),\n            pass = !!(req && req.session.user);\n\n        def.resolve({ user: pass });\n        return def.promise;\n    },\n\n    admin: function (model, req) {\n        var def = deferred(),\n            pass = !!(req && req.session.user && req.session.user.roles.indexOf('admin') !== -1);\n\n        def.resolve({ admin: pass });\n        return def.promise;\n    }\n}\n```\n\nAbove example adds custom user role checks for `user` and `admin`, where user is anyone with user hash inside `req.session` and `admin` is a user whose roles hash contains \"admin\".\n\nPlease note that all of these functions return a promise \u2014 this is important because in Prometheus' internals we use `deferred.map()` to check all permissions. We did this on purpose because some permission checkers may be asyncronous.\n\n### Handling 403 Forbidden situations\n\nIf you are using any method on the model that involves CRUD operations, and user's permissions are insufficient to do a certain operation on the model, an error event will fire on the model, which you can handle by subscribing to it where you instantiate the model:\n\n```javascript\nvar model = new UserModel({ email: 'farennikov@gmail.com' }, { req: req });\n\nmodel.on('error', function(err) {\n    res.send(403, err.toString());\n});\n\nmodel.ready(function(model) {\n    model.set('foo', 'bar');\n    model.save();\n});\n```\n\nAbove example will send client \"403 Forbidden\" headers if session user does not have update rights.\n\n## Changelog\n\n### v.0.1.3\n\n*   Added ability to create and remove indexes on the store's collections\n*   Removed `unique` param from schema; use `index: ModelFactory.indexes.UNIQUE` instead\n\n### v.0.1.2\n\n*   Refactored evt_handlers.js\n*   Fixed examples\n\n### v.0.1.1\n\n*   Moved some event handlers in model_factory.js initializer to separate dependencies\n*   Changed `model.find()` attributes to accept only `query` and `options`\n*   Removed `multiline` param from schema descriptions; use `datatypes.TEXT` instead\n\n### v.0.1.0\n\n*   Instantiating model arguments changed to `query` and `[options]`\n*   Model constructor does not return promise any more; it returns self (model)\n*   If model is not found with a query, `model.ready` is resolved with `this`, not `null` as in previous versions. This allows you not to have to instantiate a new blank model, but instead reuse existing model instance\n*   Added model-level permissions\n\n### v.0.0.3\n\n*   Added setters and getters for model attributes\n*   Removed built-in validators\n*   Added implicit check for changes in model attributes before update\n*   Refactored `destroy()` method\n\n### v.0.0.2\n\n*   Refactored image uploader\n*   Added image resizer. Note that image resizer needs __imagemagick__ to be installed.", "readmeFilename": "README.md", "_id": "prometheus@0.1.3", "dist": {"shasum": "b3328b3e11f64ca61e747ac3e3e595292773208d", "tarball": "https://registry.npmjs.org/prometheus/-/prometheus-0.1.3.tgz", "integrity": "sha512-lJpvfhvBjs1uikkaroYh1SaaxLzmGJs6lxCqhCynXu0vzrRwpdvkKp/klibeNFQqOA84WpSjFer3prS6MQdzsw==", "signatures": [{"keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA", "sig": "MEUCIQCLD2vXABYfAXo6WTBnd5wr+oZqGkRZqQh3nTeXYPGoiQIgaVVHVCpXkicOPu0iWz3rlSiNM5XOP3C9st49uNd3hH8="}]}, "_from": ".", "_npmVersion": "1.2.27", "_npmUser": {"name": "shubik", "email": "farennikov@gmail.com"}, "maintainers": [{"name": "shubik", "email": "farennikov@gmail.com"}], "directories": {}}, "0.1.4": {"version": "0.1.4", "author": {"name": "Alexander Farennikov", "email": "farennikov@gmail.com"}, "name": "prometheus", "description": "Simple ODM for Node.js with pluggable adapters", "keywords": ["ODM", "object document mapping", "prometheus", "adapter", "mongodb"], "homepage": "https://github.com/shubik/prometheus", "license": "MIT", "contributors": [], "repository": {"type": "git", "url": "https://github.com/shubik/prometheus"}, "bugs": {"url": "https://github.com/shubik/prometheus/issues"}, "main": "./lib/index.js", "scripts": {}, "engines": {"node": ">= 0.4.0"}, "dependencies": {"underscore": "~1.4.4", "deferred": "~0.6.1", "mongodb": "~1.2.14", "MD5": "~1.0.3"}, "devDependencies": {}, "readme": "Prometheus\n==========\n\nPrometheus is a simple ODM for Node.js with adapter for MongoDB (so far) and built-in __form builder__, __form parser__, and __table builder__. Form parser has __uploads handler__ with __image resizer.__\n\nBecause of async nature of database calls, Prometheus' model constructor has an internal promise (we use [Deferred](https://github.com/medikoo/deferred) library), which is exposed via attribute `ready`. This promise resolves with model once model is initialized (e.g. a blank model, `var user = new UserModel({})`), or loaded from database (e.g. if you provide a query, `var user = new UserModel({ id: 123 })`). If you're trying to load with a query a model that does not exist, you can know if by checking `model.get() === null` or `model.toJSON() === null`.\n\n## Installation\n\n### NPM\n\nIn your project path:\n\n```javascript\n$ npm install prometheus\n```\n\n## Defining models:\n\nYou define model by passing model-specific options to ModelFactory, which returns a model constructor.\n\n### Required params\n\n*   `name` \u2014 Friendly name of your model, e.g. `UserModel`\n*   `schema` \u2014 Description of model attributes\n\n### Optional params\n\n*   `mixins` \u2014 An array with mixins that will be applied to constructor's prototype\n*   `prototype_methods` \u2014 Model-specific methods that will be added to constructor's prototype\n*   `static_methods` \u2014 Model-specific static methods that will be added to constructor\n*   `hooks` \u2014 Model-specific hooks (callbacks) that will be called during model lifecycle, e.g. `afterInitialize`, `beforeSave` etc.\n*   `permissions` \u2014 Object with a list of CRUDT permissions\n*   `roles` \u2014 Object with functions which check permissions per each role listed in `permissions`\n\n## Defining a model example\n\n```javascript\nvar prometheus    = require('prometheus'),\n    ModelFactory  = prometheus.factory,\n    MongodbStore  = prometheus.stores.mongodb,\n    MD5           = prometheus.MD5,\n    UserModel,\n    model_options;\n\nmodel_options = {\n\n    name: 'ExampleModel',\n\n    store: new MongodbStore({\n        collection: 'example'\n    }),\n\n    schema: {\n        name: {\n            name: 'Name',\n            default: '',\n            type: ModelFactory.types.STRING\n        },\n        email: {\n            name: 'Email',\n            default: '',\n            type: ModelFactory.types.STRING,\n            validate: Validators.isEmail,\n            index: ModelFactory.indexes.UNIQUE\n        },\n        password: {\n            name: 'Password',\n            default: '',\n            type: ModelFactory.types.STRING,\n            hidden: true\n        }\n    },\n\n    mixins: [],\n\n    prototype_methods: {},\n\n    static_methods: {\n        login: function(req, options) {\n            // your login logic\n        },\n\n        logout: function(req) {\n            // your logout logic\n        }\n    },\n\n    hooks: {\n        beforeSave: function() {\n            var password = this.get('password');\n\n            if (password.length !== 32) {\n                this.set('password', MD5(password));\n            }\n\n            this.set('updated_at', utils.now());\n        }\n    }\n}\n\nUserModel = module.exports = ModelFactory(model_options);\n```\n\n## Instantiating models\n\nBlank model is instantiated by calling a model constructor with a blank query as first argument:\n\n```javascript\nvar user = new UserModel({}, { req: req });\n\nuser.ready(function(model) {\n    model.set({\n        name: 'Shubik',\n        email: 'farennikov@gmail.com',\n        password: 'password'\n    });\n\n    model.save()(function(model) {\n        // model successfully saved\n    }, function(err) {\n        // handle error\n    });\n}, function(err) {\n    // handle error\n});\n```\n\nExisting model is instantiated with a query as first argument:\n\n```javascript\nvar user = new UserModel({ email: 'farennikov@gmail.com' }, { req: req });\n\nuser.ready(function(model) {\n    if (model.toJSON() === null) {\n        // model with this email not found - save new\n        model.set({ email: 'farennikov@gmail.com' });\n    } else {\n        var new_name = model.get('name') + ' updated';\n        model.set('name', new_name);\n    }\n    model.save();\n}, function(err) {\n    // handle error\n});\n```\n\nNote that if model with such id is not found, promise will resolve with `null`.\n\n## Model API\n\n__Instance methods__\n\n### model.get()\n\n`get(attr)` retrieves an attribute of the model, or an entire model if attribute name is not provided.\n\n### model.set()\n\n`set(attr, [value])` sssigns new value to an attribute or a number of attributes of the model. If given only 1 param which is an Object, method will use keys of the object as attributes.\n\n### model.save()\n\n`save()` saves a new model or model that has been changed by `set()`. Returns a promise which is resolved with model if model was successfully saved or error if saving model failed. If model was initialized without an id, new model will be attempted to be created.\n\n### model.destroy()\n\n`destroy()` deletes model from a store. Returns a promise which is resolved with this model once model is deleted from database.\n\n### model.toJSON()\n\n`toJSON()` returns all attributes of the model (key-value pairs).\n\n### model.validate()\n\n`validate()` validates model attributes according to the model's schema. Returns true or false.\n\n### model.toForm()\n\n`toForm()` returns an object that can be used to create HTML form for this model.\n\n### model.parseForm()\n\n`parseForm(req)` populates a model by values from a request.\n\n### model.toTable()\n\n`toTable()` returns an object that can be used to show this model in table form.\n\nYou can add model-specific instance methods by adding them to `prototype_methods` param of the options you pass to `ModelFactory`.\n\n__Static methods__\n\nModel constructors can have static methods which you can use without instantiating a model. By default there are two static methods: `find()` and `count()`:\n\n### SomeModel.find()\n\n`find(query, offset, limit, sort)` returns a promise which is resolved with an array of models found in database using provided arguments. Example:\n\n```javascript\nUserModel.find({ name: 'Shubik' })(function(results) {\n    // do somethig with `results`\n});\n```\n\n### SomeModel.count()\n\n`count()` returns a promise which is resolved with number of all models in the database. Example:\n\n```javascript\nUserModel.count()(function(num) {\n    // do somethig with `num`\n});\n```\n\nYou can add more model-specific static methods to `static_methods` param of the options you pass to `ModelFactory`.\n\n## Form builder\n\nEach model has built-in method `model.toForm()` which returns an object that you can use to render forms. Below is an example route that uses `toForm()` method to display form for adding a new company:\n\n```javascript\nadd: function(req, res) {\n    var company = new CompanyModel({}, { req: req });\n\n    company.ready(function(model) {\n\n        model.set('auth_token', MD5(_.random(1000000, 9999999) + config.auth.salt));\n\n        var model_form = model.toForm({\n            url         : '/rest/company',\n            method      : 'POST',\n            show_hidden : true\n        });\n\n        res.render('admin/company_add', {\n            title      : 'Add company',\n            model_form : model_form\n        });\n\n    }, function(err) {\n        res.send(400, err.toString());\n    });\n}\n```\n\nActual form is rendered using a Jade mixin and Twitter Bootstrap, as follows:\n\n```jade\nmixin form_builder(formdata)\n  form.form-horizontal.themed(id=\"#{formdata.tag.id}\", name=\"#{formdata.tag.name}\", method=\"#{formdata.tag.method}\", action=\"#{formdata.tag.action}\", enctype=\"#{formdata.tag.enctype}\")\n    fieldset\n      for field in formdata.fields\n        .control-group\n          label.control-label #{field.label}\n          .controls\n            for inp in field.inputs\n\n              if field.type == 'text'\n                !{inp}\n\n              if field.type == 'textarea'\n                !{inp}\n\n              if field.type == 'select'\n                !{inp}\n\n              if field.type == 'checkbox'\n                label.checkbox\n                  !{inp}\n\n              if field.type == 'radio'\n                label.radio\n                  !{inp}\n\n              if field.type == 'other'\n                !{inp}\n\n      .form-actions\n        button.btn.medium.btn-primary(type=\"submit\") Save\n```\n\nAnd this mixin is called from respective view as follows:\n\n```jade\n+form_builder(model_form)\n```\n\n## Form parser\n\nEach model has built-in method `model.parseForm()` which returns an object that you can use to render forms. Below is an example route that uses `parseForm()` method to add a new company:\n\n```javascript\ncreate: function(req, res) {\n    var params  = _.extend(req.params || {}, req.query || {}, req.body || {}),\n        company = new CompanyModel({}, { req: req });\n\n    company.ready(function(model) {\n        model.parseForm(req)(function(model) {\n            model.save()(function(model) {\n                res.json(200, model.toJSON());\n            }, function(err) {\n                res.send(400, err.toString());\n            });\n        }, function(err) {\n            res.send(400, err.toString());\n        });\n    });\n}\n```\n\n### Using image resizer\n\nYou can optionally resize your image uploads by adding `resize` property to schema attribute, such as in this example:\n\n```javascript\nschema: {\n    logo: {\n        name: 'Company Logo',\n        default: null,\n        type: ModelFactory.types.STRING,\n        content_type: 'image/jpeg, image/png, image/gif',\n        resize: ['c100', 's600x600', 's1200x1200']\n    }\n}\n```\n\nPlease note, that uploads are saved in store as their public URLs, not as a binary. Therefore in order to save uploads, your model definition needs to have `uploads` attribute, which is an object with two params: `path` and `path_public`, where `path` is path to upload folder on the server, and `path_public` is a path to the upload relative to your domain, e.g.:\n\n```javascript\nuploads: {\n    path: '/home/ubuntu/myproject/node/public/uploads/',\n    path_public: '/uploads/'\n}\n```\n\nYou can generate `path` in your app.js as follows:\n\n```javascript\nvar uploads = {\n    path_public: '/uploads/'\n};\nuploads.path = __dirname + '/public' + config.uploads.path_public;\n```\n\nUploaded images will be saved in the provided path and will be persisted in the store as public path, e.g. `/uploads/3e192ca4fa8ec546cdb6ef6e2ab55b00.jpg`.\n\n### Image sizes\n\nImage sizes are listed in the `resize` param of the attribute schema and you can add as many size definitions as you want. There are two notations for the image sizes:\n\n*   __Crop:__ `cXXX`, e.g. `c100` which will generate thumbs 100x100px centered in the middle of the original image\n*   __Resize:__ `sXXXxYYY`, e.g. `s600x600` which will generate image with either size up to 600px wide or high\n\nAll additional sizes are saved using image basename followed with `_{size}.ext`, e.g. `3e192ca4fa8ec546cdb6ef6e2ab55b00_c100.jpg` or `3e192ca4fa8ec546cdb6ef6e2ab55b00_s600x600.jpg`.\n\nImage resizer required [Imagemagick](http://www.imagemagick.org/script/index.php) to be installed on your host.\n\n## Validators\n\nPrometheus does validation by data type as long as you use `type` property in schema item description. But if attribute's value requires more specific validation, you can add a `validate` property to schema item. For example, if you want to know if value is a number Pi (to a certain proximity), you can add a validator:\n\n```javascript\nschema: {\n    pi: {\n        name: 'Pi',\n        default: null,\n        type: ModelFactory.types.NUMBER,\n        validate: function(val) {\n            return val / Math.PI > 0.999;\n        }\n    }\n}\n```\n\n## Schema properties\n\n### Required\n\n*   `name` \u2014 {String} Friendly name for this attribute, e.g. \"UserModel\"\n*   `default` \u2014 {Mixed} Default attribute value, e.g. `null`, `\"changeme\"`, etc.\n*   `type` \u2014 {String} Data type from list of constants in ModelFactory.types\n\n### Optional\n\n*   `validate` \u2014 {Function} that validates attribute value (see above)\n*   `permitted` \u2014 {Array} Permitted values\n*   `content_type` \u2014 {String} Comma separated mime types, default `text/plain`\n*   `resize` \u2014 {Array} Desired image sizes (see above)\n*   `maxlength` \u2014 {Number} Number if string has a maximum length\n*   `maketag` \u2014 {Function} that returns a custom HTML tag for this field\n*   `readonly` \u2014 {Boolean} True if user is not allowed to change value\n*   `sync` \u2014 {Boolean} False if should not be synced with store\n*   `index` \u2014 {String} Type of index, e.g. UNIQUE, FULLTEXT etc.\n*   `required` \u2014 {Boolean} true if value can not be empty, null or default\n\n## Permissions\n\nPrometheus has model level permissions management. Defining permissions is optional. If permission rules are not defined, all permissions are set to `true`.\n\n### Defining permissions\n\nYou can define permissions for models by adding `permissions` and `roles` properties to `model_options` of a model, as in the example below. `permissions` is a hash with key-value pairs, where keys are CRUD operations and values are arrays with user roles, able to perform corresponding operations:\n\n```javascript\npermissions: {\n    'create'   : ['admin'],\n    'read'     : ['admin', 'user', 'guest'],\n    'update'   : ['admin', 'user'],\n    'destroy'  : ['admin'],\n    'transfer' : ['admin']\n}\n```\n\nTwo built-in roles are `app` and `guest`: if you do no pass `req` to the model constructor in the options, we assume that this model is not created within a function handling a route, so it's created elsewhere by the application. At the other hand, if `req` was passed with options, we assume that model is created as a result of HTTP(S) request by a user, who by default is a guest.\n\n`roles` is a hash of functions which return promises resolved with boolean result of permission checks:\n\n```javascript\nroles: {\n    user: function (model, req) {\n        var def = deferred(),\n            pass = !!(req && req.session.user);\n\n        def.resolve({ user: pass });\n        return def.promise;\n    },\n\n    admin: function (model, req) {\n        var def = deferred(),\n            pass = !!(req && req.session.user && req.session.user.roles.indexOf('admin') !== -1);\n\n        def.resolve({ admin: pass });\n        return def.promise;\n    }\n}\n```\n\nAbove example adds custom user role checks for `user` and `admin`, where user is anyone with user hash inside `req.session` and `admin` is a user whose roles hash contains \"admin\".\n\nPlease note that all of these functions return a promise \u2014 this is important because in Prometheus' internals we use `deferred.map()` to check all permissions. We did this on purpose because some permission checkers may be asyncronous.\n\n### Handling 403 Forbidden situations\n\nIf you are using any method on the model that involves CRUD operations, and user's permissions are insufficient to do a certain operation on the model, an error event will fire on the model, which you can handle by subscribing to it where you instantiate the model:\n\n```javascript\nvar model = new UserModel({ email: 'farennikov@gmail.com' }, { req: req });\n\nmodel.on('error', function(err) {\n    res.send(403, err.toString());\n});\n\nmodel.ready(function(model) {\n    model.set('foo', 'bar');\n    model.save();\n});\n```\n\nAbove example will send client \"403 Forbidden\" headers if session user does not have update rights.\n\n## Changelog\n\n### v.0.1.4\n\n*   Added typecasting to values parsed by `parseForm`\n*   Added optional `required` attribute to schema\n*   Added check for `required` attribute, `PRIMARY` and `UNIQUE` indexes in model validator\n*   Misc. bug fixes\n\n### v.0.1.3\n\n*   Added ability to create and remove indexes on the store's collections\n*   Removed `unique` param from schema; use `index: ModelFactory.indexes.UNIQUE` instead\n\n### v.0.1.2\n\n*   Refactored evt_handlers.js\n*   Fixed examples\n\n### v.0.1.1\n\n*   Moved some event handlers in model_factory.js initializer to separate dependencies\n*   Changed `model.find()` attributes to accept only `query` and `options`\n*   Removed `multiline` param from schema descriptions; use `datatypes.TEXT` instead\n\n### v.0.1.0\n\n*   Instantiating model arguments changed to `query` and `[options]`\n*   Model constructor does not return promise any more; it returns self (model)\n*   If model is not found with a query, `model.ready` is resolved with `this`, not `null` as in previous versions. This allows you not to have to instantiate a new blank model, but instead reuse existing model instance\n*   Added model-level permissions\n\n### v.0.0.3\n\n*   Added setters and getters for model attributes\n*   Removed built-in validators\n*   Added implicit check for changes in model attributes before update\n*   Refactored `destroy()` method\n\n### v.0.0.2\n\n*   Refactored image uploader\n*   Added image resizer. Note that image resizer needs __imagemagick__ to be installed.", "readmeFilename": "README.md", "_id": "prometheus@0.1.4", "dist": {"shasum": "470a52678df02857ab866462c1a93957d5b24173", "tarball": "https://registry.npmjs.org/prometheus/-/prometheus-0.1.4.tgz", "integrity": "sha512-ibYwkQXpgjFPwbsFgy1nnrAU+8i2nk+b1Ke8VFpjosKdrLl/fP/PI+CbMPA/MgUuSeVjvywkMNvpzTteYvor3A==", "signatures": [{"keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA", "sig": "MEUCID1CuxME2YpPgKMYTI/zroosPMkTLyDf7aNp/OyFEwA3AiEA/m/zM4Y7sGdl7ltPUdqitPVtfogLi8LC8/H2XjCM9cg="}]}, "_from": ".", "_npmVersion": "1.2.18", "_npmUser": {"name": "shubik", "email": "farennikov@gmail.com"}, "maintainers": [{"name": "shubik", "email": "farennikov@gmail.com"}], "directories": {}}, "0.1.5": {"version": "0.1.5", "author": {"name": "Alexander Farennikov", "email": "farennikov@gmail.com"}, "name": "prometheus", "description": "Simple ODM for Node.js with pluggable adapters", "keywords": ["ODM", "object document mapping", "prometheus", "adapter", "mongodb"], "homepage": "https://github.com/shubik/prometheus", "license": "MIT", "contributors": [], "repository": {"type": "git", "url": "https://github.com/shubik/prometheus"}, "bugs": {"url": "https://github.com/shubik/prometheus/issues"}, "main": "./lib/index.js", "scripts": {}, "engines": {"node": ">= 0.4.0"}, "dependencies": {"underscore": "~1.4.4", "deferred": "~0.6.1", "mongodb": "~1.2.14", "MD5": "~1.0.3"}, "devDependencies": {}, "readme": "Prometheus\n==========\n\nPrometheus is a simple ODM for Node.js with adapter for MongoDB (so far) and built-in __form builder__, __form parser__, and __table builder__. Form parser has __uploads handler__ with __image resizer.__\n\nBecause of async nature of database calls, Prometheus' model constructor has an internal promise (we use [Deferred](https://github.com/medikoo/deferred) library), which is exposed via attribute `ready`. This promise resolves with model once model is initialized (e.g. a blank model, `var user = new UserModel({})`), or loaded from database (e.g. if you provide a query, `var user = new UserModel({ id: 123 })`). If you're trying to load with a query a model that does not exist, you can know if by checking `model.get() === null` or `model.toJSON() === null`.\n\n## Installation\n\n### NPM\n\nIn your project path:\n\n```javascript\n$ npm install prometheus\n```\n\n## Defining models:\n\nYou define model by passing model-specific options to ModelFactory, which returns a model constructor.\n\n### Required params\n\n*   `name` \u2014 Friendly name of your model, e.g. `UserModel`\n*   `schema` \u2014 Description of model attributes\n\n### Optional params\n\n*   `mixins` \u2014 An array with mixins that will be applied to constructor's prototype\n*   `prototype_methods` \u2014 Model-specific methods that will be added to constructor's prototype\n*   `static_methods` \u2014 Model-specific static methods that will be added to constructor\n*   `hooks` \u2014 Model-specific hooks (callbacks) that will be called during model lifecycle, e.g. `afterInitialize`, `beforeSave` etc.\n*   `permissions` \u2014 Object with a list of CRUDT permissions\n*   `roles` \u2014 Object with functions which check permissions per each role listed in `permissions`\n\n## Defining a model example\n\n```javascript\nvar prometheus    = require('prometheus'),\n    ModelFactory  = prometheus.factory,\n    MongodbStore  = prometheus.stores.mongodb,\n    MD5           = prometheus.MD5,\n    UserModel,\n    model_options;\n\nmodel_options = {\n\n    name: 'ExampleModel',\n\n    store: new MongodbStore({\n        collection: 'example'\n    }),\n\n    schema: {\n        name: {\n            name: 'Name',\n            default: '',\n            type: ModelFactory.types.STRING\n        },\n        email: {\n            name: 'Email',\n            default: '',\n            type: ModelFactory.types.STRING,\n            validate: Validators.isEmail,\n            index: ModelFactory.indexes.UNIQUE\n        },\n        password: {\n            name: 'Password',\n            default: '',\n            type: ModelFactory.types.STRING,\n            hidden: true\n        }\n    },\n\n    mixins: [],\n\n    prototype_methods: {},\n\n    static_methods: {\n        login: function(req, options) {\n            // your login logic\n        },\n\n        logout: function(req) {\n            // your logout logic\n        }\n    },\n\n    hooks: {\n        beforeSave: function() {\n            var password = this.get('password');\n\n            if (password.length !== 32) {\n                this.set('password', MD5(password));\n            }\n\n            this.set('updated_at', utils.now());\n        }\n    }\n}\n\nUserModel = module.exports = ModelFactory(model_options);\n```\n\n## Instantiating models\n\nBlank model is instantiated by calling a model constructor with a blank query as first argument:\n\n```javascript\nvar user = new UserModel({}, { req: req });\n\nuser.ready(function(model) {\n    model.set({\n        name: 'Shubik',\n        email: 'farennikov@gmail.com',\n        password: 'password'\n    });\n\n    model.save()(function(model) {\n        // model successfully saved\n    }, function(err) {\n        // handle error\n    });\n}, function(err) {\n    // handle error\n});\n```\n\nExisting model is instantiated with a query as first argument:\n\n```javascript\nvar user = new UserModel({ email: 'farennikov@gmail.com' }, { req: req });\n\nuser.ready(function(model) {\n    if (model.toJSON() === null) {\n        // model with this email not found - save new\n        model.set({ email: 'farennikov@gmail.com' });\n    } else {\n        var new_name = model.get('name') + ' updated';\n        model.set('name', new_name);\n    }\n    model.save();\n}, function(err) {\n    // handle error\n});\n```\n\nNote that if model with such id is not found, promise will resolve with `null`.\n\n## Model API\n\n__Instance methods__\n\n### model.get()\n\n`get(attr)` retrieves an attribute of the model, or an entire model if attribute name is not provided.\n\n### model.set()\n\n`set(attr, [value])` sssigns new value to an attribute or a number of attributes of the model. If given only 1 param which is an Object, method will use keys of the object as attributes.\n\n### model.save()\n\n`save()` saves a new model or model that has been changed by `set()`. Returns a promise which is resolved with model if model was successfully saved or error if saving model failed. If model was initialized without an id, new model will be attempted to be created.\n\n### model.destroy()\n\n`destroy()` deletes model from a store. Returns a promise which is resolved with this model once model is deleted from database.\n\n### model.toJSON()\n\n`toJSON()` returns all attributes of the model (key-value pairs).\n\n### model.validate()\n\n`validate()` validates model attributes according to the model's schema. Returns true or false.\n\n### model.toForm()\n\n`toForm()` returns an object that can be used to create HTML form for this model.\n\n### model.parseForm()\n\n`parseForm(req)` populates a model by values from a request.\n\n### model.toTable()\n\n`toTable()` returns an object that can be used to show this model in table form.\n\nYou can add model-specific instance methods by adding them to `prototype_methods` param of the options you pass to `ModelFactory`.\n\n__Static methods__\n\nModel constructors can have static methods which you can use without instantiating a model. By default there are two static methods: `find()` and `count()`:\n\n### SomeModel.find()\n\n`find(query, offset, limit, sort)` returns a promise which is resolved with an array of models found in database using provided arguments. Example:\n\n```javascript\nUserModel.find({ name: 'Shubik' })(function(results) {\n    // do somethig with `results`\n});\n```\n\n### SomeModel.count()\n\n`count()` returns a promise which is resolved with number of all models in the database. Example:\n\n```javascript\nUserModel.count()(function(num) {\n    // do somethig with `num`\n});\n```\n\nYou can add more model-specific static methods to `static_methods` param of the options you pass to `ModelFactory`.\n\n## Form builder\n\nEach model has built-in method `model.toForm()` which returns an object that you can use to render forms. Below is an example route that uses `toForm()` method to display form for adding a new company:\n\n```javascript\nadd: function(req, res) {\n    var company = new CompanyModel({}, { req: req });\n\n    company.ready(function(model) {\n\n        model.set('auth_token', MD5(_.random(1000000, 9999999) + config.auth.salt));\n\n        var model_form = model.toForm({\n            url         : '/rest/company',\n            method      : 'POST',\n            show_hidden : true\n        });\n\n        res.render('admin/company_add', {\n            title      : 'Add company',\n            model_form : model_form\n        });\n\n    }, function(err) {\n        res.send(400, err.toString());\n    });\n}\n```\n\nActual form is rendered using a Jade mixin and Twitter Bootstrap, as follows:\n\n```jade\nmixin form_builder(formdata)\n  form.form-horizontal.themed(id=\"#{formdata.tag.id}\", name=\"#{formdata.tag.name}\", method=\"#{formdata.tag.method}\", action=\"#{formdata.tag.action}\", enctype=\"#{formdata.tag.enctype}\")\n    fieldset\n      for field in formdata.fields\n        .control-group\n          label.control-label #{field.label}\n          .controls\n            for inp in field.inputs\n\n              if field.type == 'text'\n                !{inp}\n\n              if field.type == 'textarea'\n                !{inp}\n\n              if field.type == 'select'\n                !{inp}\n\n              if field.type == 'checkbox'\n                label.checkbox\n                  !{inp}\n\n              if field.type == 'radio'\n                label.radio\n                  !{inp}\n\n              if field.type == 'other'\n                !{inp}\n\n      .form-actions\n        button.btn.medium.btn-primary(type=\"submit\") Save\n```\n\nAnd this mixin is called from respective view as follows:\n\n```jade\n+form_builder(model_form)\n```\n\n## Form parser\n\nEach model has built-in method `model.parseForm()` which returns an object that you can use to render forms. Below is an example route that uses `parseForm()` method to add a new company:\n\n```javascript\ncreate: function(req, res) {\n    var params  = _.extend(req.params || {}, req.query || {}, req.body || {}),\n        company = new CompanyModel({}, { req: req });\n\n    company.ready(function(model) {\n        model.parseForm(req)(function(model) {\n            model.save()(function(model) {\n                res.json(200, model.toJSON());\n            }, function(err) {\n                res.send(400, err.toString());\n            });\n        }, function(err) {\n            res.send(400, err.toString());\n        });\n    });\n}\n```\n\n### Using image resizer\n\nYou can optionally resize your image uploads by adding `resize` property to schema attribute, such as in this example:\n\n```javascript\nschema: {\n    logo: {\n        name: 'Company Logo',\n        default: null,\n        type: ModelFactory.types.STRING,\n        content_type: 'image/jpeg, image/png, image/gif',\n        resize: ['c100', 's600x600', 's1200x1200']\n    }\n}\n```\n\nPlease note, that uploads are saved in store as their public URLs, not as a binary. Therefore in order to save uploads, your model definition needs to have `uploads` attribute, which is an object with two params: `path` and `path_public`, where `path` is path to upload folder on the server, and `path_public` is a path to the upload relative to your domain, e.g.:\n\n```javascript\nuploads: {\n    path: '/home/ubuntu/myproject/node/public/uploads/',\n    path_public: '/uploads/'\n}\n```\n\nYou can generate `path` in your app.js as follows:\n\n```javascript\nvar uploads = {\n    path_public: '/uploads/'\n};\nuploads.path = __dirname + '/public' + config.uploads.path_public;\n```\n\nUploaded images will be saved in the provided path and will be persisted in the store as public path, e.g. `/uploads/3e192ca4fa8ec546cdb6ef6e2ab55b00.jpg`.\n\n### Image sizes\n\nImage sizes are listed in the `resize` param of the attribute schema and you can add as many size definitions as you want. There are two notations for the image sizes:\n\n*   __Crop:__ `cXXX`, e.g. `c100` which will generate thumbs 100x100px centered in the middle of the original image\n*   __Resize:__ `sXXXxYYY`, e.g. `s600x600` which will generate image with either size up to 600px wide or high\n\nAll additional sizes are saved using image basename followed with `_{size}.ext`, e.g. `3e192ca4fa8ec546cdb6ef6e2ab55b00_c100.jpg` or `3e192ca4fa8ec546cdb6ef6e2ab55b00_s600x600.jpg`.\n\nImage resizer required [Imagemagick](http://www.imagemagick.org/script/index.php) to be installed on your host.\n\n## Validators\n\nPrometheus does validation by data type as long as you use `type` property in schema item description. But if attribute's value requires more specific validation, you can add a `validate` property to schema item. For example, if you want to know if value is a number Pi (to a certain proximity), you can add a validator:\n\n```javascript\nschema: {\n    pi: {\n        name: 'Pi',\n        default: null,\n        type: ModelFactory.types.NUMBER,\n        validate: function(val) {\n            return val / Math.PI > 0.999;\n        }\n    }\n}\n```\n\n## Object Pool\n\nIn order to helm minimize memory usage by reusing model instances, Prometheus (somewhat) implements [Object Pool Pattern](http://en.wikipedia.org/wiki/Object_pool_pattern), [reusable Obj class](https://gist.github.com/wthit56/5890898). `model_factory.js` has a hash with arrays of model instances by model name. In order to take advantage of OPP, all you have to do is use your model constructor without `new` keyword (e.g. `model = DeviceModel({ id: id }, { req: req });`), and releasing model back to the pool by calling `model.release()` when you don't plan to use this model any more (e.g. after ending request with `res.send()`). Calling `model.release()` marks it as available and resets all initial attributes and event listeners for this model. Next time you attempt to create a model without `new`, `ModelConstructor` will try to find an available model instance of this type, initialize it again and return, or create new one and add to the pool if there are no free instances.\n\n### Cleanup of unused model instances\n\nBy default pool of model instances is never clean up. You can initiate cleaning up unused models by calling `reusable.cleanup()` as in the following code:\n\n```javascript\nvar prometheus   = require('prometheus'),\n    reusable     = prometheus.reusable,\n    ModelFactory = prometheus.factory;\n\nreusable.cleanup(ModelFactory, 30000); // where last param is interval delay in ms\n```\n\nAt any time you can stop cleanup of models by running `reusable.stop()`.\n\n## Schema properties\n\n### Required\n\n*   `name` \u2014 {String} Friendly name for this attribute, e.g. \"UserModel\"\n*   `default` \u2014 {Mixed} Default attribute value, e.g. `null`, `\"changeme\"`, etc.\n*   `type` \u2014 {String} Data type from list of constants in ModelFactory.types\n\n### Optional\n\n*   `validate` \u2014 {Function} that validates attribute value (see above)\n*   `permitted` \u2014 {Array} Permitted values\n*   `content_type` \u2014 {String} Comma separated mime types, default `text/plain`\n*   `resize` \u2014 {Array} Desired image sizes (see above)\n*   `maxlength` \u2014 {Number} Number if string has a maximum length\n*   `maketag` \u2014 {Function} that returns a custom HTML tag for this field\n*   `readonly` \u2014 {Boolean} True if user is not allowed to change value\n*   `sync` \u2014 {Boolean} False if should not be synced with store\n*   `index` \u2014 {String} Type of index, e.g. UNIQUE, FULLTEXT etc.\n*   `required` \u2014 {Boolean} true if value can not be empty, null or default\n\n## Permissions\n\nPrometheus has model level permissions management. Defining permissions is optional. If permission rules are not defined, all permissions are set to `true`.\n\n### Defining permissions\n\nYou can define permissions for models by adding `permissions` and `roles` properties to `model_options` of a model, as in the example below. `permissions` is a hash with key-value pairs, where keys are CRUD operations and values are arrays with user roles, able to perform corresponding operations:\n\n```javascript\npermissions: {\n    'create'   : ['admin'],\n    'read'     : ['admin', 'user', 'guest'],\n    'update'   : ['admin', 'user'],\n    'destroy'  : ['admin'],\n    'transfer' : ['admin']\n}\n```\n\nTwo built-in roles are `app` and `guest`: if you do no pass `req` to the model constructor in the options, we assume that this model is not created within a function handling a route, so it's created elsewhere by the application. At the other hand, if `req` was passed with options, we assume that model is created as a result of HTTP(S) request by a user, who by default is a guest.\n\n`roles` is a hash of functions which return promises resolved with boolean result of permission checks:\n\n```javascript\nroles: {\n    user: function (model, req) {\n        var def = deferred(),\n            pass = !!(req && req.session.user);\n\n        def.resolve({ user: pass });\n        return def.promise;\n    },\n\n    admin: function (model, req) {\n        var def = deferred(),\n            pass = !!(req && req.session.user && req.session.user.roles.indexOf('admin') !== -1);\n\n        def.resolve({ admin: pass });\n        return def.promise;\n    }\n}\n```\n\nAbove example adds custom user role checks for `user` and `admin`, where user is anyone with user hash inside `req.session` and `admin` is a user whose roles hash contains \"admin\".\n\nPlease note that all of these functions return a promise \u2014 this is important because in Prometheus' internals we use `deferred.map()` to check all permissions. We did this on purpose because some permission checkers may be asyncronous.\n\n### Handling 403 Forbidden situations\n\nIf you are using any method on the model that involves CRUD operations, and user's permissions are insufficient to do a certain operation on the model, an error event will fire on the model, which you can handle by subscribing to it where you instantiate the model:\n\n```javascript\nvar model = new UserModel({ email: 'farennikov@gmail.com' }, { req: req });\n\nmodel.on('error', function(err) {\n    res.send(403, err.toString());\n});\n\nmodel.ready(function(model) {\n    model.set('foo', 'bar');\n    model.save();\n});\n```\n\nAbove example will send client \"403 Forbidden\" headers if session user does not have update rights.\n\n## Changelog\n\n### v.0.1.5\n\n*   Fixed an issue with EventEmitter being a part of model prototype instead of model instance which caused firing events on all models of the same type\n*   Implemented Object Pool Pattern\n*   Implemented clean up of unused model instances at a set interval\n\n### v.0.1.4\n\n*   Added typecasting to values parsed by `parseForm`\n*   Added optional `required` attribute to schema\n*   Added check for `required` attribute, `PRIMARY` and `UNIQUE` indexes in model validator\n*   Misc. bug fixes\n\n### v.0.1.3\n\n*   Added ability to create and remove indexes on the store's collections\n*   Removed `unique` param from schema; use `index: ModelFactory.indexes.UNIQUE` instead\n\n### v.0.1.2\n\n*   Refactored evt_handlers.js\n*   Fixed examples\n\n### v.0.1.1\n\n*   Moved some event handlers in model_factory.js initializer to separate dependencies\n*   Changed `model.find()` attributes to accept only `query` and `options`\n*   Removed `multiline` param from schema descriptions; use `datatypes.TEXT` instead\n\n### v.0.1.0\n\n*   Instantiating model arguments changed to `query` and `[options]`\n*   Model constructor does not return promise any more; it returns self (model)\n*   If model is not found with a query, `model.ready` is resolved with `this`, not `null` as in previous versions. This allows you not to have to instantiate a new blank model, but instead reuse existing model instance\n*   Added model-level permissions\n\n### v.0.0.3\n\n*   Added setters and getters for model attributes\n*   Removed built-in validators\n*   Added implicit check for changes in model attributes before update\n*   Refactored `destroy()` method\n\n### v.0.0.2\n\n*   Refactored image uploader\n*   Added image resizer. Note that image resizer needs __imagemagick__ to be installed.", "readmeFilename": "README.md", "_id": "prometheus@0.1.5", "dist": {"shasum": "828b7dafa47e0ef5ba4ff1455e669301c3198ac7", "tarball": "https://registry.npmjs.org/prometheus/-/prometheus-0.1.5.tgz", "integrity": "sha512-HxRnPn1wmlTzJxI0rPFNZ/RxZUhSaiE+tqJxa0WuGZ4ebaaoMMoevtYJRK5ocgEPJdd0uq/i3W4T2GoLMtAesw==", "signatures": [{"keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA", "sig": "MEUCIFwIuO0PRUTnDPBsywikD0fwnZ30Wq5BW8+7TaCWEU6IAiEAkvpQGJSSfbcs25FSG2kHEyNNfX4qii1YR0cO8mBKOAw="}]}, "_from": ".", "_npmVersion": "1.2.27", "_npmUser": {"name": "shubik", "email": "farennikov@gmail.com"}, "maintainers": [{"name": "shubik", "email": "farennikov@gmail.com"}], "directories": {}}, "0.1.6": {"version": "0.1.6", "author": {"name": "Alexander Farennikov", "email": "farennikov@gmail.com"}, "name": "prometheus", "description": "Simple ODM for Node.js with pluggable adapters", "keywords": ["ODM", "object document mapping", "prometheus", "adapter", "mongodb"], "homepage": "https://github.com/shubik/prometheus", "license": "MIT", "contributors": [], "repository": {"type": "git", "url": "https://github.com/shubik/prometheus"}, "bugs": {"url": "https://github.com/shubik/prometheus/issues"}, "main": "./lib/index.js", "scripts": {}, "engines": {"node": ">= 0.4.0"}, "dependencies": {"underscore": "~1.4.4", "deferred": "~0.6.1", "mongodb": "~1.2.14", "MD5": "~1.0.3"}, "devDependencies": {}, "readme": "Prometheus\n==========\n\nPrometheus is a simple ODM for Node.js with adapter for MongoDB (so far) and built-in __form builder__, __form parser__, and __table builder__. Form parser has __uploads handler__ with __image resizer.__\n\nBecause of async nature of database calls, Prometheus' model constructor has an internal promise (we use [Deferred](https://github.com/medikoo/deferred) library), which is exposed via attribute `ready`. This promise resolves with model once model is initialized (e.g. a blank model, `var user = new UserModel({})`), or loaded from database (e.g. if you provide a query, `var user = new UserModel({ id: 123 })`). If you're trying to load with a query a model that does not exist, you can know if by checking `model.get() === null` or `model.toJSON() === null`.\n\n## Installation\n\n### NPM\n\nIn your project path:\n\n```javascript\n$ npm install prometheus\n```\n\n## Defining models:\n\nYou define model by passing model-specific options to ModelFactory, which returns a model constructor.\n\n### Required params\n\n*   `name` \u2014 Friendly name of your model, e.g. `UserModel`\n*   `schema` \u2014 Description of model attributes\n\n### Optional params\n\n*   `mixins` \u2014 An array with mixins that will be applied to constructor's prototype\n*   `prototype_methods` \u2014 Model-specific methods that will be added to constructor's prototype\n*   `static_methods` \u2014 Model-specific static methods that will be added to constructor\n*   `hooks` \u2014 Model-specific hooks (callbacks) that will be called during model lifecycle, e.g. `afterInitialize`, `beforeSave` etc.\n*   `permissions` \u2014 Object with a list of CRUDT permissions\n*   `roles` \u2014 Object with functions which check permissions per each role listed in `permissions`\n\n## Defining a model example\n\n```javascript\nvar prometheus    = require('prometheus'),\n    ModelFactory  = prometheus.factory,\n    MongodbStore  = prometheus.stores.mongodb,\n    MD5           = prometheus.MD5,\n    UserModel,\n    model_options;\n\nmodel_options = {\n\n    name: 'ExampleModel',\n\n    store: new MongodbStore({\n        collection: 'example'\n    }),\n\n    schema: {\n        name: {\n            name: 'Name',\n            default: '',\n            type: ModelFactory.types.STRING\n        },\n        email: {\n            name: 'Email',\n            default: '',\n            type: ModelFactory.types.STRING,\n            validate: Validators.isEmail,\n            index: ModelFactory.indexes.UNIQUE\n        },\n        password: {\n            name: 'Password',\n            default: '',\n            type: ModelFactory.types.STRING,\n            hidden: true\n        }\n    },\n\n    mixins: [],\n\n    prototype_methods: {},\n\n    static_methods: {\n        login: function(req, options) {\n            // your login logic\n        },\n\n        logout: function(req) {\n            // your logout logic\n        }\n    },\n\n    hooks: {\n        beforeSave: function() {\n            var password = this.get('password');\n\n            if (password.length !== 32) {\n                this.set('password', MD5(password));\n            }\n\n            this.set('updated_at', utils.now());\n        }\n    }\n}\n\nUserModel = module.exports = ModelFactory(model_options);\n```\n\n## Instantiating models\n\nBlank model is instantiated by calling a model constructor with a blank query as first argument:\n\n```javascript\nvar user = new UserModel({}, { req: req });\n\nuser.ready(function(model) {\n    model.set({\n        name: 'Shubik',\n        email: 'farennikov@gmail.com',\n        password: 'password'\n    });\n\n    model.save()(function(model) {\n        // model successfully saved\n    }, function(err) {\n        // handle error\n    });\n}, function(err) {\n    // handle error\n});\n```\n\nExisting model is instantiated with a query as first argument:\n\n```javascript\nvar user = new UserModel({ email: 'farennikov@gmail.com' }, { req: req });\n\nuser.ready(function(model) {\n    if (model.toJSON() === null) {\n        // model with this email not found - save new\n        model.set({ email: 'farennikov@gmail.com' });\n    } else {\n        var new_name = model.get('name') + ' updated';\n        model.set('name', new_name);\n    }\n    model.save();\n}, function(err) {\n    // handle error\n});\n```\n\nNote that if model with such id is not found, promise will resolve with `null`.\n\n## Model API\n\n__Instance methods__\n\n### model.get()\n\n`get(attr)` retrieves an attribute of the model, or an entire model if attribute name is not provided.\n\n### model.set()\n\n`set(attr, [value])` sssigns new value to an attribute or a number of attributes of the model. If given only 1 param which is an Object, method will use keys of the object as attributes.\n\n### model.save()\n\n`save()` saves a new model or model that has been changed by `set()`. Returns a promise which is resolved with model if model was successfully saved or error if saving model failed. If model was initialized without an id, new model will be attempted to be created.\n\n### model.destroy()\n\n`destroy()` deletes model from a store. Returns a promise which is resolved with this model once model is deleted from database.\n\n### model.toJSON()\n\n`toJSON()` returns all attributes of the model (key-value pairs).\n\n### model.validate()\n\n`validate()` validates model attributes according to the model's schema. Returns true or false.\n\n### model.toForm()\n\n`toForm()` returns an object that can be used to create HTML form for this model.\n\n### model.parseForm()\n\n`parseForm(req)` populates a model by values from a request.\n\n### model.toTable()\n\n`toTable()` returns an object that can be used to show this model in table form.\n\nYou can add model-specific instance methods by adding them to `prototype_methods` param of the options you pass to `ModelFactory`.\n\n__Static methods__\n\nModel constructors can have static methods which you can use without instantiating a model. By default there are two static methods: `find()` and `count()`:\n\n### SomeModel.find()\n\n`find(query, offset, limit, sort)` returns a promise which is resolved with an array of models found in database using provided arguments. Example:\n\n```javascript\nUserModel.find({ name: 'Shubik' })(function(results) {\n    // do somethig with `results`\n});\n```\n\n### SomeModel.count()\n\n`count()` returns a promise which is resolved with number of all models in the database. Example:\n\n```javascript\nUserModel.count()(function(num) {\n    // do somethig with `num`\n});\n```\n\nYou can add more model-specific static methods to `static_methods` param of the options you pass to `ModelFactory`.\n\n## Form builder\n\nEach model has built-in method `model.toForm()` which returns an object that you can use to render forms. Below is an example route that uses `toForm()` method to display form for adding a new company:\n\n```javascript\nadd: function(req, res) {\n    var company = new CompanyModel({}, { req: req });\n\n    company.ready(function(model) {\n\n        model.set('auth_token', MD5(_.random(1000000, 9999999) + config.auth.salt));\n\n        var model_form = model.toForm({\n            url         : '/rest/company',\n            method      : 'POST',\n            show_hidden : true\n        });\n\n        res.render('admin/company_add', {\n            title      : 'Add company',\n            model_form : model_form\n        });\n\n    }, function(err) {\n        res.send(400, err.toString());\n    });\n}\n```\n\nActual form is rendered using a Jade mixin and Twitter Bootstrap, as follows:\n\n```jade\nmixin form_builder(formdata)\n  form.form-horizontal.themed(id=\"#{formdata.tag.id}\", name=\"#{formdata.tag.name}\", method=\"#{formdata.tag.method}\", action=\"#{formdata.tag.action}\", enctype=\"#{formdata.tag.enctype}\")\n    fieldset\n      for field in formdata.fields\n        .control-group\n          label.control-label #{field.label}\n          .controls\n            for inp in field.inputs\n\n              if field.type == 'text'\n                !{inp}\n\n              if field.type == 'textarea'\n                !{inp}\n\n              if field.type == 'select'\n                !{inp}\n\n              if field.type == 'checkbox'\n                label.checkbox\n                  !{inp}\n\n              if field.type == 'radio'\n                label.radio\n                  !{inp}\n\n              if field.type == 'other'\n                !{inp}\n\n      .form-actions\n        button.btn.medium.btn-primary(type=\"submit\") Save\n```\n\nAnd this mixin is called from respective view as follows:\n\n```jade\n+form_builder(model_form)\n```\n\n## Form parser\n\nEach model has built-in method `model.parseForm()` which returns an object that you can use to render forms. Below is an example route that uses `parseForm()` method to add a new company:\n\n```javascript\ncreate: function(req, res) {\n    var params  = _.extend(req.params || {}, req.query || {}, req.body || {}),\n        company = new CompanyModel({}, { req: req });\n\n    company.ready(function(model) {\n        model.parseForm(req)(function(model) {\n            model.save()(function(model) {\n                res.json(200, model.toJSON());\n            }, function(err) {\n                res.send(400, err.toString());\n            });\n        }, function(err) {\n            res.send(400, err.toString());\n        });\n    });\n}\n```\n\n### Using image resizer\n\nYou can optionally resize your image uploads by adding `resize` property to schema attribute, such as in this example:\n\n```javascript\nschema: {\n    logo: {\n        name: 'Company Logo',\n        default: null,\n        type: ModelFactory.types.STRING,\n        content_type: 'image/jpeg, image/png, image/gif',\n        resize: ['c100', 's600x600', 's1200x1200']\n    }\n}\n```\n\nPlease note, that uploads are saved in store as their public URLs, not as a binary. Therefore in order to save uploads, your model definition needs to have `uploads` attribute, which is an object with two params: `path` and `path_public`, where `path` is path to upload folder on the server, and `path_public` is a path to the upload relative to your domain, e.g.:\n\n```javascript\nuploads: {\n    path: '/home/ubuntu/myproject/node/public/uploads/',\n    path_public: '/uploads/'\n}\n```\n\nYou can generate `path` in your app.js as follows:\n\n```javascript\nvar uploads = {\n    path_public: '/uploads/'\n};\nuploads.path = __dirname + '/public' + config.uploads.path_public;\n```\n\nUploaded images will be saved in the provided path and will be persisted in the store as public path, e.g. `/uploads/3e192ca4fa8ec546cdb6ef6e2ab55b00.jpg`.\n\n### Image sizes\n\nImage sizes are listed in the `resize` param of the attribute schema and you can add as many size definitions as you want. There are two notations for the image sizes:\n\n*   __Crop:__ `cXXX`, e.g. `c100` which will generate thumbs 100x100px centered in the middle of the original image\n*   __Resize:__ `sXXXxYYY`, e.g. `s600x600` which will generate image with either size up to 600px wide or high\n\nAll additional sizes are saved using image basename followed with `_{size}.ext`, e.g. `3e192ca4fa8ec546cdb6ef6e2ab55b00_c100.jpg` or `3e192ca4fa8ec546cdb6ef6e2ab55b00_s600x600.jpg`.\n\nImage resizer required [Imagemagick](http://www.imagemagick.org/script/index.php) to be installed on your host.\n\n## Validators\n\nPrometheus does validation by data type as long as you use `type` property in schema item description. But if attribute's value requires more specific validation, you can add a `validate` property to schema item. For example, if you want to know if value is a number Pi (to a certain proximity), you can add a validator:\n\n```javascript\nschema: {\n    pi: {\n        name: 'Pi',\n        default: null,\n        type: ModelFactory.types.NUMBER,\n        validate: function(val) {\n            return val / Math.PI > 0.999;\n        }\n    }\n}\n```\n\n## Object Pool\n\nIn order to helm minimize memory usage by reusing model instances, Prometheus (somewhat) implements [Object Pool Pattern](http://en.wikipedia.org/wiki/Object_pool_pattern), [reusable Obj class](https://gist.github.com/wthit56/5890898). `model_factory.js` has a hash with arrays of model instances by model name. In order to take advantage of OPP, all you have to do is use your model constructor without `new` keyword (e.g. `model = DeviceModel({ id: id }, { req: req });`), and releasing model back to the pool by calling `model.release()` when you don't plan to use this model any more (e.g. after ending request with `res.send()`). Calling `model.release()` marks it as available and resets all initial attributes and event listeners for this model. Next time you attempt to create a model without `new`, `ModelConstructor` will try to find an available model instance of this type, initialize it again and return, or create new one and add to the pool if there are no free instances.\n\n### Cleanup of unused model instances\n\nBy default pool of model instances is never clean up. You can initiate cleaning up unused models by calling `reusable.cleanup()` as in the following code:\n\n```javascript\nvar prometheus   = require('prometheus'),\n    reusable     = prometheus.reusable,\n    ModelFactory = prometheus.factory;\n\nreusable.cleanup(ModelFactory, 30000); // where last param is interval delay in ms\n```\n\nAt any time you can stop cleanup of models by running `reusable.stop()`.\n\n## Schema properties\n\n### Required\n\n*   `name` \u2014 {String} Friendly name for this attribute, e.g. \"UserModel\"\n*   `default` \u2014 {Mixed} Default attribute value, e.g. `null`, `\"changeme\"`, etc.\n*   `type` \u2014 {String} Data type from list of constants in ModelFactory.types\n\n### Optional\n\n*   `validate` \u2014 {Function} that validates attribute value (see above)\n*   `permitted` \u2014 {Array} Permitted values\n*   `content_type` \u2014 {String} Comma separated mime types, default `text/plain`\n*   `resize` \u2014 {Array} Desired image sizes (see above)\n*   `maxlength` \u2014 {Number} Number if string has a maximum length\n*   `maketag` \u2014 {Function} that returns a custom HTML tag for this field\n*   `readonly` \u2014 {Boolean} True if user is not allowed to change value\n*   `sync` \u2014 {Boolean} False if should not be synced with store\n*   `index` \u2014 {String} Type of index, e.g. UNIQUE, FULLTEXT etc.\n*   `required` \u2014 {Boolean} true if value can not be empty, null or default\n\n## Permissions\n\nPrometheus has model level permissions management. Defining permissions is optional. If permission rules are not defined, all permissions are set to `true`.\n\n### Defining permissions\n\nYou can define permissions for models by adding `permissions` and `roles` properties to `model_options` of a model, as in the example below. `permissions` is a hash with key-value pairs, where keys are CRUD operations and values are arrays with user roles, able to perform corresponding operations:\n\n```javascript\npermissions: {\n    'create'   : ['admin'],\n    'read'     : ['admin', 'user', 'guest'],\n    'update'   : ['admin', 'user'],\n    'destroy'  : ['admin'],\n    'transfer' : ['admin']\n}\n```\n\nTwo built-in roles are `app` and `guest`: if you do no pass `req` to the model constructor in the options, we assume that this model is not created within a function handling a route, so it's created elsewhere by the application. At the other hand, if `req` was passed with options, we assume that model is created as a result of HTTP(S) request by a user, who by default is a guest.\n\n`roles` is a hash of functions which return promises resolved with boolean result of permission checks:\n\n```javascript\nroles: {\n    user: function (model, req) {\n        var def = deferred(),\n            pass = !!(req && req.session.user);\n\n        def.resolve({ user: pass });\n        return def.promise;\n    },\n\n    admin: function (model, req) {\n        var def = deferred(),\n            pass = !!(req && req.session.user && req.session.user.roles.indexOf('admin') !== -1);\n\n        def.resolve({ admin: pass });\n        return def.promise;\n    }\n}\n```\n\nAbove example adds custom user role checks for `user` and `admin`, where user is anyone with user hash inside `req.session` and `admin` is a user whose roles hash contains \"admin\".\n\nPlease note that all of these functions return a promise \u2014 this is important because in Prometheus' internals we use `deferred.map()` to check all permissions. We did this on purpose because some permission checkers may be asyncronous.\n\n### Handling 403 Forbidden situations\n\nIf you are using any method on the model that involves CRUD operations, and user's permissions are insufficient to do a certain operation on the model, an error event will fire on the model, which you can handle by subscribing to it where you instantiate the model:\n\n```javascript\nvar model = new UserModel({ email: 'farennikov@gmail.com' }, { req: req });\n\nmodel.on('error', function(err) {\n    res.send(403, err.toString());\n});\n\nmodel.ready(function(model) {\n    model.set('foo', 'bar');\n    model.save();\n});\n```\n\nAbove example will send client \"403 Forbidden\" headers if session user does not have update rights.\n\n## Changelog\n\n### v.0.1.6\n\n*   Implemented clean up of unused model instances at a set interval\n*   Added `PASSWORD` data type. For this type, `toForm()` generates `<input type=\"password\">` tag. This type validates as `STRING`.\n*   Fixed MongoDB store `find()` bug that prevented from using queries. Now JSON string queries are parsed to objects.\n\n### v.0.1.5\n\n*   Fixed an issue with EventEmitter being a part of model prototype instead of model instance which caused firing events on all models of the same type\n*   Implemented Object Pool Pattern\n\n### v.0.1.4\n\n*   Added typecasting to values parsed by `parseForm`\n*   Added optional `required` attribute to schema\n*   Added check for `required` attribute, `PRIMARY` and `UNIQUE` indexes in model validator\n*   Misc. bug fixes\n\n### v.0.1.3\n\n*   Added ability to create and remove indexes on the store's collections\n*   Removed `unique` param from schema; use `index: ModelFactory.indexes.UNIQUE` instead\n\n### v.0.1.2\n\n*   Refactored evt_handlers.js\n*   Fixed examples\n\n### v.0.1.1\n\n*   Moved some event handlers in model_factory.js initializer to separate dependencies\n*   Changed `model.find()` attributes to accept only `query` and `options`\n*   Removed `multiline` param from schema descriptions; use `datatypes.TEXT` instead\n\n### v.0.1.0\n\n*   Instantiating model arguments changed to `query` and `[options]`\n*   Model constructor does not return promise any more; it returns self (model)\n*   If model is not found with a query, `model.ready` is resolved with `this`, not `null` as in previous versions. This allows you not to have to instantiate a new blank model, but instead reuse existing model instance\n*   Added model-level permissions\n\n### v.0.0.3\n\n*   Added setters and getters for model attributes\n*   Removed built-in validators\n*   Added implicit check for changes in model attributes before update\n*   Refactored `destroy()` method\n\n### v.0.0.2\n\n*   Refactored image uploader\n*   Added image resizer. Note that image resizer needs __imagemagick__ to be installed.", "readmeFilename": "README.md", "_id": "prometheus@0.1.6", "dist": {"shasum": "4df8c24cb8c2c82388cac0e896bd70d9cf9c652c", "tarball": "https://registry.npmjs.org/prometheus/-/prometheus-0.1.6.tgz", "integrity": "sha512-s7+xfYZHd+qsumcNOd9KrluyJojW5ySntAeqi65+D5TQBgayb3GkW/cxChB6Q7VcrixSc80A/7KGf/uMZhoj0A==", "signatures": [{"keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA", "sig": "MEYCIQD9OPoxKuIVjrcK/54+orlf3+XoN3tdV/UPZ/bmwuRLtwIhAJ7WWzhCBvYM/bfUjmsauP9hpDQsFP3avKapuyhwaLoe"}]}, "_from": ".", "_npmVersion": "1.2.18", "_npmUser": {"name": "shubik", "email": "farennikov@gmail.com"}, "maintainers": [{"name": "shubik", "email": "farennikov@gmail.com"}], "directories": {}}, "0.1.7": {"version": "0.1.7", "author": {"name": "Alexander Farennikov", "email": "farennikov@gmail.com"}, "name": "prometheus", "description": "Simple ODM for Node.js with pluggable adapters", "keywords": ["ODM", "object document mapping", "prometheus", "adapter", "mongodb"], "homepage": "https://github.com/shubik/prometheus", "license": "MIT", "contributors": [], "repository": {"type": "git", "url": "https://github.com/shubik/prometheus"}, "bugs": {"url": "https://github.com/shubik/prometheus/issues"}, "main": "./lib/index.js", "scripts": {}, "engines": {"node": ">= 0.4.0"}, "dependencies": {"underscore": "~1.4.4", "deferred": "~0.6.1", "mongodb": "~1.2.14", "MD5": "~1.0.3"}, "devDependencies": {}, "readme": "Prometheus\n==========\n\nPrometheus is a simple ODM for Node.js with adapter for MongoDB (so far) and built-in __form builder__, __form parser__, and __table builder__. Form parser has __uploads handler__ with __image resizer.__\n\nBecause of async nature of database calls, Prometheus' model constructor has an internal promise (we use [Deferred](https://github.com/medikoo/deferred) library), which is exposed via attribute `ready`. This promise resolves with model once model is initialized (e.g. a blank model, `var user = new UserModel({})`), or loaded from database (e.g. if you provide a query, `var user = new UserModel({ id: 123 })`). If you're trying to load with a query a model that does not exist, you can know if by checking `model.get() === null` or `model.toJSON() === null`.\n\n## Installation\n\n### NPM\n\nIn your project path:\n\n```javascript\n$ npm install prometheus\n```\n\n## Defining models:\n\nYou define model by passing model-specific options to ModelFactory, which returns a model constructor.\n\n### Required params\n\n*   `name` \u2014 Friendly name of your model, e.g. `UserModel`\n*   `schema` \u2014 Description of model attributes\n\n### Optional params\n\n*   `mixins` \u2014 An array with mixins that will be applied to constructor's prototype\n*   `prototype_methods` \u2014 Model-specific methods that will be added to constructor's prototype\n*   `static_methods` \u2014 Model-specific static methods that will be added to constructor\n*   `hooks` \u2014 Model-specific hooks (callbacks) that will be called during model lifecycle, e.g. `afterInitialize`, `beforeSave` etc.\n*   `permissions` \u2014 Object with a list of CRUDT permissions\n*   `roles` \u2014 Object with functions which check permissions per each role listed in `permissions`\n\n## Defining a model example\n\n```javascript\nvar prometheus    = require('prometheus'),\n    ModelFactory  = prometheus.factory,\n    MongodbStore  = prometheus.stores.mongodb,\n    MD5           = prometheus.MD5,\n    UserModel,\n    model_options;\n\nmodel_options = {\n\n    name: 'ExampleModel',\n\n    store: new MongodbStore({\n        collection: 'example'\n    }),\n\n    schema: {\n        name: {\n            name: 'Name',\n            default: '',\n            type: ModelFactory.types.STRING\n        },\n        email: {\n            name: 'Email',\n            default: '',\n            type: ModelFactory.types.STRING,\n            validate: Validators.isEmail,\n            index: ModelFactory.indexes.UNIQUE\n        },\n        password: {\n            name: 'Password',\n            default: '',\n            type: ModelFactory.types.STRING,\n            hidden: true\n        }\n    },\n\n    mixins: [],\n\n    prototype_methods: {},\n\n    static_methods: {\n        login: function(req, options) {\n            // your login logic\n        },\n\n        logout: function(req) {\n            // your logout logic\n        }\n    },\n\n    hooks: {\n        beforeSave: function() {\n            var password = this.get('password');\n\n            if (password.length !== 32) {\n                this.set('password', MD5(password));\n            }\n\n            this.set('updated_at', utils.now());\n        }\n    }\n}\n\nUserModel = module.exports = ModelFactory(model_options);\n```\n\n## Instantiating models\n\nBlank model is instantiated by calling a model constructor with a blank query as first argument:\n\n```javascript\nvar user = new UserModel({}, { req: req });\n\nuser.ready(function(model) {\n    model.set({\n        name: 'Shubik',\n        email: 'farennikov@gmail.com',\n        password: 'password'\n    });\n\n    model.save()(function(model) {\n        // model successfully saved\n    }, function(err) {\n        // handle error\n    });\n}, function(err) {\n    // handle error\n});\n```\n\nExisting model is instantiated with a query as first argument:\n\n```javascript\nvar user = new UserModel({ email: 'farennikov@gmail.com' }, { req: req });\n\nuser.ready(function(model) {\n    if (model.toJSON() === null) {\n        // model with this email not found - save new\n        model.set({ email: 'farennikov@gmail.com' });\n    } else {\n        var new_name = model.get('name') + ' updated';\n        model.set('name', new_name);\n    }\n    model.save();\n}, function(err) {\n    // handle error\n});\n```\n\nNote that if model with such id is not found, promise will resolve with `null`.\n\n## Model API\n\n__Instance methods__\n\n### model.get()\n\n`get(attr)` retrieves an attribute of the model, or an entire model if attribute name is not provided.\n\n### model.set()\n\n`set(attr, [value])` sssigns new value to an attribute or a number of attributes of the model. If given only 1 param which is an Object, method will use keys of the object as attributes.\n\n### model.save()\n\n`save()` saves a new model or model that has been changed by `set()`. Returns a promise which is resolved with model if model was successfully saved or error if saving model failed. If model was initialized without an id, new model will be attempted to be created.\n\n### model.destroy()\n\n`destroy()` deletes model from a store. Returns a promise which is resolved with this model once model is deleted from database.\n\n### model.toJSON()\n\n`toJSON()` returns all attributes of the model (key-value pairs).\n\n### model.validate()\n\n`validate()` validates model attributes according to the model's schema. Returns true or false.\n\n### model.toForm()\n\n`toForm()` returns an object that can be used to create HTML form for this model.\n\n### model.parseForm()\n\n`parseForm(req)` populates a model by values from a request.\n\n### model.toTable()\n\n`toTable()` returns an object that can be used to show this model in table form.\n\nYou can add model-specific instance methods by adding them to `prototype_methods` param of the options you pass to `ModelFactory`.\n\n__Static methods__\n\nModel constructors can have static methods which you can use without instantiating a model. By default there are two static methods: `find()` and `count()`:\n\n### SomeModel.find()\n\n`find(query, offset, limit, sort)` returns a promise which is resolved with an array of models found in database using provided arguments. Example:\n\n```javascript\nUserModel.find({ name: 'Shubik' })(function(results) {\n    // do somethig with `results`\n});\n```\n\n### SomeModel.count()\n\n`count()` returns a promise which is resolved with number of all models in the database. Example:\n\n```javascript\nUserModel.count()(function(num) {\n    // do somethig with `num`\n});\n```\n\nYou can add more model-specific static methods to `static_methods` param of the options you pass to `ModelFactory`.\n\n## Form builder\n\nEach model has built-in method `model.toForm()` which returns an object that you can use to render forms. Below is an example route that uses `toForm()` method to display form for adding a new company:\n\n```javascript\nadd: function(req, res) {\n    var company = new CompanyModel({}, { req: req });\n\n    company.ready(function(model) {\n\n        model.set('auth_token', MD5(_.random(1000000, 9999999) + config.auth.salt));\n\n        var model_form = model.toForm({\n            url         : '/rest/company',\n            method      : 'POST',\n            show_hidden : true\n        });\n\n        res.render('admin/company_add', {\n            title      : 'Add company',\n            model_form : model_form\n        });\n\n    }, function(err) {\n        res.send(400, err.toString());\n    });\n}\n```\n\nActual form is rendered using a Jade mixin and Twitter Bootstrap, as follows:\n\n```jade\nmixin form_builder(formdata)\n  form.form-horizontal.themed(id=\"#{formdata.tag.id}\", name=\"#{formdata.tag.name}\", method=\"#{formdata.tag.method}\", action=\"#{formdata.tag.action}\", enctype=\"#{formdata.tag.enctype}\")\n    fieldset\n      for field in formdata.fields\n        .control-group\n          label.control-label #{field.label}\n          .controls\n            for inp in field.inputs\n\n              if field.type == 'text'\n                !{inp}\n\n              if field.type == 'textarea'\n                !{inp}\n\n              if field.type == 'select'\n                !{inp}\n\n              if field.type == 'checkbox'\n                label.checkbox\n                  !{inp}\n\n              if field.type == 'radio'\n                label.radio\n                  !{inp}\n\n              if field.type == 'other'\n                !{inp}\n\n      .form-actions\n        button.btn.medium.btn-primary(type=\"submit\") Save\n```\n\nAnd this mixin is called from respective view as follows:\n\n```jade\n+form_builder(model_form)\n```\n\n## Form parser\n\nEach model has built-in method `model.parseForm()` which returns an object that you can use to render forms. Below is an example route that uses `parseForm()` method to add a new company:\n\n```javascript\ncreate: function(req, res) {\n    var params  = _.extend(req.params || {}, req.query || {}, req.body || {}),\n        company = new CompanyModel({}, { req: req });\n\n    company.ready(function(model) {\n        model.parseForm(req)(function(model) {\n            model.save()(function(model) {\n                res.json(200, model.toJSON());\n            }, function(err) {\n                res.send(400, err.toString());\n            });\n        }, function(err) {\n            res.send(400, err.toString());\n        });\n    });\n}\n```\n\n### Using image resizer\n\nYou can optionally resize your image uploads by adding `resize` property to schema attribute, such as in this example:\n\n```javascript\nschema: {\n    logo: {\n        name: 'Company Logo',\n        default: null,\n        type: ModelFactory.types.STRING,\n        content_type: 'image/jpeg, image/png, image/gif',\n        resize: ['c100', 's600x600', 's1200x1200']\n    }\n}\n```\n\nPlease note, that uploads are saved in store as their public URLs, not as a binary. Therefore in order to save uploads, your model definition needs to have `uploads` attribute, which is an object with two params: `path` and `path_public`, where `path` is path to upload folder on the server, and `path_public` is a path to the upload relative to your domain, e.g.:\n\n```javascript\nuploads: {\n    path: '/home/ubuntu/myproject/node/public/uploads/',\n    path_public: '/uploads/'\n}\n```\n\nYou can generate `path` in your app.js as follows:\n\n```javascript\nvar uploads = {\n    path_public: '/uploads/'\n};\nuploads.path = __dirname + '/public' + config.uploads.path_public;\n```\n\nUploaded images will be saved in the provided path and will be persisted in the store as public path, e.g. `/uploads/3e192ca4fa8ec546cdb6ef6e2ab55b00.jpg`.\n\n### Image sizes\n\nImage sizes are listed in the `resize` param of the attribute schema and you can add as many size definitions as you want. There are two notations for the image sizes:\n\n*   __Crop:__ `cXXX`, e.g. `c100` which will generate thumbs 100x100px centered in the middle of the original image\n*   __Resize:__ `sXXXxYYY`, e.g. `s600x600` which will generate image with either size up to 600px wide or high\n\nAll additional sizes are saved using image basename followed with `_{size}.ext`, e.g. `3e192ca4fa8ec546cdb6ef6e2ab55b00_c100.jpg` or `3e192ca4fa8ec546cdb6ef6e2ab55b00_s600x600.jpg`.\n\nImage resizer required [Imagemagick](http://www.imagemagick.org/script/index.php) to be installed on your host.\n\n## Validators\n\nPrometheus does validation by data type as long as you use `type` property in schema item description. But if attribute's value requires more specific validation, you can add a `validate` property to schema item. For example, if you want to know if value is a number Pi (to a certain proximity), you can add a validator:\n\n```javascript\nschema: {\n    pi: {\n        name: 'Pi',\n        default: null,\n        type: ModelFactory.types.NUMBER,\n        validate: function(val) {\n            return val / Math.PI > 0.999;\n        }\n    }\n}\n```\n\n## Object Pool\n\nIn order to helm minimize memory usage by reusing model instances, Prometheus (somewhat) implements [Object Pool Pattern](http://en.wikipedia.org/wiki/Object_pool_pattern), [reusable Obj class](https://gist.github.com/wthit56/5890898). `model_factory.js` has a hash with arrays of model instances by model name. In order to take advantage of OPP, all you have to do is use your model constructor without `new` keyword (e.g. `model = DeviceModel({ id: id }, { req: req });`), and releasing model back to the pool by calling `model.release()` when you don't plan to use this model any more (e.g. after ending request with `res.send()`). Calling `model.release()` marks it as available and resets all initial attributes and event listeners for this model. Next time you attempt to create a model without `new`, `ModelConstructor` will try to find an available model instance of this type, initialize it again and return, or create new one and add to the pool if there are no free instances.\n\n### Cleanup of unused model instances\n\nBy default pool of model instances is never clean up. You can initiate cleaning up unused models by calling `reusable.cleanup()` as in the following code:\n\n```javascript\nvar prometheus   = require('prometheus'),\n    reusable     = prometheus.reusable,\n    ModelFactory = prometheus.factory;\n\nreusable.cleanup(ModelFactory, 30000); // where last param is interval delay in ms\n```\n\nAt any time you can stop cleanup of models by running `reusable.stop()`.\n\n## Schema properties\n\n### Required\n\n*   `name` \u2014 {String} Friendly name for this attribute, e.g. \"UserModel\"\n*   `default` \u2014 {Mixed} Default attribute value, e.g. `null`, `\"changeme\"`, etc.\n*   `type` \u2014 {String} Data type from list of constants in ModelFactory.types\n\n### Optional\n\n*   `validate` \u2014 {Function} that validates attribute value (see above)\n*   `permitted` \u2014 {Array} Permitted values\n*   `content_type` \u2014 {String} Comma separated mime types, default `text/plain`\n*   `resize` \u2014 {Array} Desired image sizes (see above)\n*   `maxlength` \u2014 {Number} Number if string has a maximum length\n*   `maketag` \u2014 {Function} that returns a custom HTML tag for this field\n*   `readonly` \u2014 {Boolean} True if user is not allowed to change value\n*   `sync` \u2014 {Boolean} False if should not be synced with store\n*   `index` \u2014 {String} Type of index, e.g. UNIQUE, FULLTEXT etc.\n*   `required` \u2014 {Boolean} true if value can not be empty, null or default\n\n## Permissions\n\nPrometheus has model level permissions management. Defining permissions is optional. If permission rules are not defined, all permissions are set to `true`.\n\n### Defining permissions\n\nYou can define permissions for models by adding `permissions` and `roles` properties to `model_options` of a model, as in the example below. `permissions` is a hash with key-value pairs, where keys are CRUD operations and values are arrays with user roles, able to perform corresponding operations:\n\n```javascript\npermissions: {\n    'create'   : ['admin'],\n    'read'     : ['admin', 'user', 'guest'],\n    'update'   : ['admin', 'user'],\n    'destroy'  : ['admin'],\n    'transfer' : ['admin']\n}\n```\n\nTwo built-in roles are `app` and `guest`: if you do no pass `req` to the model constructor in the options, we assume that this model is not created within a function handling a route, so it's created elsewhere by the application. At the other hand, if `req` was passed with options, we assume that model is created as a result of HTTP(S) request by a user, who by default is a guest.\n\n`roles` is a hash of functions which return promises resolved with boolean result of permission checks:\n\n```javascript\nroles: {\n    user: function (model, req) {\n        var def = deferred(),\n            pass = !!(req && req.session.user);\n\n        def.resolve({ user: pass });\n        return def.promise;\n    },\n\n    admin: function (model, req) {\n        var def = deferred(),\n            pass = !!(req && req.session.user && req.session.user.roles.indexOf('admin') !== -1);\n\n        def.resolve({ admin: pass });\n        return def.promise;\n    }\n}\n```\n\nAbove example adds custom user role checks for `user` and `admin`, where user is anyone with user hash inside `req.session` and `admin` is a user whose roles hash contains \"admin\".\n\nPlease note that all of these functions return a promise \u2014 this is important because in Prometheus' internals we use `deferred.map()` to check all permissions. We did this on purpose because some permission checkers may be asyncronous.\n\n### Handling 403 Forbidden situations\n\nIf you are using any method on the model that involves CRUD operations, and user's permissions are insufficient to do a certain operation on the model, an error event will fire on the model, which you can handle by subscribing to it where you instantiate the model:\n\n```javascript\nvar model = new UserModel({ email: 'farennikov@gmail.com' }, { req: req });\n\nmodel.on('error', function(err) {\n    res.send(403, err.toString());\n});\n\nmodel.ready(function(model) {\n    model.set('foo', 'bar');\n    model.save();\n});\n```\n\nAbove example will send client \"403 Forbidden\" headers if session user does not have update rights.\n\n## Changelog\n\n### v.0.1.7\n\n*   Changed checking permissions during CRUD ops from event-based to synchronous\n*   (this is bad but) Formbuilder has been altered to add Bootstrap 3 classes to form elements\n\n### v.0.1.6\n\n*   Implemented clean up of unused model instances at a set interval\n*   Added `PASSWORD` data type. For this type, `toForm()` generates `<input type=\"password\">` tag. This type validates as `STRING`.\n*   Fixed MongoDB store `find()` bug that prevented from using queries. Now JSON string queries are parsed to objects.\n\n### v.0.1.5\n\n*   Fixed an issue with EventEmitter being a part of model prototype instead of model instance which caused firing events on all models of the same type\n*   Implemented Object Pool Pattern\n\n### v.0.1.4\n\n*   Added typecasting to values parsed by `parseForm`\n*   Added optional `required` attribute to schema\n*   Added check for `required` attribute, `PRIMARY` and `UNIQUE` indexes in model validator\n*   Misc. bug fixes\n\n### v.0.1.3\n\n*   Added ability to create and remove indexes on the store's collections\n*   Removed `unique` param from schema; use `index: ModelFactory.indexes.UNIQUE` instead\n\n### v.0.1.2\n\n*   Refactored evt_handlers.js\n*   Fixed examples\n\n### v.0.1.1\n\n*   Moved some event handlers in model_factory.js initializer to separate dependencies\n*   Changed `model.find()` attributes to accept only `query` and `options`\n*   Removed `multiline` param from schema descriptions; use `datatypes.TEXT` instead\n\n### v.0.1.0\n\n*   Instantiating model arguments changed to `query` and `[options]`\n*   Model constructor does not return promise any more; it returns self (model)\n*   If model is not found with a query, `model.ready` is resolved with `this`, not `null` as in previous versions. This allows you not to have to instantiate a new blank model, but instead reuse existing model instance\n*   Added model-level permissions\n\n### v.0.0.3\n\n*   Added setters and getters for model attributes\n*   Removed built-in validators\n*   Added implicit check for changes in model attributes before update\n*   Refactored `destroy()` method\n\n### v.0.0.2\n\n*   Refactored image uploader\n*   Added image resizer. Note that image resizer needs __imagemagick__ to be installed.", "readmeFilename": "README.md", "_id": "prometheus@0.1.7", "dist": {"shasum": "b95892471e6ca839b3756e892e62d3e22a0d1727", "tarball": "https://registry.npmjs.org/prometheus/-/prometheus-0.1.7.tgz", "integrity": "sha512-OCIMCHanvxIDZovC85I31MVbFwP72MovJExpzqBx79wdqsVGjPbTCLp3ahWADqYdv2IXFAJbqiaKnvYnbc1eQg==", "signatures": [{"keyid": "SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA", "sig": "MEUCIQD94YQGSj6DNe85TSqSpOuwPp5J4lEzN45NAH+So1IePwIgBV0rgtMAYJG8Ynh2jP2eWHmTiqANQtdtHzdrGFVwcrU="}]}, "_from": ".", "_npmVersion": "1.3.14", "_npmUser": {"name": "shubik", "email": "farennikov@gmail.com"}, "maintainers": [{"name": "shubik", "email": "farennikov@gmail.com"}], "directories": {}}}, "readme": "Prometheus\n==========\n\nPrometheus is a simple ORM for Node.js with adapter for MongoDB.\n\nBecause of async nature of database calls, Prometheus' model constructor always returns a promise (we prefer [Deferred](https://github.com/medikoo/deferred) library), not a model. This promise resolves with model once it is created (e.g. for a blank model, `var user = new UserModel()`), or once it is loaded from database (e.g. if you provide model id, `var user = new UserModel(123)`) or `null` if model was not found.\n\n## Defining models:\n\nYou define model by passing model-specific options to ModelFactory, which returns a model constructor.\n\n### Required params\n\n*   `name` \u2014 Name of your model, e.g. `UserModel`\n*   `schema` \u2014 Description of model attributes\n\n### Optional params\n\n*   `mixins` \u2014 An array with mixins that will be applied to constructor's prototype\n*   `prototype_methods` \u2014 Model-specific methods that will be added to constructor's prototype\n*   `static_methods` \u2014 Model-specific static methods that will be added to constructor\n*   `hooks` \u2014 Model-specific hooks (callbacks) that will be called during model lifecycle, e.g. `afterInitialize`, `beforeSave` etc.\n\n## Defining a model\n\n```javascript\nvar prometheus    = require('prometheus'),\n    ModelFactory  = prometheus.factory,\n    MongodbStore  = prometheus.stores.mongodb,\n    Validators    = prometheus.validators,\n    MD5           = prometheus.MD5,\n    UserModel,\n    model_options;\n\nmodel_options = {\n\n    name: 'ExampleModel',\n\n    store: new MongodbStore({\n        collection: 'example'\n    }),\n\n    schema: {\n        name: {\n            name: 'Name',\n            default: '',\n            type: ModelFactory.types.STRING\n        },\n        email: {\n            name: 'Email',\n            default: '',\n            type: ModelFactory.types.STRING,\n            validate: Validators.isEmail,\n            unique: true\n        },\n        password: {\n            name: 'Password',\n            default: '',\n            type: ModelFactory.types.STRING,\n            hidden: true\n        }\n    },\n\n    mixins: [],\n\n    prototype_methods: {},\n\n    static_methods: {\n        login: function(req, options) {\n            // your login logic\n        },\n\n        logout: function(req) {\n            // your logout logic\n        }\n    },\n\n    hooks: {\n        beforeSave: function() {\n            var password = this.get('password');\n\n            if (password.length !== 32) {\n                this.set('password', MD5(password));\n            }\n\n            this.set('updated_at', utils.now());\n        }\n    }\n}\n\nUserModel = module.exports = ModelFactory(model_options);\n```\n\n## Instantiating models\n\nBlank model is instantiated by calling a model constructor without arguments:\n\n```javascript\nvar user = new UserModel();\n\nuser(function(model) {\n    model.set({\n        name: 'Shubik',\n        email: 'farennikov@gmail.com',\n        password: 'password'\n    });\n\n    model.save()(function(model) {\n        // model successfully saved\n    }, function(err) {\n        // handle error\n    });\n}, function(err) {\n    // handle error\n});\n```\n\nExisting model is instantiated with model id as argument:\n\n```javascript\nvar user = new UserModel(123);\n\nuser(function(model) {\n    if (model === null) {\n        // model with id 123 was not found\n    } else {\n        var new_name = model.get('name') + ' updated';\n        model.set('name', new_name);\n        model.save();\n    }\n}, function(err) {\n    // handle error\n});\n```\n\nNote that if model with such id is not found, promise will resolve with `null`.\n\n## Model API\n\n__Instance methods__\n\n### model.get()\n\n`get(attr)` retrieves an attribute of the model, or an entire model if attribute name is not provided.\n\n### model.set()\n\n`set(attr, [value])` sssigns new value to an attribute or a number of attributes of the model. If given only 1 param which is an Object, method will use keys of the object as attributes.\n\n### model.save()\n\n`save()` saves a new model or model that has been changed by `set()`. Returns a promise which is resolved with model if model was successfully saved or error if saving model failed. If model was initialized without an id, new model will be attempted to be created.\n\n### model.destroy()\n\n`destroy()` deletes model from a store. Returns a promise which is resolved with this model once model is deleted from database.\n\n### model.keys()\n\n`keys()` returns attribute names of this model.\n\n### model.toJSON()\n\n`toJSON()` returns all attributes of the model (key-value pairs).\n\n### model.validate()\n\n`validate()` validates model attributes according to the model's schema. Returns true or false.\n\n### model.toForm()\n\n`toForm()` returns an object that can be used to create HTML form for this model.\n\n### model.parseForm()\n\n`parseForm(req)` populates a model by values from a request.\n\n### model.toTable()\n\n`toTable()` returns an object that can be used to show this model in table form.\n\nYou can add model-specific instance methods by adding them to `prototype_methods` param of the options you pass to `ModelFactory`.\n\n__Static methods__\n\nModel constructors can have static methods which you can use without instantiating a model. By default there are two static methods: `find()` and `count()`:\n\n### SomeModel.find()\n\n`find(query, offset, limit, sort)` returns a promise which is resolved with an array of models found in database using provided arguments. Example:\n\n```javascript\nUserModel.find({ name: 'Shubik' })(function(results) {\n    // do somethig with `results`\n});\n```\n\n### SomeModel.count()\n\n`count()` returns a promise which is resolved with number of all models in the database. Example:\n\n```javascript\nUserModel.count()(function(num) {\n    // do somethig with `num`\n});\n```\n\nYou can add more model-specific static methods to `static_methods` param of the options you pass to `ModelFactory`.", "maintainers": [{"email": "farennikov@gmail.com", "name": "shubik"}, {"email": "gajus@gajus.com", "name": "gajus"}], "time": {"modified": "2022-06-24T18:20:19.095Z", "created": "2013-06-04T02:17:37.167Z", "0.0.1": "2013-06-04T02:17:40.770Z", "0.0.2": "2013-06-09T11:06:23.981Z", "0.0.3": "2013-06-10T23:52:22.903Z", "0.1.0": "2013-06-13T03:34:06.458Z", "0.1.1": "2013-06-15T00:46:00.654Z", "0.1.2": "2013-06-19T16:46:28.351Z", "0.1.3": "2013-06-26T16:21:14.010Z", "0.1.4": "2013-06-28T05:08:46.135Z", "0.1.5": "2013-07-03T20:44:50.175Z", "0.1.6": "2013-08-29T08:33:52.565Z", "0.1.7": "2013-11-21T00:48:53.103Z"}, "author": {"name": "Alexander Farennikov", "email": "farennikov@gmail.com"}, "repository": {"type": "git", "url": "https://github.com/shubik/prometheus"}}}