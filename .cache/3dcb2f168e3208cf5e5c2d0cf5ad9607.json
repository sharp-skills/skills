{"d": {"exhaustive": {"nbHits": false, "typo": false}, "exhaustiveNbHits": false, "exhaustiveTypo": false, "hits": [{"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "tempAsk"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["netlify", "production"], "value": "[This question was marked as opinion based and \nclosed on stackoverflow.]<p>I currently have a frontend application built with create-react-app starter, and I'm looking to deploy unto <em>Netlify</em>. I understand how deploying to <em>Netlify</em> works, but how does one setup/what is the setup of a git structure that makes continuous deployment easy.<p>I'm thinking to create a new branch for every additional feature pushed to <em>production</em> on <em>Netlify</em>; this new branch will contain the latest <em>production</em> build. However how is this sustainable, especially when using a custom domain; or maybe is this method wrong all together.<p>Bottom line: best git + <em>Netlify</em> workflow for continuous deployment of React apps, with usage of custom domains"}, "title": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["netlify"], "value": "How to deploy a create-react-app to <em>Netlify</em> with continuous deployment"}}, "_tags": ["story", "author_tempAsk", "story_23007179", "ask_hn"], "author": "tempAsk", "created_at": "2020-04-28T14:16:34Z", "created_at_i": 1588083394, "num_comments": 0, "objectID": "23007179", "points": 1, "story_id": 23007179, "story_text": "[This question was marked as opinion based and \nclosed on stackoverflow.]<p>I currently have a frontend application built with create-react-app starter, and I&#x27;m looking to deploy unto Netlify. I understand how deploying to Netlify works, but how does one setup&#x2F;what is the setup of a git structure that makes continuous deployment easy.<p>I&#x27;m thinking to create a new branch for every additional feature pushed to production on Netlify; this new branch will contain the latest production build. However how is this sustainable, especially when using a custom domain; or maybe is this method wrong all together.<p>Bottom line: best git + Netlify workflow for continuous deployment of React apps, with usage of custom domains", "title": "How to deploy a create-react-app to Netlify with continuous deployment", "updated_at": "2024-09-20T06:00:28Z"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "frabjoused"}, "story_text": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["netlify"], "value": "We have a few hundred sites serving their nav \nmenus using a shared CSS file located in a private Github repo. This file is hosted via <em>Netlify</em> with CloudFlare in front.<p>This afternoon we started receiving a number of reports of broken nav styling on the US west coast. On loading these sites, the minified CSS file was replaced with the word &quot;hello&quot;.<p>No commits have been made to this repo since May.  I checked the commit history of the minified file and &quot;hello&quot; was never written by accident at any point. Clearing out the CF cache addressed this.<p>Thoughts?"}, "title": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["netlify", "production"], "value": "<em>Netlify</em> or CloudFlare just replaced our <em>production</em> CSS file with \u201chello\u201d"}}, "_tags": ["story", "author_frabjoused", "story_32756660", "ask_hn"], "author": "frabjoused", "children": [32756707, 32757630, 32758511, 32758698, 32777940, 32783946], "created_at": "2022-09-07T20:51:56Z", "created_at_i": 1662583916, "num_comments": 13, "objectID": "32756660", "points": 10, "story_id": 32756660, "story_text": "We have a few hundred sites serving their nav \nmenus using a shared CSS file located in a private Github repo. This file is hosted via Netlify with CloudFlare in front.<p>This afternoon we started receiving a number of reports of broken nav styling on the US west coast. On loading these sites, the minified CSS file was replaced with the word &quot;hello&quot;.<p>No commits have been made to this repo since May.  I checked the commit history of the minified file and &quot;hello&quot; was never written by accident at any point. Clearing out the CF cache addressed this.<p>Thoughts?", "title": "Netlify or CloudFlare just replaced our production CSS file with \u201chello\u201d", "updated_at": "2024-09-20T12:02:22Z"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "buildinext"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["netlify", "production"], "value": "Hey HN! I've been building Quell, an AI QA testing agent designed to run tests directly triggered from issue trackers (Jira, Linear) or designs (Figma) or CI/CD platforms (Vercel, <em>Netlify</em>, GitHub), ensuring rapid and accurate acceptance testing without manual effort.<p>What problem does it solve?\nAs a product manager and founder myself, I constantly faced issues releasing a new feature only to discover critical bugs or that the build doesn't fully meet acceptance criteria. Bottlenecks in our QA and release process\u2014tickets and issues stuck in manual testing, slow deployments due to delayed verification, and missed acceptance criteria leading to bugs slipping into <em>production</em>. I built Quell to automate these tedious steps, freeing up teams to focus on actual feature development and faster iterations.<p>How is it different?<p>Integrates with existing dev workflows\u2014triggers tests via Jira/Linear issue status automatically testing Vercel, or <em>Netlify</em> or other URL deployment builds.<p>Tests against explicit acceptance criteria pulled directly from your issue tracker.<p>Current Capabilities (free to test):<p>Automatically trigger QA runs from Linear/Jira issue state transitions or Vercel/<em>Netlify</em> deploy previews.<p>Generate immediate test reports and tickets for issues spotted.<p>Quell is ready to test right now\u2014email only required to try out demo functionality directly:<p>Try out [Quellit.ai](<a href=\"http://quellit.ai/\" rel=\"nofollow\">http://quellit.ai/</a>) for free<p>I'm actively iterating based on user feedback\u2014would love to hear your thoughts, suggestions, or even criticisms on the idea, implementation, integrations, or anything else.<p>Thanks for checking it out!"}, "title": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["netlify"], "value": "Show HN: Quell \u2013 AI QA Agent Working Across Linear, Vercel, Jira, <em>Netlify</em>, Figma"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://www.quellit.ai/"}}, "_tags": ["story", "author_buildinext", "story_44083596", "show_hn"], "author": "buildinext", "children": [44187584, 44193749], "created_at": "2025-05-24T20:25:34Z", "created_at_i": 1748118334, "num_comments": 2, "objectID": "44083596", "points": 7, "story_id": 44083596, "story_text": "Hey HN! I&#x27;ve been building Quell, an AI QA testing agent designed to run tests directly triggered from issue trackers (Jira, Linear) or designs (Figma) or CI&#x2F;CD platforms (Vercel, Netlify, GitHub), ensuring rapid and accurate acceptance testing without manual effort.<p>What problem does it solve?\nAs a product manager and founder myself, I constantly faced issues releasing a new feature only to discover critical bugs or that the build doesn&#x27;t fully meet acceptance criteria. Bottlenecks in our QA and release process\u2014tickets and issues stuck in manual testing, slow deployments due to delayed verification, and missed acceptance criteria leading to bugs slipping into production. I built Quell to automate these tedious steps, freeing up teams to focus on actual feature development and faster iterations.<p>How is it different?<p>Integrates with existing dev workflows\u2014triggers tests via Jira&#x2F;Linear issue status automatically testing Vercel, or Netlify or other URL deployment builds.<p>Tests against explicit acceptance criteria pulled directly from your issue tracker.<p>Current Capabilities (free to test):<p>Automatically trigger QA runs from Linear&#x2F;Jira issue state transitions or Vercel&#x2F;Netlify deploy previews.<p>Generate immediate test reports and tickets for issues spotted.<p>Quell is ready to test right now\u2014email only required to try out demo functionality directly:<p>Try out [Quellit.ai](<a href=\"http:&#x2F;&#x2F;quellit.ai&#x2F;\" rel=\"nofollow\">http:&#x2F;&#x2F;quellit.ai&#x2F;</a>) for free<p>I&#x27;m actively iterating based on user feedback\u2014would love to hear your thoughts, suggestions, or even criticisms on the idea, implementation, integrations, or anything else.<p>Thanks for checking it out!", "title": "Show HN: Quell \u2013 AI QA Agent Working Across Linear, Vercel, Jira, Netlify, Figma", "updated_at": "2025-06-06T04:40:09Z", "url": "https://www.quellit.ai/"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "encremagique"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["netlify", "production"], "value": "I'm in a desperate situation and would appreciate any advice from the HN community.<p>*Background:*<p>My <em>production</em> website (encremagique.org) has been completely DOWN for over 7 days. I accidentally deleted a project on Bolt.new (<em>Netlify</em>) on Jan 30, 2026, and immediately paid $17.88 for a Pro plan to restore it (Order #2060-7613).<p>*The Problem:*<p>- Site has been down for 150+ hours\n- Submitted 6 support tickets over 7 days\n- ZERO human responses - only automated &quot;Sam&quot; bot replies\n- No phone support available\n- No escalation path visible<p>*What I've Done:*<p>- Paid Pro subscription immediately after the incident\n- Filed ICANN complaint (Case #01547725)\n- Posted on Twitter tagging @boltdotnew and @StackBlitz\n- Messaged Reddit moderators of r/boltnew\n- Attempted to post on multiple Reddit communities<p>*Impact:*<p>My users cannot access the platform. My business is suffering. 150+ hours of downtime on a PAID account.<p>*My Questions:*<p>1. Has anyone dealt with this level of support unresponsiveness from <em>Netlify</em>/Bolt.new?\n2. What legal/technical options do I have beyond ICANN complaints?\n3. Are there any other escalation paths I'm missing?\n4. Should I consider immediate migration to another provider?<p>*Lessons Learned (so far):*<p>- Always maintain backups on multiple platforms\n- Research support quality before committing to a hosting provider\n- Don't rely on a single provider for critical infrastructure<p>Any advice would be greatly appreciated. I'm documenting everything for potential legal action if needed.<p>Order: #2060-7613 | Domain: encremagique.org | ICANN Case: #01547725"}, "title": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["netlify"], "value": "Ask HN: 7 days down, zero human support from <em>Netlify</em>/Bolt.new (paid account)"}}, "_tags": ["story", "author_encremagique", "story_46909379", "ask_hn"], "author": "encremagique", "children": [46911107], "created_at": "2026-02-06T05:12:30Z", "created_at_i": 1770354750, "num_comments": 0, "objectID": "46909379", "points": 3, "story_id": 46909379, "story_text": "I&#x27;m in a desperate situation and would appreciate any advice from the HN community.<p>*Background:*<p>My production website (encremagique.org) has been completely DOWN for over 7 days. I accidentally deleted a project on Bolt.new (Netlify) on Jan 30, 2026, and immediately paid $17.88 for a Pro plan to restore it (Order #2060-7613).<p>*The Problem:*<p>- Site has been down for 150+ hours\n- Submitted 6 support tickets over 7 days\n- ZERO human responses - only automated &quot;Sam&quot; bot replies\n- No phone support available\n- No escalation path visible<p>*What I&#x27;ve Done:*<p>- Paid Pro subscription immediately after the incident\n- Filed ICANN complaint (Case #01547725)\n- Posted on Twitter tagging @boltdotnew and @StackBlitz\n- Messaged Reddit moderators of r&#x2F;boltnew\n- Attempted to post on multiple Reddit communities<p>*Impact:*<p>My users cannot access the platform. My business is suffering. 150+ hours of downtime on a PAID account.<p>*My Questions:*<p>1. Has anyone dealt with this level of support unresponsiveness from Netlify&#x2F;Bolt.new?\n2. What legal&#x2F;technical options do I have beyond ICANN complaints?\n3. Are there any other escalation paths I&#x27;m missing?\n4. Should I consider immediate migration to another provider?<p>*Lessons Learned (so far):*<p>- Always maintain backups on multiple platforms\n- Research support quality before committing to a hosting provider\n- Don&#x27;t rely on a single provider for critical infrastructure<p>Any advice would be greatly appreciated. I&#x27;m documenting everything for potential legal action if needed.<p>Order: #2060-7613 | Domain: encremagique.org | ICANN Case: #01547725", "title": "Ask HN: 7 days down, zero human support from Netlify/Bolt.new (paid account)", "updated_at": "2026-02-11T12:50:12Z"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "crossivejoker"}, "story_text": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["production"], "value": "I built TruthGate. It\u2019s a self-hosted IPFS gateway that makes decentralized hosting <em>production</em>-grade.<p>The motivation: I like some of the ideas behind IPFS (content addressing, redundancy, distribution), but running a node in practice felt painful. By default, your server turns into a free CDN for strangers, bandwidth and disk get chewed up, and sites are often slow or don\u2019t load at all. SaaS \u201cfixes\u201d exist, but they usually cost more than just renting a normal VPS.<p>TruthGate makes hosting content straightforward: no extra extensions, apps, or SaaS. You can:<p>* Publish Web Assembly websites directly to IPFS and served over HTTPS.<p>* Host and share files without relying on centralized storage.<p>* Only serve your own content (not become a public gateway).<p>* Point your own domain and manage it like any other webserver.<p>For anyone unfamiliar: IPFS is a peer-to-peer, content-addressed file system. In theory, nodes help each other serve shared files and cached sites (deduplication, redundancy, speed). In practice, it hasn\u2019t lived up to that promise. TruthGate is my attempt to fix that gap.<p>My own site runs on it, and the docs are there if you\u2019d like to tinker.<p>Website: <a href=\"https://truthgate.io/\" rel=\"nofollow\">https://truthgate.io/</a><p>GitHub: <a href=\"https://github.com/TruthOrigin/TruthGate-IPFS\" rel=\"nofollow\">https://github.com/TruthOrigin/TruthGate-IPFS</a><p>I\u2019d really appreciate feedback from this community.<p>* Does the \u201cNGINX for decentralized hosting\u201d idea make sense?<p>* Would you actually run something like this at home or in <em>production</em>, or is IPFS still too impractical outside experiments?<p>Thanks for taking a look."}, "title": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["netlify"], "value": "Show HN: TruthGate: Self-hosted IPFS Gateway (<em>Netlify</em> for decentralized hosting)"}}, "_tags": ["story", "author_crossivejoker", "story_45039173", "show_hn"], "author": "crossivejoker", "created_at": "2025-08-27T13:09:17Z", "created_at_i": 1756300157, "num_comments": 0, "objectID": "45039173", "points": 2, "story_id": 45039173, "story_text": "I built TruthGate. It\u2019s a self-hosted IPFS gateway that makes decentralized hosting production-grade.<p>The motivation: I like some of the ideas behind IPFS (content addressing, redundancy, distribution), but running a node in practice felt painful. By default, your server turns into a free CDN for strangers, bandwidth and disk get chewed up, and sites are often slow or don\u2019t load at all. SaaS \u201cfixes\u201d exist, but they usually cost more than just renting a normal VPS.<p>TruthGate makes hosting content straightforward: no extra extensions, apps, or SaaS. You can:<p>* Publish Web Assembly websites directly to IPFS and served over HTTPS.<p>* Host and share files without relying on centralized storage.<p>* Only serve your own content (not become a public gateway).<p>* Point your own domain and manage it like any other webserver.<p>For anyone unfamiliar: IPFS is a peer-to-peer, content-addressed file system. In theory, nodes help each other serve shared files and cached sites (deduplication, redundancy, speed). In practice, it hasn\u2019t lived up to that promise. TruthGate is my attempt to fix that gap.<p>My own site runs on it, and the docs are there if you\u2019d like to tinker.<p>Website: <a href=\"https:&#x2F;&#x2F;truthgate.io&#x2F;\" rel=\"nofollow\">https:&#x2F;&#x2F;truthgate.io&#x2F;</a><p>GitHub: <a href=\"https:&#x2F;&#x2F;github.com&#x2F;TruthOrigin&#x2F;TruthGate-IPFS\" rel=\"nofollow\">https:&#x2F;&#x2F;github.com&#x2F;TruthOrigin&#x2F;TruthGate-IPFS</a><p>I\u2019d really appreciate feedback from this community.<p>* Does the \u201cNGINX for decentralized hosting\u201d idea make sense?<p>* Would you actually run something like this at home or in production, or is IPFS still too impractical outside experiments?<p>Thanks for taking a look.", "title": "Show HN: TruthGate: Self-hosted IPFS Gateway (Netlify for decentralized hosting)", "updated_at": "2025-08-27T20:08:10Z"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "mike_heffner"}, "title": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["production"], "value": "Tracking down a CGO crash in <em>production</em>"}, "url": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["netlify", "production"], "value": "https://www.<em>netlify</em>.com/blog/2021/03/18/tracking-down-a-cgo-crash-in-<em>production</em>/"}}, "_tags": ["story", "author_mike_heffner", "story_26506245"], "author": "mike_heffner", "created_at": "2021-03-18T19:00:06Z", "created_at_i": 1616094006, "num_comments": 0, "objectID": "26506245", "points": 2, "story_id": 26506245, "title": "Tracking down a CGO crash in production", "updated_at": "2024-09-20T08:07:57Z", "url": "https://www.netlify.com/blog/2021/03/18/tracking-down-a-cgo-crash-in-production/"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "wittydeveloper"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["netlify", "production"], "value": "Hi HN! We are Charly and Bryan, founders of Defer (<a href=\"https://www.defer.run/\">https://www.defer.run/</a>). Defer is a zero-infrastructure background jobs platform for Node.js developers. As a managed platform that brings modern development standards to background jobs (ex: multi-env support, zero-API design), we enable Node.js developers to build products faster and scale without effort and infrastructure knowledge.<p>Background jobs, while being used in all web applications (processing webhooks, interacting with 3rd party APIs, or powering core features), did not benefit from the developer experience improvements that arose in all other layers of the Node.js API stack: quick and reliable databases with Supabase or easy Serverless deployment with Vercel.<p>Today, even for simple use cases, working with background jobs in Node.js necessarily requires some infrastructure knowledge\u2014either by deploying and scaling an open source solution (ex: BullMQ) or using an IaaS such as AWS SQS with Lambdas, which comes with complexity and limited features (no support for dead letter queues, dynamic concurrency, or throttling).<p>At a large scale, you will need to solve how to handle rolling restarts, how to auto-scale your workers, how to safely deploy without interrupting long-running jobs, how to safely encrypt jobs\u2019 data, and how to version them. Once deployed, your background job\u2019s code lives in a separate part of your codebase, with its own mental model (queues and workers). Finally, most solutions provide technical dashboards which are not always helpful in debugging <em>production</em> issues, so you end up having to build custom dashboards.<p>Most companies we talked to try to handle those different aspects, building custom similar solutions and using developers\u2019 time that could have been used on user-facing features.<p>Bryan and I are technical founders with 10+ years of experience working at start-ups of all stages (e.g. Algolia, home of HN Search!), from tech lead to CTO roles. Like many developers, we got asked many times to work on background job stacks and invest time into tailoring and scaling them for product needs.<p>I even dedicated most of my time at Algolia to building a custom background jobs pipeline to power the Algolia Shopify integration: ingesting partial webhooks from Shopify, enriching them given customers configuration, in FIFO order per shop, with the Shopify rate limited API, for thousands of shops and the equivalents of 3 millions of jobs per day. Given the complex and unique product requirements of the Algolia Shopify Ingestion Pipeline, the only solution (at the time and context) was to build a custom background jobs stack combining Redis and Kubernetes.<p>When consulting with some startups, we witnessed some developers choosing to keep some slow API routes calling 3rd party APIs synchronously instead of investing time in setting up background jobs. When looking back to the recent increase of productive zero infrastructure solutions in the Node.js ecosystem, we were surprised that the experience with background jobs remained unchanged. We decided to build Defer, so working with background jobs, CRONs, and workflows would match the current standard of Node.js developer experience.<p>Inspired by Next.js, Remix, and <em>Netlify</em> design, background jobs in Defer become background functions that live in your application\u2019s code, with direct access to all configuration options: retry, concurrency, and more (<a href=\"https://docs.defer.run/features/retries-concurrency/\">https://docs.defer.run/features/retries-concurrency/</a>) , and no specific mental model to learn. Your background functions get continuously deployed from GitHub with support for branch-based environments, allowing you to test new background jobs in no time, before safely moving to <em>production</em>.<p>Defer works for all kinds of Node.js projects, not only serverless ones. It does not require you to learn any new architectures or adapt your system design\u2014you just turn your code into background functions using coding patterns you already know, ex: map-reduce, or recursion. \nDefer brings features such as configurable retries (advanced backoff options), throttling, and concurrency at the background job level, which other solutions either require you to implement yourself or are simply not available. Finally, the Defer Dashboard is the only background jobs Dashboard to allow developers to quickly find executions based on business/product metadata, ex: \u201cShow all executions for `user_id=123`) to quickly debug product issues.<p>Defer\u2019s infrastructure, written in Go, is composed of 3 main components: a Build pipeline, a Scheduler, and a Runner. The Build pipeline enables us to build any Node.js project without requiring any configuration file (<a href=\"https://docs.defer.run/platform/builds/\">https://docs.defer.run/platform/builds/</a>). The Scheduler relies on Postgres for persistent storage of your jobs (no risk of losing some)\u2014all jobs\u2019 data is encrypted\u2014and on Redis, as an atomic counter to handle features such as concurrency and throttling (<a href=\"https://docs.defer.run/platform/executions/\">https://docs.defer.run/platform/executions/</a>). Our infrastructure runs on AWS EC2 - leveraging auto-scaling groups, using the containerd API directly from Go.<p>We run a progressive deployment approach to enable uninterrupted long-running jobs (some of our customers\u2019 jobs run for more than 5h) while releasing updates multiple times a day.\nOnce your application is up and running, the Defer dashboard gives you all the essential information to operate background jobs: activity histograms, performances, and Slack alerting upon failures. The executions list comes with rich filters, allowing you to quickly find all the executions linked to a specific customer or other business metadata.<p>In short, we ensure that you get all the essential features, with the best developer experience, and with a fully managed infrastructure and observability tools so you can focus on building your product.<p>All of this would be meaningless without a free plan for small and side projects and usage-based pricing, so that\u2019s what we offer: <a href=\"https://www.defer.run/pricing\">https://www.defer.run/pricing</a>. If you want to give Defer a try, you can get started with a simple GitHub login, without any credit card information required, and our docs are at <a href=\"https://docs.defer.run\">https://docs.defer.run</a>.<p>We would love to get to read about your experience with doing background jobs in Node.js and feedback on what we\u2019ve built. We look forward to your comments!"}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Launch HN: Defer (YC W23) \u2013 Zero-infrastructure background jobs for Node.js"}}, "_tags": ["story", "author_wittydeveloper", "story_35096366", "launch_hn"], "author": "wittydeveloper", "children": [35096646, 35096731, 35096886, 35096954, 35096959, 35097077, 35097099, 35097402, 35097535, 35098275, 35098305, 35098361, 35098423, 35098557, 35098565, 35098719, 35098883, 35099085, 35099170, 35099345, 35099662, 35099755, 35099762, 35100148, 35100323, 35100358, 35100904, 35100981, 35101468, 35102310, 35103784, 35103985, 35104591, 35104896, 35106645, 35106927, 35107080, 35107948, 35108417, 35265216], "created_at": "2023-03-10T16:16:28Z", "created_at_i": 1678464988, "num_comments": 111, "objectID": "35096366", "points": 202, "story_id": 35096366, "story_text": "Hi HN! We are Charly and Bryan, founders of Defer (<a href=\"https:&#x2F;&#x2F;www.defer.run&#x2F;\">https:&#x2F;&#x2F;www.defer.run&#x2F;</a>). Defer is a zero-infrastructure background jobs platform for Node.js developers. As a managed platform that brings modern development standards to background jobs (ex: multi-env support, zero-API design), we enable Node.js developers to build products faster and scale without effort and infrastructure knowledge.<p>Background jobs, while being used in all web applications (processing webhooks, interacting with 3rd party APIs, or powering core features), did not benefit from the developer experience improvements that arose in all other layers of the Node.js API stack: quick and reliable databases with Supabase or easy Serverless deployment with Vercel.<p>Today, even for simple use cases, working with background jobs in Node.js necessarily requires some infrastructure knowledge\u2014either by deploying and scaling an open source solution (ex: BullMQ) or using an IaaS such as AWS SQS with Lambdas, which comes with complexity and limited features (no support for dead letter queues, dynamic concurrency, or throttling).<p>At a large scale, you will need to solve how to handle rolling restarts, how to auto-scale your workers, how to safely deploy without interrupting long-running jobs, how to safely encrypt jobs\u2019 data, and how to version them. Once deployed, your background job\u2019s code lives in a separate part of your codebase, with its own mental model (queues and workers). Finally, most solutions provide technical dashboards which are not always helpful in debugging production issues, so you end up having to build custom dashboards.<p>Most companies we talked to try to handle those different aspects, building custom similar solutions and using developers\u2019 time that could have been used on user-facing features.<p>Bryan and I are technical founders with 10+ years of experience working at start-ups of all stages (e.g. Algolia, home of HN Search!), from tech lead to CTO roles. Like many developers, we got asked many times to work on background job stacks and invest time into tailoring and scaling them for product needs.<p>I even dedicated most of my time at Algolia to building a custom background jobs pipeline to power the Algolia Shopify integration: ingesting partial webhooks from Shopify, enriching them given customers configuration, in FIFO order per shop, with the Shopify rate limited API, for thousands of shops and the equivalents of 3 millions of jobs per day. Given the complex and unique product requirements of the Algolia Shopify Ingestion Pipeline, the only solution (at the time and context) was to build a custom background jobs stack combining Redis and Kubernetes.<p>When consulting with some startups, we witnessed some developers choosing to keep some slow API routes calling 3rd party APIs synchronously instead of investing time in setting up background jobs. When looking back to the recent increase of productive zero infrastructure solutions in the Node.js ecosystem, we were surprised that the experience with background jobs remained unchanged. We decided to build Defer, so working with background jobs, CRONs, and workflows would match the current standard of Node.js developer experience.<p>Inspired by Next.js, Remix, and Netlify design, background jobs in Defer become background functions that live in your application\u2019s code, with direct access to all configuration options: retry, concurrency, and more (<a href=\"https:&#x2F;&#x2F;docs.defer.run&#x2F;features&#x2F;retries-concurrency&#x2F;\">https:&#x2F;&#x2F;docs.defer.run&#x2F;features&#x2F;retries-concurrency&#x2F;</a>) , and no specific mental model to learn. Your background functions get continuously deployed from GitHub with support for branch-based environments, allowing you to test new background jobs in no time, before safely moving to production.<p>Defer works for all kinds of Node.js projects, not only serverless ones. It does not require you to learn any new architectures or adapt your system design\u2014you just turn your code into background functions using coding patterns you already know, ex: map-reduce, or recursion. \nDefer brings features such as configurable retries (advanced backoff options), throttling, and concurrency at the background job level, which other solutions either require you to implement yourself or are simply not available. Finally, the Defer Dashboard is the only background jobs Dashboard to allow developers to quickly find executions based on business&#x2F;product metadata, ex: \u201cShow all executions for `user_id=123`) to quickly debug product issues.<p>Defer\u2019s infrastructure, written in Go, is composed of 3 main components: a Build pipeline, a Scheduler, and a Runner. The Build pipeline enables us to build any Node.js project without requiring any configuration file (<a href=\"https:&#x2F;&#x2F;docs.defer.run&#x2F;platform&#x2F;builds&#x2F;\">https:&#x2F;&#x2F;docs.defer.run&#x2F;platform&#x2F;builds&#x2F;</a>). The Scheduler relies on Postgres for persistent storage of your jobs (no risk of losing some)\u2014all jobs\u2019 data is encrypted\u2014and on Redis, as an atomic counter to handle features such as concurrency and throttling (<a href=\"https:&#x2F;&#x2F;docs.defer.run&#x2F;platform&#x2F;executions&#x2F;\">https:&#x2F;&#x2F;docs.defer.run&#x2F;platform&#x2F;executions&#x2F;</a>). Our infrastructure runs on AWS EC2 - leveraging auto-scaling groups, using the containerd API directly from Go.<p>We run a progressive deployment approach to enable uninterrupted long-running jobs (some of our customers\u2019 jobs run for more than 5h) while releasing updates multiple times a day.\nOnce your application is up and running, the Defer dashboard gives you all the essential information to operate background jobs: activity histograms, performances, and Slack alerting upon failures. The executions list comes with rich filters, allowing you to quickly find all the executions linked to a specific customer or other business metadata.<p>In short, we ensure that you get all the essential features, with the best developer experience, and with a fully managed infrastructure and observability tools so you can focus on building your product.<p>All of this would be meaningless without a free plan for small and side projects and usage-based pricing, so that\u2019s what we offer: <a href=\"https:&#x2F;&#x2F;www.defer.run&#x2F;pricing\">https:&#x2F;&#x2F;www.defer.run&#x2F;pricing</a>. If you want to give Defer a try, you can get started with a simple GitHub login, without any credit card information required, and our docs are at <a href=\"https:&#x2F;&#x2F;docs.defer.run\">https:&#x2F;&#x2F;docs.defer.run</a>.<p>We would love to get to read about your experience with doing background jobs in Node.js and feedback on what we\u2019ve built. We look forward to your comments!", "title": "Launch HN: Defer (YC W23) \u2013 Zero-infrastructure background jobs for Node.js", "updated_at": "2024-09-20T13:31:31Z"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "lewisl9029"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["netlify", "production"], "value": "Hi HN! I've been working on Reflame since I quit my job at Brex last year, excited to finally open it up for everybody to try out! Here's a demo: <a href=\"https://www.youtube.com/watch?v=SohUnrjiIxk\" rel=\"nofollow\">https://www.youtube.com/watch?v=SohUnrjiIxk</a><p>Reflame deploys client-rendered React web apps instantly, to previews and to <em>production</em>.<p>In concrete wall-clock terms, deploys generally take:<p>- ~50-500ms from our VSCode extension<p>- ~500-3000ms from our GitHub app<p>(Jump to this comment (<a href=\"https://news.ycombinator.com/item?id=33134082\" rel=\"nofollow\">https://news.ycombinator.com/item?id=33134082</a>) for what makes Reflame so fast)<p>The Reflame GitHub App automatically deploys default branches to <em>production</em>, and other branches to previews. If you've used <em>Netlify</em>/Vercel's GitHub apps, you should feel right at home. The difference is it\u2019s multiple orders of magnitudes faster. Fast enough that <i>you'll probably never see an in-progress deploy on GitHub ever again</i>, only ready-to-go preview/<em>production</em> links.<p>No more having to babysit builds or having to context switch to and from other tasks before being able to see our changes deployed in previews or <em>production</em>. Previewing, sharing, and even shipping, can now become part of the so-called inner loop, giving us the superpower to stay in flow state for much longer.<p>The Reflame VSCode extension is yet another order of magnitude faster than even the GitHub App. It was designed to offer an experience that can rival local development workflows in both speed and ergonomics, while addressing many of local dev's limitations around collaboration and <em>production</em>-parity. Every time we make a change (e.g. by saving a file), the extension will deploy that change (in ~50-500ms) to a &quot;Live Preview&quot;, and will immediately update the app in our browsers to reflect that change.<p>Live Previews can operate in one of two modes:<p>- Development mode delivers updates through React Fast Refresh, offering the familiar state-preserving instant feedback loop we know and love from local development workflows.<p>- <em>Production</em> mode delivers updates by triggering a full browser reload on every change, and in exchange for this extra bit of friction, we get to develop against a byte-identical version of the fully optimized <em>production</em> deployment that customers will see once we ship, with a tighter feedback loop than was ever possible before.<p>Live Previews deliver updates over the internet, meaning we can effortlessly test out our changes on multiple devices simultaneously, and show our changes to anyone in the world, just by sharing a Live Preview link, all while having our updates reflected automatically across all connected devices in real-time (with live reload or React Fast Refresh <i>over the internet</i>).<p>Being able to ship quickly is valuable on its own, but Reflame's true north star has always been to enable customers to ship quickly <i>with confidence</i>.<p>One way Reflame helps customers ship with more confidence today is by making previews with full <em>production</em>-parity available at every step of the development process. Previews in Reflame are accessible at the exact same URL customers will use to access the <em>production</em> deployment, instead of at a different subdomain for each preview (i.e. every preview is accessed through <a href=\"https://reflame.app\" rel=\"nofollow\">https://reflame.app</a> instead of at <a href=\"https://some-branch-of-reflamedotapp.reflame-previews.dev\" rel=\"nofollow\">https://some-branch-of-reflamedotapp.reflame-previews.dev</a>). Behind the scenes, this is implemented using session cookies that our CDN will check to determine which version of the app to serve.<p>This is only the tip of the iceberg. We have some really exciting prototypes around testing and typechecking that we've been exploring that could allow us to ship with even more confidence <i>without ever slowing us down</i>.<p>If any of this sounds interesting for the apps you're building or planning to build (taking into account this comment (<a href=\"https://news.ycombinator.com/item?id=33134092\" rel=\"nofollow\">https://news.ycombinator.com/item?id=33134092</a>) below describing what Reflame is not well suited for), please sign up and give it a try!<p>I can't wait to see what you\u2019ll build with it! :)"}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Show HN: Reflame \u2013 Deploy your React web apps in milliseconds"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://reflame.app/?source=show-hn-launch"}}, "_tags": ["story", "author_lewisl9029", "story_33134059", "show_hn"], "author": "lewisl9029", "children": [33134082, 33134092, 33134107, 33134881, 33135016, 33135040, 33135050, 33135145, 33135174, 33135375, 33135600, 33136484, 33136732, 33136757, 33136808, 33137096, 33137485], "created_at": "2022-10-08T17:10:57Z", "created_at_i": 1665249057, "num_comments": 56, "objectID": "33134059", "points": 147, "story_id": 33134059, "story_text": "Hi HN! I&#x27;ve been working on Reflame since I quit my job at Brex last year, excited to finally open it up for everybody to try out! Here&#x27;s a demo: <a href=\"https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=SohUnrjiIxk\" rel=\"nofollow\">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=SohUnrjiIxk</a><p>Reflame deploys client-rendered React web apps instantly, to previews and to production.<p>In concrete wall-clock terms, deploys generally take:<p>- ~50-500ms from our VSCode extension<p>- ~500-3000ms from our GitHub app<p>(Jump to this comment (<a href=\"https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=33134082\" rel=\"nofollow\">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=33134082</a>) for what makes Reflame so fast)<p>The Reflame GitHub App automatically deploys default branches to production, and other branches to previews. If you&#x27;ve used Netlify&#x2F;Vercel&#x27;s GitHub apps, you should feel right at home. The difference is it\u2019s multiple orders of magnitudes faster. Fast enough that <i>you&#x27;ll probably never see an in-progress deploy on GitHub ever again</i>, only ready-to-go preview&#x2F;production links.<p>No more having to babysit builds or having to context switch to and from other tasks before being able to see our changes deployed in previews or production. Previewing, sharing, and even shipping, can now become part of the so-called inner loop, giving us the superpower to stay in flow state for much longer.<p>The Reflame VSCode extension is yet another order of magnitude faster than even the GitHub App. It was designed to offer an experience that can rival local development workflows in both speed and ergonomics, while addressing many of local dev&#x27;s limitations around collaboration and production-parity. Every time we make a change (e.g. by saving a file), the extension will deploy that change (in ~50-500ms) to a &quot;Live Preview&quot;, and will immediately update the app in our browsers to reflect that change.<p>Live Previews can operate in one of two modes:<p>- Development mode delivers updates through React Fast Refresh, offering the familiar state-preserving instant feedback loop we know and love from local development workflows.<p>- Production mode delivers updates by triggering a full browser reload on every change, and in exchange for this extra bit of friction, we get to develop against a byte-identical version of the fully optimized production deployment that customers will see once we ship, with a tighter feedback loop than was ever possible before.<p>Live Previews deliver updates over the internet, meaning we can effortlessly test out our changes on multiple devices simultaneously, and show our changes to anyone in the world, just by sharing a Live Preview link, all while having our updates reflected automatically across all connected devices in real-time (with live reload or React Fast Refresh <i>over the internet</i>).<p>Being able to ship quickly is valuable on its own, but Reflame&#x27;s true north star has always been to enable customers to ship quickly <i>with confidence</i>.<p>One way Reflame helps customers ship with more confidence today is by making previews with full production-parity available at every step of the development process. Previews in Reflame are accessible at the exact same URL customers will use to access the production deployment, instead of at a different subdomain for each preview (i.e. every preview is accessed through <a href=\"https:&#x2F;&#x2F;reflame.app\" rel=\"nofollow\">https:&#x2F;&#x2F;reflame.app</a> instead of at <a href=\"https:&#x2F;&#x2F;some-branch-of-reflamedotapp.reflame-previews.dev\" rel=\"nofollow\">https:&#x2F;&#x2F;some-branch-of-reflamedotapp.reflame-previews.dev</a>). Behind the scenes, this is implemented using session cookies that our CDN will check to determine which version of the app to serve.<p>This is only the tip of the iceberg. We have some really exciting prototypes around testing and typechecking that we&#x27;ve been exploring that could allow us to ship with even more confidence <i>without ever slowing us down</i>.<p>If any of this sounds interesting for the apps you&#x27;re building or planning to build (taking into account this comment (<a href=\"https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=33134092\" rel=\"nofollow\">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=33134092</a>) below describing what Reflame is not well suited for), please sign up and give it a try!<p>I can&#x27;t wait to see what you\u2019ll build with it! :)", "title": "Show HN: Reflame \u2013 Deploy your React web apps in milliseconds", "updated_at": "2025-10-06T20:48:13Z", "url": "https://reflame.app/?source=show-hn-launch"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "podoman"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["netlify", "production"], "value": "Hello Hacker News! We're Jay and Himank from Reploy (<a href=\"https://getreploy.com\" rel=\"nofollow\">https://getreploy.com</a>). We're building a platform that allows teams to easily configure full-stack staging environments or &quot;previews&quot; of their web app which are created on every open PR.<p>In the past, Himank and I spent time at several startups (~10-&gt;200 employees), where we were on customer-facing, product-oriented teams. We often found ourselves in positions where we wanted to share our environment with designer/PM/sales folks who didn't necessarily have a dev environment setup, and ngrok didn't cut it.  Further, even when trying to share our environment with fellow engineers, there was always a slow down when requiring that they git stash, git pull, etc..<p>The solution to these pain points was either:<p>1) Waiting for a full staging or <em>production</em> deployment, which in most cases, wasn't really practical (from a cost and/or time perspective).<p>2) Using a static site hosting solution (Vercel, <em>Netlify</em>, etc..) which didn't allow us to preview full-stack changes.<p>At some of these companies, an infra team had tried to build something like this, however, the &quot;preview&quot; workflow was very different than the &quot;<em>production</em>&quot; workflow, so there were annoyances (slow builds, lack of concurrent env support, no populating staging data etc..) that made the tool hard to use. This is where Reploy comes in! Especially in the current remote landscape, being able to have as many staging environments as features is helping teams move faster by simplifying and streamlining the feature development flow.<p>We've put a lot of time into making this dead simple to set up. Just connect your repo, give us the commands that you run on your dev machine, and we'll spit out a live environment on a managed link. All of this configuration can be described in the `reploy.yml` file, which is essentially a simpler version of docker-compose :). And if you already have a docker-compose file, we can use that as well :).<p>Take a look at a demo on our site! (<a href=\"https://getreploy.com\" rel=\"nofollow\">https://getreploy.com</a>).<p>How does it work you may ask? The short answer is k8s. We schedule these environments on Kubernetes, however, we hide this from end-users so that all that they're interacting with is the Reploy configuration (just a series of commands to start up your web app). We've also curated a bunch of &quot;runtimes&quot;  which contain common framework dependencies (reactjs, node, rails, etc..) so that if you don't want to worry about docker, you don't have to :) . And for the hardcore folks out there, we also support custom images.<p>A few notable features that Reploy offers (specific to the aforementioned &quot;staging&quot; workflow):<p>1) Caching of specific directories (node_modules, .bundle, etc..) -&gt; faster builds<p>2) Restarts of past environments -&gt; Let's you compare the state of different commits<p>3) Notifications! -&gt; We'll notify your team when a new environment is ready or failed the build process via slack, email, etc..<p>4) A &quot;setup&quot; hook where your team can populate a database with staging data, or configure the host environment to your liking.<p>From a pricing angle, we're looking to charge like most CI providers. That is, we'll charge a base price per engineer/user (~$30) and prorate any additional usage over a max number of concurrent environments. On that note, we've realized that pricing for Reploy is a very interesting problem, as the types of users that are creating environments (engineers, devops teams, etc..) are not necessarily the only users getting value out of the product (PMs, for example). If you have any thoughts here, we'd love to hear them in the comments!<p>Feel free to request access at <a href=\"https://getreploy.com\" rel=\"nofollow\">https://getreploy.com</a> if you're interested in getting up and running; also happy to answer any questions at `jay [at] getreploy.com`.<p>Overall, very excited to be sharing this with HN, we'd love to hear your thoughts and keep the conversation going :)."}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Launch HN: Reploy (YC S20) \u2013 Instant fullstack staging environments for web apps"}}, "_tags": ["story", "author_podoman", "story_23917956", "launch_hn"], "author": "podoman", "children": [23918250, 23918279, 23918472, 23918531, 23918649, 23918705, 23918808, 23918809, 23918828, 23918841, 23919052, 23919408, 23920078, 23920101, 23920106, 23921130, 23921348, 23922093, 23923882, 23926049, 23927028, 23935218], "created_at": "2020-07-22T15:20:54Z", "created_at_i": 1595431254, "num_comments": 84, "objectID": "23917956", "points": 114, "story_id": 23917956, "story_text": "Hello Hacker News! We&#x27;re Jay and Himank from Reploy (<a href=\"https:&#x2F;&#x2F;getreploy.com\" rel=\"nofollow\">https:&#x2F;&#x2F;getreploy.com</a>). We&#x27;re building a platform that allows teams to easily configure full-stack staging environments or &quot;previews&quot; of their web app which are created on every open PR.<p>In the past, Himank and I spent time at several startups (~10-&gt;200 employees), where we were on customer-facing, product-oriented teams. We often found ourselves in positions where we wanted to share our environment with designer&#x2F;PM&#x2F;sales folks who didn&#x27;t necessarily have a dev environment setup, and ngrok didn&#x27;t cut it.  Further, even when trying to share our environment with fellow engineers, there was always a slow down when requiring that they git stash, git pull, etc..<p>The solution to these pain points was either:<p>1) Waiting for a full staging or production deployment, which in most cases, wasn&#x27;t really practical (from a cost and&#x2F;or time perspective).<p>2) Using a static site hosting solution (Vercel, Netlify, etc..) which didn&#x27;t allow us to preview full-stack changes.<p>At some of these companies, an infra team had tried to build something like this, however, the &quot;preview&quot; workflow was very different than the &quot;production&quot; workflow, so there were annoyances (slow builds, lack of concurrent env support, no populating staging data etc..) that made the tool hard to use. This is where Reploy comes in! Especially in the current remote landscape, being able to have as many staging environments as features is helping teams move faster by simplifying and streamlining the feature development flow.<p>We&#x27;ve put a lot of time into making this dead simple to set up. Just connect your repo, give us the commands that you run on your dev machine, and we&#x27;ll spit out a live environment on a managed link. All of this configuration can be described in the `reploy.yml` file, which is essentially a simpler version of docker-compose :). And if you already have a docker-compose file, we can use that as well :).<p>Take a look at a demo on our site! (<a href=\"https:&#x2F;&#x2F;getreploy.com\" rel=\"nofollow\">https:&#x2F;&#x2F;getreploy.com</a>).<p>How does it work you may ask? The short answer is k8s. We schedule these environments on Kubernetes, however, we hide this from end-users so that all that they&#x27;re interacting with is the Reploy configuration (just a series of commands to start up your web app). We&#x27;ve also curated a bunch of &quot;runtimes&quot;  which contain common framework dependencies (reactjs, node, rails, etc..) so that if you don&#x27;t want to worry about docker, you don&#x27;t have to :) . And for the hardcore folks out there, we also support custom images.<p>A few notable features that Reploy offers (specific to the aforementioned &quot;staging&quot; workflow):<p>1) Caching of specific directories (node_modules, .bundle, etc..) -&gt; faster builds<p>2) Restarts of past environments -&gt; Let&#x27;s you compare the state of different commits<p>3) Notifications! -&gt; We&#x27;ll notify your team when a new environment is ready or failed the build process via slack, email, etc..<p>4) A &quot;setup&quot; hook where your team can populate a database with staging data, or configure the host environment to your liking.<p>From a pricing angle, we&#x27;re looking to charge like most CI providers. That is, we&#x27;ll charge a base price per engineer&#x2F;user (~$30) and prorate any additional usage over a max number of concurrent environments. On that note, we&#x27;ve realized that pricing for Reploy is a very interesting problem, as the types of users that are creating environments (engineers, devops teams, etc..) are not necessarily the only users getting value out of the product (PMs, for example). If you have any thoughts here, we&#x27;d love to hear them in the comments!<p>Feel free to request access at <a href=\"https:&#x2F;&#x2F;getreploy.com\" rel=\"nofollow\">https:&#x2F;&#x2F;getreploy.com</a> if you&#x27;re interested in getting up and running; also happy to answer any questions at `jay [at] getreploy.com`.<p>Overall, very excited to be sharing this with HN, we&#x27;d love to hear your thoughts and keep the conversation going :).", "title": "Launch HN: Reploy (YC S20) \u2013 Instant fullstack staging environments for web apps", "updated_at": "2024-09-20T06:34:09Z"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "sakerbos"}, "story_text": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["production"], "value": "My cousin and I love the Terraforming Mars board game. But we'd often get overly excited and knock our pieces off of our boards, losing track of our progress. So I digitised it. It comes with a few cool features like resource conversions (e.g. converting plants to greenery), <em>production</em> phase, offline, mobile-friendly and keeps track of the history using the browser history itself. Sharing this here in case there are any other TM fans that could also find some use in this :)"}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Show HN: Digital player board for Terraforming Mars"}, "url": {"fullyHighlighted": false, "matchLevel": "partial", "matchedWords": ["netlify"], "value": "https://terraforming-mars-player-board.<em>netlify</em>.app/"}}, "_tags": ["story", "author_sakerbos", "story_40406344", "show_hn"], "author": "sakerbos", "children": [40406682, 40406738, 40406996, 40407090, 40407092, 40407119, 40407247, 40407502, 40407767, 40408020, 40408095, 40408304, 40408435, 40408732, 40409060, 40409844, 40410064, 40423480], "created_at": "2024-05-19T12:00:25Z", "created_at_i": 1716120025, "num_comments": 47, "objectID": "40406344", "points": 72, "story_id": 40406344, "story_text": "My cousin and I love the Terraforming Mars board game. But we&#x27;d often get overly excited and knock our pieces off of our boards, losing track of our progress. So I digitised it. It comes with a few cool features like resource conversions (e.g. converting plants to greenery), production phase, offline, mobile-friendly and keeps track of the history using the browser history itself. Sharing this here in case there are any other TM fans that could also find some use in this :)", "title": "Show HN: Digital player board for Terraforming Mars", "updated_at": "2024-09-20T16:59:41Z", "url": "https://terraforming-mars-player-board.netlify.app/"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "tonyhb"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["netlify", "production"], "value": "Hi HN! I\u2019m Tony, one of the co-founders of Inngest (<a href=\"https://inngest.com/\" rel=\"nofollow\">https://inngest.com/</a>).  Wanted to show you something we\u2019re working on: StepKit.<p>StepKit is an open source SDK and framework for building and iterating on durable workflows that run on any platform (self-hosted, Inngest, Cloudflare, <em>Netlify</em>, etc.) without requiring any provider or bundler-specific code.<p>Here\u2019s the repo: <a href=\"https://github.com/inngest/stepkit\" rel=\"nofollow\">https://github.com/inngest/stepkit</a>.<p>StepKit extracts the core execution loop that we built in Inngest and makes it fully open, Apache 2, and hackable/pluggable to different backends.  We don\u2019t want people to have to go through multiple major versions in SDKs to learn the lessons we\u2019ve already learned in <em>production</em>:<p><i>It needs to work anywhere:</i> This SDK is push-based and receives tasks via API endpoints, so it works anywhere (servers, serverless, k8s, etc).  That's also customizable.  It doesn\u2019t need any specific runtime or bundler support.<p><i>It needs to be complete:</i> StepKit includes the entire execution engine: step discovery, memoization, a core event loop to turn async steps into generators <i>without</i> relying on `try/catch` based control, and middleware for extensibility (eg, end-to-end encryption, Sentry integrations, and so on).<p><i>It needs a simple API:</i> StepKit APIs are explicit `step.*()` functions, which we designed in our original Inngest SDK back in 2022.  They\u2019re easy to read, understand, implement, and use.  They contain all of the primitives for durable execution: steps, suspend/resume, human-in-the-loop, and observability.  These same APIs have also been adopted by Cloudflare, <em>Netlify</em>, Convex, and others, and support billions of runs every month.<p><i>It needs to be resilient</i>: Steps tolerate changes when refactoring, and provide the building blocks of durable execution without complex abstractions.<p>We\u2019re starting with in-memory, filesystem, Inngest, and Cloudflare (WIP) drivers, with more coming soon.<p>The roadmap includes middleware, compatible SDKs in different languages, as well as extensions like concurrency controls and idempotency: <a href=\"https://github.com/inngest/stepkit/discussions/52\" rel=\"nofollow\">https://github.com/inngest/stepkit/discussions/52</a>.<p>Excited to see what you think:  <a href=\"https://github.com/inngest/stepkit\" rel=\"nofollow\">https://github.com/inngest/stepkit</a>."}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Show HN: StepKit, an open and cross-platform durable execution standard"}}, "_tags": ["story", "author_tonyhb", "story_46048322", "show_hn"], "author": "tonyhb", "children": [46048394, 46048502, 46048652, 46048864, 46048884, 46049036, 46049496, 46049731, 46049923, 46053648, 46055736, 46056151, 46057282], "created_at": "2025-11-25T17:39:36Z", "created_at_i": 1764092376, "num_comments": 16, "objectID": "46048322", "points": 36, "story_id": 46048322, "story_text": "Hi HN! I\u2019m Tony, one of the co-founders of Inngest (<a href=\"https:&#x2F;&#x2F;inngest.com&#x2F;\" rel=\"nofollow\">https:&#x2F;&#x2F;inngest.com&#x2F;</a>).  Wanted to show you something we\u2019re working on: StepKit.<p>StepKit is an open source SDK and framework for building and iterating on durable workflows that run on any platform (self-hosted, Inngest, Cloudflare, Netlify, etc.) without requiring any provider or bundler-specific code.<p>Here\u2019s the repo: <a href=\"https:&#x2F;&#x2F;github.com&#x2F;inngest&#x2F;stepkit\" rel=\"nofollow\">https:&#x2F;&#x2F;github.com&#x2F;inngest&#x2F;stepkit</a>.<p>StepKit extracts the core execution loop that we built in Inngest and makes it fully open, Apache 2, and hackable&#x2F;pluggable to different backends.  We don\u2019t want people to have to go through multiple major versions in SDKs to learn the lessons we\u2019ve already learned in production:<p><i>It needs to work anywhere:</i> This SDK is push-based and receives tasks via API endpoints, so it works anywhere (servers, serverless, k8s, etc).  That&#x27;s also customizable.  It doesn\u2019t need any specific runtime or bundler support.<p><i>It needs to be complete:</i> StepKit includes the entire execution engine: step discovery, memoization, a core event loop to turn async steps into generators <i>without</i> relying on `try&#x2F;catch` based control, and middleware for extensibility (eg, end-to-end encryption, Sentry integrations, and so on).<p><i>It needs a simple API:</i> StepKit APIs are explicit `step.*()` functions, which we designed in our original Inngest SDK back in 2022.  They\u2019re easy to read, understand, implement, and use.  They contain all of the primitives for durable execution: steps, suspend&#x2F;resume, human-in-the-loop, and observability.  These same APIs have also been adopted by Cloudflare, Netlify, Convex, and others, and support billions of runs every month.<p><i>It needs to be resilient</i>: Steps tolerate changes when refactoring, and provide the building blocks of durable execution without complex abstractions.<p>We\u2019re starting with in-memory, filesystem, Inngest, and Cloudflare (WIP) drivers, with more coming soon.<p>The roadmap includes middleware, compatible SDKs in different languages, as well as extensions like concurrency controls and idempotency: <a href=\"https:&#x2F;&#x2F;github.com&#x2F;inngest&#x2F;stepkit&#x2F;discussions&#x2F;52\" rel=\"nofollow\">https:&#x2F;&#x2F;github.com&#x2F;inngest&#x2F;stepkit&#x2F;discussions&#x2F;52</a>.<p>Excited to see what you think:  <a href=\"https:&#x2F;&#x2F;github.com&#x2F;inngest&#x2F;stepkit\" rel=\"nofollow\">https:&#x2F;&#x2F;github.com&#x2F;inngest&#x2F;stepkit</a>.", "title": "Show HN: StepKit, an open and cross-platform durable execution standard", "updated_at": "2025-11-28T01:21:40Z"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "phrasecode"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["netlify", "production"], "value": "LinkedQL is a new SQL client that supports live queries over any Postgres, MySQL, and MariaDB database. You get result sets that self-update differentially as rows change in your database \u2013 via inserts, updates, deletes. Works with no extra tooling/ORM layer or GraphQL servers. You opt into live mode simply with a flag:\nclient.query('SELECT ...', { live: true }).\nMore at: <a href=\"https://linked-ql.netlify.app/capabilities/live-queries\" rel=\"nofollow\">https://linked-ql.<em>netlify</em>.app/capabilities/live-queries</a><p>LinkedQL is written in JavaScript and runs in both client and server environments.<p>GitHub + docs: <a href=\"https://github.com/linked-db/linked-ql\" rel=\"nofollow\">https://github.com/linked-db/linked-ql</a><p>Demo examples included.<p>I\u2019d love feedback:\n\u2022 Anything confusing?\n\u2022 Anything seems useful or dangerous?\n\u2022 Anything else that'd make you consider LinkedQL for <em>production</em>?<p>Thanks for taking a look \u2014 happy to answer any questions."}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Show HN: LinkedQL \u2013 Live Queries over Postgres, MySQL, MariaDB"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://github.com/linked-db/linked-ql"}}, "_tags": ["story", "author_phrasecode", "story_46192545", "show_hn"], "author": "phrasecode", "children": [46192583, 46193562, 46256634, 46256671, 46256722, 46257024, 46258193, 46259289], "created_at": "2025-12-08T14:23:36Z", "created_at_i": 1765203816, "num_comments": 22, "objectID": "46192545", "points": 31, "story_id": 46192545, "story_text": "LinkedQL is a new SQL client that supports live queries over any Postgres, MySQL, and MariaDB database. You get result sets that self-update differentially as rows change in your database \u2013 via inserts, updates, deletes. Works with no extra tooling&#x2F;ORM layer or GraphQL servers. You opt into live mode simply with a flag:\nclient.query(&#x27;SELECT ...&#x27;, { live: true }).\nMore at: <a href=\"https:&#x2F;&#x2F;linked-ql.netlify.app&#x2F;capabilities&#x2F;live-queries\" rel=\"nofollow\">https:&#x2F;&#x2F;linked-ql.netlify.app&#x2F;capabilities&#x2F;live-queries</a><p>LinkedQL is written in JavaScript and runs in both client and server environments.<p>GitHub + docs: <a href=\"https:&#x2F;&#x2F;github.com&#x2F;linked-db&#x2F;linked-ql\" rel=\"nofollow\">https:&#x2F;&#x2F;github.com&#x2F;linked-db&#x2F;linked-ql</a><p>Demo examples included.<p>I\u2019d love feedback:\n\u2022 Anything confusing?\n\u2022 Anything seems useful or dangerous?\n\u2022 Anything else that&#x27;d make you consider LinkedQL for production?<p>Thanks for taking a look \u2014 happy to answer any questions.", "title": "Show HN: LinkedQL \u2013 Live Queries over Postgres, MySQL, MariaDB", "updated_at": "2025-12-20T04:21:50Z", "url": "https://github.com/linked-db/linked-ql"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "honey_m"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["netlify", "production"], "value": "Hey there, I am Honey - Co-founder at Locofy.<p>We, along with other makers, have been building Locofy.ai to help massively accelerate the builders - the designers, developers, product managers &amp; founders, and we're excited to share it today with the HN Community.<p>Locofy.ai simply converts designs into <em>production</em>-ready frontend code for web and mobile apps. It adapts to your preferred design tools, tech stack, and workflows with ease and lets you launch upto 4x faster, while letting designers design the way they want and giving high-quality responsive code that developers love.<p>With this launch, you can convert your Figma designs into React, React Native, Next.js, Gatsby, and HTML-CSS code. You get a live-responsive prototype that runs on code (we call these \u2018real-fidelity prototypes\u2019) and when good to go, you can either export the code to build on top of it or directly deploy to <em>Netlify</em>, Vercel, or Github.<p>Today, we have also launched on Product Hunt. Let us know your thoughts and suggestions: <a href=\"https://www.producthunt.com/posts/locofy-ai\" rel=\"nofollow\">https://www.producthunt.com/posts/locofy-ai</a>.<p>Our team will be answering all your questions!"}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Show HN: Locofy.ai \u2013 Turn Figma Designs into Code: React, React Native, HTML-CSS"}, "url": {"matchLevel": "none", "matchedWords": [], "value": "https://www.locofy.ai"}}, "_tags": ["story", "author_honey_m", "story_32135638", "show_hn"], "author": "honey_m", "children": [32138326], "created_at": "2022-07-18T07:31:40Z", "created_at_i": 1658129500, "num_comments": 2, "objectID": "32135638", "points": 6, "story_id": 32135638, "story_text": "Hey there, I am Honey - Co-founder at Locofy.<p>We, along with other makers, have been building Locofy.ai to help massively accelerate the builders - the designers, developers, product managers &amp; founders, and we&#x27;re excited to share it today with the HN Community.<p>Locofy.ai simply converts designs into production-ready frontend code for web and mobile apps. It adapts to your preferred design tools, tech stack, and workflows with ease and lets you launch upto 4x faster, while letting designers design the way they want and giving high-quality responsive code that developers love.<p>With this launch, you can convert your Figma designs into React, React Native, Next.js, Gatsby, and HTML-CSS code. You get a live-responsive prototype that runs on code (we call these \u2018real-fidelity prototypes\u2019) and when good to go, you can either export the code to build on top of it or directly deploy to Netlify, Vercel, or Github.<p>Today, we have also launched on Product Hunt. Let us know your thoughts and suggestions: <a href=\"https:&#x2F;&#x2F;www.producthunt.com&#x2F;posts&#x2F;locofy-ai\" rel=\"nofollow\">https:&#x2F;&#x2F;www.producthunt.com&#x2F;posts&#x2F;locofy-ai</a>.<p>Our team will be answering all your questions!", "title": "Show HN: Locofy.ai \u2013 Turn Figma Designs into Code: React, React Native, HTML-CSS", "updated_at": "2024-09-20T11:36:36Z", "url": "https://www.locofy.ai"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "NicolasRz_"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["netlify", "production"], "value": "Hello all.<p>A few weeks ago, I was building two showcase sites.<p>The first with wordpress and the second without (just html/css/js on <em>netlify</em>)<p>And like everytime, my customers wanted a contact form.<p>For the website on <em>netlify</em>, I was like, damn I need to get a server and configure a smtp only to send email to my customer from his website....<p>For the wordpress website, I have used ContactForm7 and EasySmtp to achieve this.\nBut I needed gmail email/password from my customer ... Explaining why I needed these information... \nEverytime it's complicate and/or boring<p>And I thought, really ? there are not easier thant all of that ?<p>No.<p>So I decided to build a NoSmtp.<p>A wordpress plugin that send email without any configuration.\nOf course, I need at least email of my client, to send email to him and the website address.\nOk it's now built and workind on <em>production</em>.<p>Ok I solved the wordpress problem.<p>Next.<p>My NoSmtp can work with a simple ajax call. But I wanted something else, something that need no code, that anyone could use.\nSo I built a Chrome Extension, where you can click on your inputs form (email/subject/ body something like that). \nThe next step is just to include in your html head a simple js link. And it's working.<p>The extension chrome and the javascript code is not ready to be in prod, but almost !<p>That's all.<p>My NoSmtp through by Mailjet and a paid plan of course, to emails reach their destination !<p>I came here to have your feedbacks, what's do you think about that ? It's something useless, not interesting ? or something that could be help some person ?<p>I made a demo for the wordpress plugin, that you can see here : https://www.youtube.com/watch?v=w-ZyaIiuEg8&amp;feature=youtu.be\nAnother video will come for the chrome extension ^^<p>Thanks in advance :)<p>Link to the website : https://bit.ly/39r0Hvr"}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Send email without any SMTP"}}, "_tags": ["story", "author_NicolasRz_", "story_23937435", "ask_hn"], "author": "NicolasRz_", "children": [23937684, 23945520, 23947802, 23950431], "created_at": "2020-07-24T09:22:03Z", "created_at_i": 1595582523, "num_comments": 7, "objectID": "23937435", "points": 3, "story_id": 23937435, "story_text": "Hello all.<p>A few weeks ago, I was building two showcase sites.<p>The first with wordpress and the second without (just html&#x2F;css&#x2F;js on netlify)<p>And like everytime, my customers wanted a contact form.<p>For the website on netlify, I was like, damn I need to get a server and configure a smtp only to send email to my customer from his website....<p>For the wordpress website, I have used ContactForm7 and EasySmtp to achieve this.\nBut I needed gmail email&#x2F;password from my customer ... Explaining why I needed these information... \nEverytime it&#x27;s complicate and&#x2F;or boring<p>And I thought, really ? there are not easier thant all of that ?<p>No.<p>So I decided to build a NoSmtp.<p>A wordpress plugin that send email without any configuration.\nOf course, I need at least email of my client, to send email to him and the website address.\nOk it&#x27;s now built and workind on production.<p>Ok I solved the wordpress problem.<p>Next.<p>My NoSmtp can work with a simple ajax call. But I wanted something else, something that need no code, that anyone could use.\nSo I built a Chrome Extension, where you can click on your inputs form (email&#x2F;subject&#x2F; body something like that). \nThe next step is just to include in your html head a simple js link. And it&#x27;s working.<p>The extension chrome and the javascript code is not ready to be in prod, but almost !<p>That&#x27;s all.<p>My NoSmtp through by Mailjet and a paid plan of course, to emails reach their destination !<p>I came here to have your feedbacks, what&#x27;s do you think about that ? It&#x27;s something useless, not interesting ? or something that could be help some person ?<p>I made a demo for the wordpress plugin, that you can see here : https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=w-ZyaIiuEg8&amp;feature=youtu.be\nAnother video will come for the chrome extension ^^<p>Thanks in advance :)<p>Link to the website : https:&#x2F;&#x2F;bit.ly&#x2F;39r0Hvr", "title": "Send email without any SMTP", "updated_at": "2024-09-20T06:36:03Z"}, {"_highlightResult": {"author": {"matchLevel": "none", "matchedWords": [], "value": "kalashvasaniya"}, "story_text": {"fullyHighlighted": false, "matchLevel": "full", "matchedWords": ["netlify", "production"], "value": "Everything you need to go from 0 to launch:<p>Authentication \u2013 Powered by Supabase + Auth.js with Magic Links (signup, login, logout)<p>Database \u2013 MongoDB &amp; Supabase to store all user actions<p>Payments \u2013 Fully integrated with Stripe, LemonSqueezy &amp; DodoPayments<p>Security \u2013 Fully protected routes and APIs<p>Frontend \u2013 Clean, blazing-fast UI/UX built with Next.js<p>Backend \u2013 Logic-ready with Node.js, JavaScript &amp; TypeScript<p>Notifications \u2013 Built-in email and push notifications via Resend (with custom templates via Newdot Email)<p>Analytics \u2013 Track everything with Vercel Analytics &amp; DataFast<p>Hosting \u2013 Deploy to Vercel, <em>Netlify</em>, Render, or AWS \u2014 your choice<p>Support \u2013 Real-time feedback and support with Crisp &amp; Insight<p>Legal Pages \u2013 Terms, Privacy Policy, and Imprint included with ready-made prompts<p>SEO &amp; Marketing \u2013 Meta tags, social previews, and more<p>Performance \u2013 Optimized for 100% uptime<p>Would you buy this if I built it as a <em>production</em>-ready boilerplate with clean code and solid documentation?<p>Drop a  if you\u2019re in."}, "title": {"matchLevel": "none", "matchedWords": [], "value": "Ask HN: Would you buy full-featured, well-documented boilerplate if I built it?"}}, "_tags": ["story", "author_kalashvasaniya", "story_43664885", "ask_hn"], "author": "kalashvasaniya", "children": [43664927], "created_at": "2025-04-12T14:51:03Z", "created_at_i": 1744469463, "num_comments": 2, "objectID": "43664885", "points": 3, "story_id": 43664885, "story_text": "Everything you need to go from 0 to launch:<p>Authentication \u2013 Powered by Supabase + Auth.js with Magic Links (signup, login, logout)<p>Database \u2013 MongoDB &amp; Supabase to store all user actions<p>Payments \u2013 Fully integrated with Stripe, LemonSqueezy &amp; DodoPayments<p>Security \u2013 Fully protected routes and APIs<p>Frontend \u2013 Clean, blazing-fast UI&#x2F;UX built with Next.js<p>Backend \u2013 Logic-ready with Node.js, JavaScript &amp; TypeScript<p>Notifications \u2013 Built-in email and push notifications via Resend (with custom templates via Newdot Email)<p>Analytics \u2013 Track everything with Vercel Analytics &amp; DataFast<p>Hosting \u2013 Deploy to Vercel, Netlify, Render, or AWS \u2014 your choice<p>Support \u2013 Real-time feedback and support with Crisp &amp; Insight<p>Legal Pages \u2013 Terms, Privacy Policy, and Imprint included with ready-made prompts<p>SEO &amp; Marketing \u2013 Meta tags, social previews, and more<p>Performance \u2013 Optimized for 100% uptime<p>Would you buy this if I built it as a production-ready boilerplate with clean code and solid documentation?<p>Drop a  if you\u2019re in.", "title": "Ask HN: Would you buy full-featured, well-documented boilerplate if I built it?", "updated_at": "2025-04-18T05:08:42Z"}], "hitsPerPage": 15, "nbHits": 31, "nbPages": 3, "page": 0, "params": "query=netlify+production&tags=story&hitsPerPage=15&advancedSyntax=true&analyticsTags=backend", "processingTimeMS": 10, "processingTimingsMS": {"_request": {"roundTrip": 14}, "afterFetch": {"format": {"highlighting": 1, "total": 2}}, "fetch": {"query": 6, "scanning": 2, "total": 9}, "total": 10}, "query": "netlify production", "serverTimeMS": 13}}